{"noir_version":"1.0.0-beta.15+1a930357477fc0c210dc5a8960680282d4cfa24e","name":"SimpleLogging","functions":[{"name":"__aztec_nr_internals__get_counter","hash":"2784857623301695217","is_unconstrained":true,"custom_attributes":["abi_utility"],"abi":{"parameters":[{"name":"owner","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"}],"return_type":{"abi_type":{"kind":"integer","sign":"unsigned","width":64},"visibility":"public"},"error_types":{"361444214588792908":{"error_kind":"string","string":"attempt to multiply with overflow"},"992401946138144806":{"error_kind":"string","string":"Attempted to read past end of BoundedVec"},"1998584279744703196":{"error_kind":"string","string":"attempt to subtract with overflow"},"3080037330898348111":{"error_kind":"fmtstring","length":132,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"4261968856572588300":{"error_kind":"string","string":"Value does not fit in field"},"4440399188109668273":{"error_kind":"string","string":"Input length must be a multiple of 32"},"6504742485148360234":{"error_kind":"fmtstring","length":40,"item_types":[]},"7564993426627941149":{"error_kind":"fmtstring","length":48,"item_types":[{"kind":"field"},{"kind":"field"}]},"7995966536718645961":{"error_kind":"fmtstring","length":61,"item_types":[{"kind":"field"},{"kind":"field"}]},"9791669845391776238":{"error_kind":"string","string":"0 has a square root; you cannot claim it is not square"},"9885968605480832328":{"error_kind":"string","string":"Attempted to read past the length of a CapsuleArray"},"10791800398362570014":{"error_kind":"string","string":"extend_from_bounded_vec out of bounds"},"11021520179822076911":{"error_kind":"string","string":"Attempted to delete past the length of a CapsuleArray"},"12469291177396340830":{"error_kind":"string","string":"call to assert_max_bit_size"},"12913276134398371456":{"error_kind":"string","string":"push out of bounds"},"13060541637244024094":{"error_kind":"fmtstring","length":98,"item_types":[]},"13450089406971132036":{"error_kind":"fmtstring","length":144,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"13455385521185560676":{"error_kind":"string","string":"Storage slot 0 not allowed. Storage slots must start from 1."},"14990209321349310352":{"error_kind":"string","string":"attempt to add with overflow"},"15764276373176857197":{"error_kind":"string","string":"Stack too deep"},"16431471497789672479":{"error_kind":"string","string":"Index out of bounds"},"16792019527863081935":{"error_kind":"fmtstring","length":77,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"17154023812102399658":{"error_kind":"fmtstring","length":128,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"17803644318014042523":{"error_kind":"fmtstring","length":58,"item_types":[{"kind":"field"}]}}},"bytecode":"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","debug_symbols":"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Qa1BrUOtQ61DrUOtQ61DrUOtQ61DrUNNoCZQE6gJ1ARqAjWBmkBNoCZQU6gp1BRqCjWFmkJNoaZQU6gp1AxqBjWDmkHNoGZQM6gZ1AxqBjWHmkPNoeZQc6g51BxqDjWHmkNtQG1AbUBtQG1AbUBtQG1AbUBtlJo8HkACMrABO1CACjSgA6GGXCLIJYJcIsglglwiyCWCXCLIJYJcIsglglwiyCWCXCLIJYJcIsglglwiyCWCXCLIJYJcIsglglwiyCWCXCLIJYJcIsglglwiyCWCXCLIJYJcIsglglwiyCWCXCLIJYJcIsglglwiyCWCXCLIJYJcIsglglwiyCWCXCLIJYJcIsglglwiyCWCXCLIJYJcIsglglwiyCWCXCLIJYJcIsglglwiyCWCXCLIJYJcIsglglwiyCWCXCLIJYJcIsglglwiyCWCXCLIJYJcIsglglwiyCWCXCLIJYJcIsglglwiyCWKXKLIJYpcosglilyiyCWKXKLIJYpcosglilyiyCWKXKLIJYpcosglilyiyCWKXKLIJYpcosglilyiyCWKXKLIJYpcosglilyiyCWKXKLIJYpcosglilyiyCWKXKLIJYpcosglilyiyCWKXKLIJYpcosglilyiyCWKXKLIJYpcosglilyiyCWKXKLIJYpcosglilyiyCWKXKLIJYpcosglilyiyCWKXKLIJYpcosglilyiyCWKXKLIJYpcosglilyiyCWKXKLIJYpcosglilyiyCWKXKLIJYpcosglilyiyCWKXKLIJYpcosglilyiyCWKXKLIJYpcosglhlwSZZ7PtY9ABjZgBwpQgQZ04CiMXHIh1AhqBDWCGkGNoEZQI6gR1BhqDDWGGkMtcsn8rAhH+WeiAkMtGipyyYWjMHJJo0ACMrABO1CACjSgA0dhh1qHWodah1qHWodah1qHWoda5JIWrRO55EICMrABO1CACjSgA6GmUFOoKdQUago1hZpCTaGmUFOoGdQMagY1g5pBzaBmUDOoGdQMag41h5pDzaHmUHOoOdQcag41h9qA2oDagNqA2oDagNqA2oDagNootagkTSQgAxuwAwWoQAM6EGoENYIaQY2gRlAjqBHUCGoENYIaQ42hxlBjqDHUGGoMNYYaQ42h1qDWoNag1qDWoNag1qDWoNag1qDWodah1qHWodah1qHWodah1qGG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","expression_width":{"Bounded":{"width":4}}},{"name":"__aztec_nr_internals__increment","hash":"9360149237284123513","is_unconstrained":true,"custom_attributes":["abi_public"],"abi":{"parameters":[{"name":"owner","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"}],"return_type":null,"error_types":{"459713770342432051":{"error_kind":"string","string":"Not initialized"},"13455385521185560676":{"error_kind":"string","string":"Storage slot 0 not allowed. Storage slots must start from 1."},"14990209321349310352":{"error_kind":"string","string":"attempt to add with overflow"},"15764276373176857197":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"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","debug_symbols":"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","expression_width":{"Bounded":{"width":4}}},{"name":"__aztec_nr_internals__initialize","hash":"13852815293007522567","is_unconstrained":true,"custom_attributes":["abi_public","abi_initializer"],"abi":{"parameters":[{"name":"headstart","type":{"kind":"integer","sign":"unsigned","width":64},"visibility":"private"},{"name":"owner","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"}],"return_type":null,"error_types":{"9967937311635654895":{"error_kind":"string","string":"Initialization hash does not match"},"13455385521185560676":{"error_kind":"string","string":"Storage slot 0 not allowed. Storage slots must start from 1."},"14415304921900233953":{"error_kind":"string","string":"Initializer address is not the contract deployer"},"14990209321349310352":{"error_kind":"string","string":"attempt to add with overflow"},"15764276373176857197":{"error_kind":"string","string":"Stack too deep"},"16431471497789672479":{"error_kind":"string","string":"Index out of bounds"}}},"bytecode":"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","debug_symbols":"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","expression_width":{"Bounded":{"width":4}}},{"name":"process_message","hash":"15391637051732047541","is_unconstrained":true,"custom_attributes":["abi_utility"],"abi":{"parameters":[{"name":"message_ciphertext","type":{"kind":"struct","path":"std::collections::bounded_vec::BoundedVec","fields":[{"name":"storage","type":{"kind":"array","length":17,"type":{"kind":"field"}}},{"name":"len","type":{"kind":"integer","sign":"unsigned","width":32}}]},"visibility":"private"},{"name":"message_context","type":{"kind":"struct","path":"aztec::messages::processing::message_context::MessageContext","fields":[{"name":"tx_hash","type":{"kind":"field"}},{"name":"unique_note_hashes_in_tx","type":{"kind":"struct","path":"std::collections::bounded_vec::BoundedVec","fields":[{"name":"storage","type":{"kind":"array","length":64,"type":{"kind":"field"}}},{"name":"len","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"first_nullifier_in_tx","type":{"kind":"field"}},{"name":"recipient","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}}]},"visibility":"private"}],"return_type":null,"error_types":{"361444214588792908":{"error_kind":"string","string":"attempt to multiply with overflow"},"992401946138144806":{"error_kind":"string","string":"Attempted to read past end of BoundedVec"},"1998584279744703196":{"error_kind":"string","string":"attempt to subtract with overflow"},"3080037330898348111":{"error_kind":"fmtstring","length":132,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"4261968856572588300":{"error_kind":"string","string":"Value does not fit in field"},"4440399188109668273":{"error_kind":"string","string":"Input length must be a multiple of 32"},"6504742485148360234":{"error_kind":"fmtstring","length":40,"item_types":[]},"7564993426627941149":{"error_kind":"fmtstring","length":48,"item_types":[{"kind":"field"},{"kind":"field"}]},"7995966536718645961":{"error_kind":"fmtstring","length":61,"item_types":[{"kind":"field"},{"kind":"field"}]},"9791669845391776238":{"error_kind":"string","string":"0 has a square root; you cannot claim it is not square"},"9885968605480832328":{"error_kind":"string","string":"Attempted to read past the length of a CapsuleArray"},"10791800398362570014":{"error_kind":"string","string":"extend_from_bounded_vec out of bounds"},"11021520179822076911":{"error_kind":"string","string":"Attempted to delete past the length of a CapsuleArray"},"12469291177396340830":{"error_kind":"string","string":"call to assert_max_bit_size"},"12913276134398371456":{"error_kind":"string","string":"push out of bounds"},"13060541637244024094":{"error_kind":"fmtstring","length":98,"item_types":[]},"13450089406971132036":{"error_kind":"fmtstring","length":144,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"14990209321349310352":{"error_kind":"string","string":"attempt to add with overflow"},"15764276373176857197":{"error_kind":"string","string":"Stack too deep"},"16431471497789672479":{"error_kind":"string","string":"Index out of bounds"},"16792019527863081935":{"error_kind":"fmtstring","length":77,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"17154023812102399658":{"error_kind":"fmtstring","length":128,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"17803644318014042523":{"error_kind":"fmtstring","length":58,"item_types":[{"kind":"field"}]}}},"bytecode":"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","debug_symbols":"tP3NkiW7jqSJvssZ12ARJEAyX6UHJdnd2S0pkpLVUpV1Jyn17ncZQEA1YpebW7j7npz4sE8ElEYj1P5gtv7zH//3v/yf//P//a//+u//z3/7H//4p//jP//xf/73f/23f/vX//e//tt/+7/++T/+9b/9+/u//uc/Xtf/TPvHP/X/8o85//FP+v5jxR/b/1iv+KPFHxJ/9PhjxB8af1j8EVlWZFmRZUeWHVl2ZNmRZUeWHVl2ZNmRZUeWHVna63X+bOdPOX/28+c4f+r5086f8/y5zp8nXzv52snXTr528rWTr5187eRrJ187+drJJyefnHxy8snJJyefnHxy8snJJyefnHz95OsnXz/5+snXT75+8vWTr598/eTrJ984+cbJN06+cfKNk2+cfOPkGyffOPnGyacnn558evLpyafvfPP6U8+fdv6c5893vva6YB+wV8I7ZesXvHO26y9bTxgJmmAJM+GdWdoF+8B8JbSEd2aRC3rCSLgyX1twlUbATLgyrwv2gatEAlqCJPSEkaAJljATMvPKzDsz78x8lU6/5ucqnoCRoAmWMBNWwg6Qq5ICWoIk9ISRoAmWMBNWQmZumbll5paZW2Zumbll5paZW2a+aqvLBfvAVV0BLUESesJI0ARLmAmZWTJzz8w9M/fM3DNzz8w9M/fM3DNzz8w9M4/MPDLzyMwjM4/MPDLzyMwjM4/MPDKzZmbNzJqZNTNrZtbMrJlZM7NmZs3MlpktM1tmtsxsmdkys2Vmy8yWmS0zz8w8M/PMzDMzz8w8M/PMzDMzz8w8M/PKzCszr8y8MvNVg10v0ARLmAkrYR+4ajCgJUhCT8jMOzPvzOw1uC5YCTugXzU4+gUtQRJ6wkjQBEuYCSthH2iZuWXmlpnbcaTeRoImWMJMWAnHkbq8ElqCJGRmycySma8aHHbBTFgJ+8BVgwEtQRJ6wkjQhMzcM3PPzD0zXzU45gUtQRJ6wkjQBEuYCSthH9DMrJlZM7MfAscFI0ETLGEmrIR94KrBgJYgCZnZMrNlZsvMlpktM1tmnpl5ZuaZmWdmnpl5ZuaZmWdmnpl5ZuaVmVdmXpl5ZeaVmVdmXpl5ZeaVmVdm3pl5Z+admXdm3pl5Z+admXdm3pl5n8zj9UpoCZLQE0aCJljCTFgJmbll5paZW2Zumbll5paZW2Zumbll5paZJTNLZpbMLJlZMrNkZsnMkpklM0tm7pm5Z+aemXtm7pm5Z+aemXtm7pm5Z+aRmUdmHpl5ZOaRmUdmHpl5ZOaRmUdm1sysmVkzc9bgyBocWYMja3BkDY6swZE1OLIGR9bgyBocWYMja3BkDY6swZE1OLIGR9bgyBocWYMja3BkDY6swZE1OLIGR9bgyBocWYMja3BkDY6swZE1OLIGR9bgyBocWYMja3BkDY6swZE1OLIGR9bgyBocWYMja3BkDY6swZE1qFmDmjWoWYOaNahZg5o1qFmDmjWoWYOaNahZg5o1qFmDmjWoWYOaNahZg5o1qFmDmjWoWYOaNahZg5o1qFmDmjWoWYOaNahZg5o1qFmDmjWoWYOaNahZg5o1qFmDmjWoWYOaNahZg5o1qFmDmjWoWYOaNahZg5o1qFmDmjWoWYOaNahZg5o1qFmDmjWoWYOaNahZg5o1qFmDmjWoWYOaNahZg5o1qFmDmjWoWYOaNahZg5o1qFmDmjWoWYOaNahZg5o1qFmDmjWoWYOaNahZg5o1qFmDmjWoWYOaNahZg5o1qFmDmjWoWYOaNahZg5o1qFmDmjWoWYOaNWhZg5Y1aFmDljVoWYOWNWhZg5Y1aFmDljVoWYOWNWhZg5Y1aFmDljVoWYOWNWhZg5Y1aFmDljVoWYOWNWhZg5Y1aFmDljVoWYOWNWhZg5Y1aFmDljVoWYOWNWhZg5Y1aFmDljVoWYOWNWhZg5Y1aFmDljVoWYOWNWhZg5Y1aFmDljVoWYOWNWhZg5Y1aFmDljVoWYOWNWhZg5Y1aFmDljVoWYOWNWhZg5Y1aFmDljVoWYOWNWhZg5Y1aFmDljVoWYOWNWhZg5Y1aFmDljVoWYOWNWhZg5Y1aFmDljVoWYOWNWhZg5Y1aFmDljVoWYOWNWhZg5Y1aFmDljU4swZn1uDMGpxZgzNrcGYNzqzBmTU4swZn1uDMGpxZgzNrcGYNzqzBmTU4swZn1uDMGpxZgzNrcGYNzqzBmTU4swZn1uDMGpxZgzNrcGYNzqzBmTU4swZn1uDMGpxZgzNrcGYNzqzBmTU4swZn1uDMGpxZgzNrcGYNzqzBmTU4swZn1uDMGpxZgzNrcGYNzqzBmTU4swZn1uDMGpxZgzNrcGYNzqzBmTU4swZn1uDMGpxZgzNrcGYNzqzBmTU4swZn1uDMGpxZgzNrcGYNzqzBmTU4swZn1uDMGpxZgzNrcGYNzqzBmTU4swZn1uDMGpxZgzNrcGYNzqzBmTU4swZn1uDMGpxZgytrcGUNrqzBlTW4sgZX1uDKGlxZgytrcGUNrqzBlTW4sgZX1uDKGlxZgytrcGUNrqzBlTW4sgZX1uDKGlxZgytrcGUNrqzBlTW4sgZX1uDKGlxZgytrcGUNrqzBlTW4sgZX1uDKGlxZgytrcGUNrqzBlTW4sgZX1uDKGlxZgytrcGUNrqzBlTW4sgZX1uDKGlxZgytrcGUNrqzBlTW4sgZX1uDKGlxZgytrcGUNrqzBlTW4vAbnBfuA16DDO7O1CyShJ4wETbCEmbAS9oGrBgMy88rMKzOvzLwy88rMKzOvzLwy887MOzPvzLwz887MOzPvzLwz887M+2Ter1dCS5CEnjASNMESZsJKyMwtM7fM3DJzy8wtM7fM3DJzy8wtM7fMLJlZMrNkZsnMkpklM0tmlswsmVkyc8/MPTP3zNwzc8/MPTP3zNwzc8/MPTOPzDwy88jMIzOPzDwy88jMIzOPzDwys2ZmzcyamTUza2bWzKyZWTOzZmbNzJaZLTNbZrbMbJnZMrNlZsvMlpktM8/MnDW4swZ31uDOGtxZgztrcGcN7qzBnTW4swZ31uDOGtxZgztrcGcN7qzBnTW4swZ31uDOGtxZgztrcGcN7qzBnTW4swZ31uDOGtxZg+8n7a+iViRFvWgUaZEVzaJVVBqtNFpptNJopdFKo5VGK41WGq00WmlIaUhpSGlIaUhpSGlIaUhpSGlIafTS6KXRS6OXRi+NXhq9NHpp9NLopTFKY5TGKI1RGqM0RmmM0hilMUpjlIaWhpaGloaWhpaGloaWhpaGloaWhpWGlYaVhpWGlYaVhpWGlYaVhpXGLI1ZGrM0ZmnM0pilMUtjlsYsjVkaqzRWaazSWKWxSmOVxiqNVRqrNFZp7NLYpbFLY5fGLo1dGrs0dmns0qg6b1Xnreq8VZ23qvNWdd6qzlvVeas6b1Xnreq8VZ23qvNWdd6qzlvVeas6b1Xnreq8VZ23qvNWdd6qzlvVeas6b1Xnreq8VZ23qvNWdd6qzlvVeas6b1Xnreq8VZ23qvNWdd6qzlvVeas6b1Xnreq8VZ23qvNWdd6qzlvVeas6b1Xnreq8VZ23qvNWdd6qzlvVeas6b1Xnreq8VZ23qvNWdd6qzlvVeas6b1Xnreq8VZ23qvNWdd6qzlvVeas6b1Xnreq8VZ23qvNWdd6qzlvVeas6b1Xnreq8VZ23qvNWdd6qzlvVeas6b1Xnreq8VZ23qvNWdd6qzlvVeas6b1Xnreq8VZ23qnOpOpeqc6k6l6pzqTqXqnOpOpeqc6k6l6pzqTqXqnOpOpeqc6k6l6pzqTqXqnOpOpeqc6k6l6pzqTqXqnOpOpeqc6k6l6pzqTqXqnOpOpeqc6k6l6pzqTqXqnOpOpeqc6k6l6pzqTqXqnOpOpeqc6k6l6pzqTqXqnOpOpeqc6k6l6pzqTqXqnOpOpeqc6k6l6pzqTqXqnOpOpeqc6k6l6pzqTqXqnOpOpeqc6k6l6pzqTqXqnOpOpeqc6k6l6pzqTqXqnOpOpeqc6k6l6pzqTqXqnOpOpeqc6k6l6pzqTqXqnOpOpeqc6k6l6pzqTqXqnOpOpeqc6k6l6rzXnXeq8571XmvOu9V573qvFed96rzXnXeq8571XmvOu9V573qvFed96rzXnXeq8571XmvOu9V573qvFed96rzXnXeq8571XmvOu9V573qvFed96rzXnXeq8571XmvOu9V573qvFed96rzXnXeq8571XmvOu9V573qvFed96rzXnXeq8571XmvOu9V573qvFed96rzXnXeq8571XmvOu9V573qvFed96rzXnXeq8571XmvOu9V573qvFed96rzXnXeq8571XmvOu9V573qvFed96rzXnXeq8571XmvOvdGJYseai2yoktjOq2ineR1HtSKpKgXjSItsqLS2KWxU8Mblw61IinqRaNIi6xoFq2i0mil0UqjlUYrjVYarTRaabTSaKXRSkNKQ0pDSkNKQ0pDSkNKQ0pDSkNKo5dGL41eGr00emn00uil0Uujl0YvjVEaozRGaYzSGKUxSmOUxiiNURqjNLQ0tDS0NLQ0tDS0NLQ0tDS0NLQ0rDSsNKw0rDSsNKw0rDSsNKw0rDRmaczSmKUxS2OWxiyNWRqzNGZpzNJYpbFKY5XGKo1VGqs0VmlUnY+q81F1PqrOR9W5N0XZdupFo0iLrGgWraJ9yJujDrUiKepFo0iLrGgWraLSaKXRSqOVRiuNVhqtNFpptNJopdFKQ0pDSkNKQ0pDSkNKQ0pDSkNKQ0qjl0YvjV4avTR6afTS6KXRS6OXRi+NURqjNEZpjNIYpTFKY5TGKI1RGqM0tDS0NLQ0tDS0NLQ0tDS0NLQ0tDSsNKw0rDSsNKw0rDSsNKw0rDSsNGZpzNKYpTFLY5bGLI1ZGrM0ZmnM0lilsUpjlcYqjVUaqzRWaazSWKWxSmOXxi6NqnOtOteqc60616pzrTrXqnOtOreqc6s6t6pzqzq3qnOrOreqc6s6t6pzqzq3qnOrOreqc6s6t6pzqzq3qnOrOreqc6s696asOZxakRT1olGkRVY0i1bRTuql0Uujl0YvjV4avTR6afTS6KXRS2OUxiiNURqjNEZpXHU+zcmKZtEq2klXnR9qRVLUi0ZRaWhpaGlcdb7EaSdddX6oFUlRLxpFWmRFs6g0rjpf/obeVeeHWpEU9aJRpEVWNItWUWms0lilsUrjqvOlTqNIi6xoFq2inXTV+aFWJEWlsUtjl8YujV0auzR2aniT16FWJEW9aBRpkRXNolVUGq00Wmm00mil0UqjlUYrjVYaV50vc9pJV50fujSmkxT1orfGfjlpkRXNolW0k646P9SKpKgXlUYvjV4avTR6afTSGKUxSmOUxiiNURqjNEZpjNIYpTFKQ0tDS0NLQ0tDS0NLQ0tDS0NLQ0vDSsNKw0rDSsNKw0rDSsNKw0rDSmOWxiyNWRqzNGZpzNKYpTFLY5bGLI1VGqs0Vmms0lilsUpjlcYqjVUaqzR2aezS2KWxS2OXxi6NXRq7NHZp7NTwRrJDrUiKetEo0iIrmkWrqDRaabTSaKXRSqOVRiuNVhqtNFpptNKQ0pDSkNKQ0qg6X1Xnq+p8VZ2vqvNVdb6qzlfV+ao6X1Xnq+p8VZ2vqvNVdb6qzlfV+ao6X1Xnq+p8VZ2vqvNVdb6qzlfV+ao6X1Xnq+p8VZ2vqvNVdb6qzlfV+ao6X1Xnq+p8VZ2vqvNVdb6qzlfV+ao6X1Xnq+p8VZ2vqvNVdb6qzlfV+ao6X1Xnq+p8VZ2vqvNVdb6qzlfV+ao6X1Xnq+p8VZ2vqvNVdb6qzlfV+ao6X1Xnq+p8VZ2vqvNVde5tars7aZEVzaJVtA95s9qhViRFvWgUaZEVXcfaeON/Fe0kP54HtSIp6kWjSIusqDRaabTSkNKQ0pDSkNKQ0pDSkNKQ0pDSkNLopdFLo5dGL41eGr00emn00uil0UtjlMYojVEaozRGaYzSGKUxSmOUxigNLQ0tDS0NLQ0tDS0NLQ0tDS0NLQ0rDSsNKw0rDSsNKw0rDSsNKw0rjVkaszRmaczSmKUxS2OWxiyNWRqzNFZprNJYpbFKY5XGKo1VGqs0Vmms0tilsUtjl8YujV0auzR2aezS2KWxj4Z4P9xWp1YkRVedm9Mo0iIrmkWraCf58TyoFUlRabTSaKXRSqOVRiuNVhpSGlIaUhpSGlIaUhpSGlIaUhpSGr00emn00uil0Uujl0YvjV4avTR6aYzSGKUxSmOUxiiNURqjNEZpjNIYpaGloaWhpaGloaWhpaGloaWhpaGlYaVhpWGl4cdzX39+PA/SIrs+ltMcJ3ABd+FV64kNKMAOHEAFQm1CbUJtQm1BbUFtQW1BbUFtQW1BbUFtQW1BbUNtQ21DbUNtQ21DbUNtQ21DbZead8wlNqAAO3AAFWjACVxAqDWoNag1qDWoNag1qDWoNag1qDWoCdQEagI1gZpATaAmUBOoCdQEah1qHWodah1qHWodah1qHWodah1qA2oDagNqA2oDagNqA2oDagNqA2oKNYWaQk2hplBTqCnUFGoKNYWaQc2gZlAzqBnUDGrwkgYvafCSBi9p8JIGL2nwkgYvafCSBi9p8JIGL2nwkgYvafCSBi9p8JIGL2nwkgYvafCSBi9p8JIGL2nwkgYvafCSBi9p8JIGL2nwkgYvafCSBi8ReInASwReIvASgZcIvETgJQIvEXiJwEsEXiLwEoGXCLxE4CUCLxF4icBLBF4i8BKBlwi8ROAlAi8ReInASwReIvASgZcIvETgJQIvEXiJwEsEXiLwEoGXCLxE4CUCLxF4icBLBF4i8BKBlwi8ROAlAi8ReInASwReIvASgZcIvETgJQIvEXiJwEsEXiLwEoGXCLxE4CUCLxF4icBLBF4i8BKBlwi8ROAlAi8ReInASwReIvASgZcIvETgJQIvEXiJwEsEXiLwEoGXCLxE4CUCLxF4icBLBF4i8BKBlwi8ROAlAi8ReInASwReIvCSDi/p8JIOL+nwkg4v6fCSDi/p8JIOL+nwkg4v6fCSDi/p8JIOL+nwkg4v6fCSDi/p8JIOL+nwkg4v6fCSDi/p8JIOL+nwkg4v6fCSDi/p4SXDUYAdOIAKNOAELuAuDC8JhNqA2oDagNqA2oDagNqA2oCaQk2hplBTqCnUFGrhJdNxAhfQ1a4rlB5eEtiAAuzAAVSgASdwAaE2oTahNqE2oTahNqE2oTahNqE2obagtqC2oLagtqC2oLagtqC2oLagtqG2obahtqG2obahtqG2obahtkttvF7ABhRgBw6gAg04gQsItQa1BrUGtQa1BrUGtQa1BrUGtQY1gZpATaAmUBOoCdQEagI1gZpArUOtQ61DrUPNveT6+q14A2KiAS+166u44j2IibvQveRgAwqwAwdQgQaE2oDagJpCTaGmUFOoKdQUago1hZpCTaFmUDOoGdQMagY1g5pBzaBmUDOoTahNqE2oTahNqE2oTahNqE2oTagtqC2oLagtqC2oLagtqC2oLagtqG2obahtqG2obahtqG2obahtqO1S8w7GxAYUYAcOoAINOIELCLUGtQa1BrUGtQa1BrUGtQa1BrUGNYGaQE2gJlATqAnUBGoCNYGaQK1DrUOtQ61DrUOtQ61DDV6i8BKFlyi8ROElCi9ReInCSxReovAShZcovEThJQovUXiJwksUXqLwEoWXKLxE4SUKL1F4icJLFF6i8BKFlyi8ROElCi9ReInCSxReovAShZcovEThJQovUXiJwksUXqLwEoWXKLxE4SUKL1F4icJLFF6i8BKFlyi8ROElCi9ReInCSxReovAShZcovEThJQovUXiJwUsMXmLwEoOXGLzE4CUGLzF4icFLDF5i8BKDlxi8xOAlBi8xeInBSwxeYvASg5cYvMTgJQYvMXiJwUsMXmLwEoOXGLzE4CUGLzF4icFLDF5i8BKDlxi8xOAlBi8xeInBSwxeYvASg5cYvMTgJQYvMXiJwUsMXmLwEoOXGLzE4CUGLzF4icFLDF5i8BKDlxi8xOAlBi8xeInBSwxeYvASg5cYvMTgJQYvMXiJwUsMXmLwEoOXGLzE4CUGLzF4icFLDF5i8BKDlxi8xOAlBi8xeInBSwxeYvASg5cYvMTgJQYvMXiJwUsMXmLwEoOXTHjJhJdMeMmEl0x4yYSXTHjJhJdMeMmEl0x4yYSXTHjJhJdMeMmEl0x4yYSXTHjJhJdMeMmEl0x4yYSXTHjJhJdMeMmEl0x4yYSXzPASc2xAAXbgACrQgBO4gLtwQG1AbUBtQG1AbUBtQG1AbUBtQE2hplBTqLmXSPxgwQAq8FITnyj3koMLeKnJdevEuzgTG1CAHTiACjTgBC4g1CbUJtQm1CbUJtQm1CbUJtTcS8Rnx70k0L3kYAMKsAMHUIEGnECoLahtqG2obahtqG2obahtqG2obajtUvNuz8QGFGAHDqACDTiBCwi1BrUGtQa1BrUGtQa1BrUGtQa1BjWBmkBNoCZQE6gJ1ARqAjWBmkCtQ61DrUOtQ61DrUOtQ61DrUOtQ21AbUBtQG1AbUBtQG1AbUBtQG1ATaGmUFOoKdQUago1hZpCTaGmUDOoGdQMagY1g5pBzaBmUDOoGdQm1CbUJtQm1CbUJtQm1CbU4CULXrLgJQtesuAlC16y4CULXrLgJQtesuAlC16y4CULXrLgJQtesuAlC16y4CULXrLgJQtesuElG16y4SUbXrLhJRtesuElG16y4SUbXrLhJRtesuElG16y4SUbXrLhJRtesuElG16y4SUbXrLhJRtesuElG16y4SUbXrLhJRtesuElG16y4SUbXrLhJRtesuElG16y4SUbXrLhJRtesuElG16y4SUbXrLhJRtesuElG16y4SUbXrLhJRtesuElG16y4SU7vGQ5LuAuDC8JbEABduAAKtCAUDOoGdQm1CbUJtQm1CbUJtQm1CbUJtQm1BbUFtQW1BbUFtQW1BbUFtQW1BbUNtQ21DbUNtQ21DbUNtQ21DbUdqr11+sFbEABduAAKtCAE7iAUGtQa1BrUGtQa1BrUGtQa1BzL7l+FK57I+tB95KDl9r1G1/de1kTO3AAFWjACVzAXehechBqHWodah1qHWodah1qHWodagNqA2oDagNqA2oDagNqA2oDagNqCjWFmkJNoaZQU6gp1BRqCjWFmkHNoGZQM6gZ1AxqBjWDmkHNoDahNqE2oTahNqE2oTahNqE2oTahtqC2oLagtqC2oLagtqC2oLagtqC2obahtqG2obahtqG2obahtqG2Sy36Xg82oAA7cAAVaMAJXECoNag1qDWoNag1qDWoNag1qDWoNagJ1OAlDV7S4CUNXtLgJQ1e0uAlDV7S4CUNXtLgJQ1e0uAlDV7S4CUNXtLgJQ1e0uAlDV7S4CUNXtLgJQ1e0uAlDV7S4CUNXtLgJQ1e0uAlDV7S4CUNXtLgJQ1e0uAlDV7S4CUNXtLgJQ1e0uAlDV7S4CUNXtLgJQ1e0uAlDV7S4CUNXtLgJQ1e0uAlDV7S4CUNXtLgJQ1e0uAlDV7S4CUNXtLgJQ1e0uAlDV7S4CUNXtLgJQ1e0uAlDV7S4CUNXtLgJQ1e0uAlAi8ReInASwReIvASgZcIvETgJQIvEXiJwEsEXiLwEoGXCLxE4CUCLxF4icBLBF4i8BKBlwi8ROAlAi8ReInASwReIvASgZcIvETgJQIvEXiJwEsEXiLwEoGXCLxE4CUCLxF4icBLBF4i8BKBlwi8ROAlAi8ReInASwReIvASgZcIvETgJQIvEXiJwEsEXiLwEoGXCLxE4CUCLxF4icBLBF4i8BKBlwi8ROAlAi8ReInASwReIvASgZcIvETgJQIvEXiJwEsEXiLwEoGXCLxE4CUCLxF4SfS9Xr9+26Pv9aAAXW06DqACDTiBC7gTo+/1YAMKsAMH0NWaowEncAF3YXhJYAMKsAMHEGoNag1qDWoNagI1gZpATaAmUBOoCdQEagI1gVqHWodah1qHWodah1qHWodah1qH2oDagNqA2oDagNqA2oDagNqA2oCaQk2hplBTqCnUFGoKNYVaeMl23IXhJYENKMAOHEAFGnACoWZQm1BzLxnLUYAdeKmN+LsKNOClNl6OC7gL3UsONqAAO3AAFWhAqC2oLahtqG2obahtqG2obahtqG2obajtUou+14MNKMAOHEAFGnACFxBqDWoNag1qDWoNag1qDWoNag1qDWoCNYGaQE2gJlATqAnUBGoCNYFah1qHWodah1qHWodah1qHWodah9qA2oDagNqA2oDagNqA2oDagNqAmkJNoaZQU6gp1BRqCjWFmkJNoWZQM6gZ1AxqBjWDmkHNoBb3XtVxF8a918AGFGAHDqACDTiBUJtQW1BbUFtQW1BbUFtQW1BbUFtQW1DbUNtQ21DbUNtQ21DbUNtQ21DbpRZ9rwcbUIAdOIAKNOAELiDUGtQa1BrUGtQa1BrUGtQa1BrUGtQEagI1gZpATaAmUBOoCdQEagK1DrUOtQ61DrUOtQ61DrUOtQ61DrUBtQG1AbUBtQG1AbUBtQG1AbUBNYWaQk2hplBTqCnUFGoKNYWae4leNR99rwcb8FLT7tiBA3ipXb9d16Pv9eAELuAudC852IAC7MABhNqE2oTahNqE2oLagtqC2oLagtqC2oLagtqC2oLahtqG2obahtqG2obahtqG2obaLrXoez3YgALswAFUoAEncAGh1qDWoNag1qDWoNag1qDWoNag1qAmUBOoCdQEagI1gZpATaAmUBOodah1qHWodah1qHWodah1qHWodagNqA2oDagNqA2oDagNqA2oDagNqCnUFGoKNYWaQk2hplBTqLmX6HbcheElgZfa9d38Hn2vBztwABVowAlcwF3oXnIQahNqE2oTahNqE2oTahNqE2oLagtqC2oLagtqC2oLagtqC2oLahtqG2obahtqG2obahtqG2obarvUou/1YAMKsAMHUIEGnMAFhFqDWoNag1qDWoNag1qDWoNag1qDmkBNoCZQE6gJ1ARqAjWBmkBNoNah1qHWodah1qHWodah1qHWodahNqA2oDagNqA2oDag5l5iy3ECF9DVrpKOvteDDXipTXHswAFUoAEncAF3oXvJwQaEmkHNoOZesl6OBpzABdyF7iUHG1CAHTiAUJtQm1BzL7k+e9uj7zXQveSgq/lUu5cc7MBLbQ9HBVpiNFiqk///gf7/m+MELuAu9DV7sAEF6HmXowEncAF3oa/Ogw0owA4cQKgNqA2oDagNqCnUFGoKNYWaQk2hplBTqCnUFGoGNYOaQc2gZlAzqBnUDGoGNYPahNqE2oTahNqE2oTahNqE2oTahNqC2oLagtqC2oLagtqC2oLadaST6xsK3TspD15HusQGFGAHjgt9gV9HukQDTqCr+frdO9E7KeX6JkH3TspEAXbgACrQgJfa9Rp2907KxF14HeneDxUdG1CAl5oXr3dSJirQgBO4gK52ObF3UiY2oAAvNfGRXaaRqMBLTXyiLtdIXMBLTTzZ5RqJDehb0R2vvN6M5d2R4g+CvDtS/JGPd0cmNqAAO3AAPa+rXf6QOIELeKn5vS3vjky81IYP8vKHxA4cQAUa8FIbvgguf0jchfYCutpyFKCr+SBtABVowEvNL7u9OzJxF17+kNiAArzU1Idz+UOiAg3oaj7IuYC7cLlac2xAAU6gZ/Ct8Jo3XwRe8wcb8BqZ+T726vYTEO9tTJzAK+/0venVfeHw3sbEK+91SjC8tzHxmofrtxmG9zYmKvBSu346YXhvY+IC7kKv7oMN6Hmno2dYjp5hO+5Cr9iDDXiNdzXHDhxABRrwUlu+FV6xB3ehV+z14wjD+xUTBdiBA6hAV1PHCVyFXscHPYNPiVfsQc/g+8Ir9uAC+nh9zrxiDzbgNd7t+9gr9uCltn0evGIPXmrbh+4Vu30evGK3D/Kq2PfT4guvik1sQLnQR3ZVbOIAzgtdYnoGl5iewSWmZ/CNn57Bl8b0DL67r3rrzZNd9Za4C696ez84dmxAAeqFrrY8g6stz+DzsF9Az+Bj2J7BJ/U6xiYOoALtQh/vnsAF3IneFZjYgALswCvvdfAZ3un3fqR94XVY7NercsMb+fr1UtzwRr5EA87Cq5wSPcNwHEDPoI7X0K+D2vDWun69pja8tS5Rga62HCdwAXflHa/6r1cxJAqwA0dt8VCgAWehYtu01QapALHFarkevF2ui0/1tex796n2ZR/oy/5gAwqwAwfwGm/3kV0HqsQJdDXfheZqPnQvke6D9BLpPkgvEV+03i6XOICe1+fMS+TgLvQSGT4yL5GDArzGO3xkXiLDR+Yl0n0fe4kc9Aw+Xi+R4eP1Ejk4gAq85mH4BnmJHFzAnejNbokNKMAO9Lzm6BmuQXp/Wr9OD4Z3ovXrtv3wTrTEBdyFXiLXoXl4J1qiADtwABVowAlcwF3Yodah1qHWodah1qHWodah1qHWoTagNqA2oDagNqA2oDag5vWm4tiAAuzAAVSgASdwAXehQc2gZlAzqBnUDGoGNYOaQc2gNqE2oTahNqE2oTahNqG2XM0XoleW+qL1yjJfcl5D192m4R1Y79ixAwfwSmbDcQF3oR8OzBwVaEDPsByvDNOFvQICvQIONqAAO3AAFWjACYSaQM0rwM8GvX8qUYCu5uP1CjiowEvNT+C8fypxAS81P+fy/qnEBrzU/PTL+6cSB1CBBpzABdyFXiIHGxBqCjWFmhfD8o33Ze+ndd4T1f1cznuiEjtwABVowAlcwF3oy/4g1CbUJtQm1CbUJtQm1CbU/JDk557eE5XYgALswAFUoAEncAGhtqG2oealF5Xlh6+DA+h5r0Od9zl1P0H2PqfuJ8je55TYgQOoQANO4ALuwvYCQq1BrUHNa/66Ezm8zynRgBO4gLvQa/5gAwqwA6EmUBOoCdS85q+bW8P7nA56zR9sQAF2oOfdju8Mw686vHdp+EWF9y4lCrADB1CBBpzABdyFCjWFmkJNXU0cB1CBBpzAVWie1/emeQafPlOgAT3DdFzAXThfwAYUYAcOoAINCLUJtelqvlvWC9iAl5pfUXk/UuKl5hdt3o80mk/fVcfDT8e9HylxAS81vybzfqTES82vvrwfafgFk/cjDb9g8n6k4VdJ3o+UaMAJXMCd6J1Hwy8qvMdo+OWD9xgNvzTyHqPEBfQM1yC9xyixAQXYgZ53OXqGa4O8b2j4RYX3DSUKsAMHUIEGnMAFvNT8WsT7hhIb0NV8HnoHDqACXc0nqk/gArqaT5TX8cEGdDV17MABVKABJ9DVfFK9jgO9jg+6mk+11/HBDhzAWWiewXeLV+xBvwPnef1O5MFV6FXo11neyZPYgQOoQANO4ALuQq/Cg67m+8Kr8GAHuoRPlJfewQl0CR+6l16gl95Bl/Ap8dI72IEDqEADTuAC7kRv30lsQAF24AAq0IATuIBQa1BrUGtQa1BrUGtQa1BrrrYdF3AXekn7ZZS37yQK8FK77kwPb99JvNTUHA04gQu4C72kr1vXw9t3El3Nx+sl7Vco3r4z/LLE23cSDXipXbejh7fvJO5CL2m/FvH2nUQBduAAKtDzXgvRW3KGX7d4S87wcvKWnMQBVKCP1zfIi/fgAu5CL+mDl5rfHfeWnPdh0vFSmz4cPzT7ZYm35CReajMyXGp+t9lbchIvNb9B7C05w686vCUn8crrJ//eZjP85N8baoaf/HtDTaIAr5EtF/YD60EFGnACF3AXenX7Sa831CQKcNTIvKQPGvCS8BNk76JJ3IneRfM+5jo2oACvDfKTPe+iSbzU/GzQu2gSJ/Ctpn5i6F00B6+STmxAAXbgACrQgBMItQY1gZpATaAmUBOoCdQEagI1gZpArUOtQ627WnPswAF0te5owAl0Nd9ZfReOF7ABXU0dXc0cXc13y1CgAV3Nd+xYwF2oL2ADCrADB1CBBoSaQk2hZq7mq88aUIAdOIAKNOAEXmp+0utdNAev8k+81PxU2LtoEjtwAC81P1f2LprEWbheQM/gu2V5Bt8tS4EGnIXbM/ge2p7BZ2cPoAINOIELeG2x35b3r7wlNqAAO3AAFWhAV5uOC7gLveYPupo4CtDVhuMAKtDVzHECF3AXes0fbEDP62PwOvYTeu8sUj+h986ig17HBxvwGq8/JfAvtyUOoAINeKn5GbT3GyXuQq/jgw0owEvNTyK93yhRgQa81PyBgfcbJe5Cr2M/4fR+I/U79N5vlOhqPlFexwddzefM6/jgBC7gLvQ6PtiAAuzAAYSaQc2gZlAzqE2oTahNqE2oTahNqE2oTahNqE2oLagtqC2oLagtqC2oLagtqC2oLahtqG2obahtqG2obahtqLk/+Emv9xsl7kTvN0q81Pz81/uNEjtwABVowAlcwF3o/nAQag1qDWoNag1qDWoNag1qDWp+9PeHAN5DpH4W7z1EiZ5hOC7gLnR/ONiAAuxAz6uOtTe9h+jMr9f8QQF2oG+xOSrQgBO4IAE1fQEbUIAdOIBaY4iaD5zABdw1Bq/5gw0INdT8Rs1v1PxGzW/U/EbNb8NKnZjJiZmcmEmv+RjDxExOzCRqfqPmN2p+o+Y3an6j5jdqfqPmd9S8j2FhJhdmcmEmF2bSa94vBr3fKNFn0vN6zR/swAG81PzJlXchJU7gAu6D6l1IiQ0owEvtupxU70JKzAWu3nqk1h0XcBd6oR/MpaGvKPTADhxABRpwAnNnqbcpHZQXsAEF2IEDqEAD+laMC738DzagT5TPg5e/+cj89OCgAg04gQu4C90qDjag552OCjTgBHpe3wo3hUA3hYMN6CdlgR04gAo04AQu4C708m+BHTiACvSt2I5+EukYJ+mBDXjlvW4OqLcpJQ7glXf6+p2GfzaBCwi1BbUFNS/0gx04gAqE2oKE13HzCvA6PtiBPvRABV7Jpi8ur+ODC3gN/erkU+9jSmxAn6jl2IEDqEBX244TuIC70Ev6emlAvf1Jr3sr6u1PiQq88l79curtT4kLuAu9eA82oABdrTsOoAINOIELuAu9pA96MnX0f+bT57V5cBd6bR5sQAH6IH1SvWIPKtCAE7iAu9Ar9qCr+Q7wij3YgQOoQAPO2i1esQd3oR/GD/ramY5as+NlenACF/BKtn1pTEyJl+nBAbzyblfzMj04gVfe7Xt+Ygcs7ICFHbCgtqC2oOZletCA2N0Lu3tBbUNi571BbXHbLdCAPvThuIA70Xup9LrBpt5LlSjA99DtuoWk/uGwRAXahc1xAhdwF15lmtiAAuzAAVQg1BrUGtQa1ARqAjWBmkBNoCZQE6gJ1ARqArUOtQ617mri2IED6Gq+L7oBXU0dF3AXDlfzPTQa0NXMsQMH0NW2owFdbTku4C68at6ab9BV84mXmh8vvJ8r8VJrPsir5hMNeKk1H+9V84m70F7ABhSg5/WRmWfwrbgK3cTX5HWUTmxAAV7jFd8BV/knKtCAE3ipic/k3IXrBWxAAXbgpdZ9DFf5JxpwAi+17lN9lf/B63Q88VLrPuvXYdy6S1yH8URX8znbCnQ1n749gQu4E/1jYIkNKMAOHEAFGnACFxBqDWoNag1qDWoNag1qDWoNag1qDWoCNYGaQE2gJlATqAnUBGoCNYFah1qHWodah5r7w/X8WL2ZLdGAE3ipXXfV1JvZDro/HGxAAXbgACrQgJ73qgBvULPrxp16g1qiZxiOCjTgBC7gLvSaP+h51RHza9hir/mDu9Br/qBvsTkKsAMHEHtzQm1ib07szYm9ubA3F/bmwt70mo/hLOzNhb25sDcXts1r/rrZqd6gdtBr3q8AvUEtUYAdeKmp7zev+YMGnMAF3InezJbYgJfadcNKvZktUXNneQebXfeu1DvYEhdwF3qh+w7wDrZEAXbgACrQgLWzBgp9oNAHCn2g0AcKfaDQBwp9oNC9V82uW2nqvWoHvaQP+kT5PHhJ+x0B71VLHEAFGnACF3AXekkf9LzTcQAVaEDP61vhB/eDu9AP7gf9cLsdBdiBA6hAA07gAu7CeHj+cuzAAbzyWqABJ/DK67dvvK/toJf/Qd8Xrublf7ADr63w+yXe15ZowHme8Gv0tR3chf74/WADCrADB1CBBoTagtqC2obahtqG2obahtqG2obahtqG2i41/85W4jWTfjfJu90SO3Cc/geNHriDPpPmOIELuE9XhEYP3EHftuUowA4cp1dC/Ttbia4Wf2ECF/BaJb64vF8usQEF2IEDqEADTuACQq1DrUOtQ61DrUOtQ61DrUOtQ61DbUBtQG1AbUBtQG1AbUDN/cFvWHkPnF1vgKr3wFksDXeCgwo0oI/X14M7wcFd6If8gw3oatOxAwfwUvNbPd5blziBruYryv0h0P3hYAMKsAMHUIEGnECoTaj56YHftvCOO/ObRd5xl9iBA6hAA07gAu5CPz04CDU/PfB7IN58lziAruY7y08PDk6gq/ms++mBozffJV5qV5+5evNdYgdeale7t3rzXaIBL7WrU0e9+S5xF17+MP2a15vvEgXYL/Rklz8kKvCtNv3a1JvvEhdwX3gZvzffJTbgqC32mvd7K95Ql7gLveYPNqAAr/H6lbA31CUq0MfrG98ncAF9vJ5svIAN6Kva/27UfOAAKtCAE+hq23EX6gt4qflFsTffJXbgtW1+se3Nd4kGvLZNfH4vf0jchZc/TL/Q9ea7RAFeat3Vruo+/2w2oAA7cAAVeI2sB07gAl4j676H1gvYgALswAFUoAEncAGhtqG2Xc330BZgBw6gAg14qfmlnPfhJe5E78NLvNT8As/78BI78FLzk3/vw5t+Ou59eImuNh0X0NWu4XgfXmIDCrADB1CBBpzABYSaQE2gJlATqAnUBGoCNYGaQE2g1qHWodah1qHWodah1qHWodah1qE2oDagNqA2oDagNqA2oDagNqA2oKZQU6gp1BRqCjV3gusBs3ofXuIELuDOQp9wggknmHCCGU4QOIAKNOAsdNe4Xu1V760LL/HeuqnxFxRowAlcwF3o/nDwyuuXyt5bd+ZhYYsXtthrPtBr/uC1xX7V7L+2mtiBA4i9uaG2sTc39uauvbleL2ADSo5hRc0HDqACLcfgfXiJCwg11PxCzS/U/ELNL9T8Qs2vVmtntQlcwJpJ78M7Y5AGFCDUUPMLNb9Q8ws1v1DzCzW/eu23FTUfiJnsmMle+8179hIxk6j5hZpfqPmFml+o+YWaX6j5hZpfA/ttYCYHZnJgJgdm0mve73Z4z16iz6Q6duAAKtC3zcfgNX9wAXeh1/zBBhRgB7qaD9Jr/qCfa7iw7axC786bfiPBu/MSBdiB2EMTe2hiD02s9Ym1Hk7guLD6FvbQwh5a2EMLe2hh9cE11sJ6WFgPC+vB/cG7ZLwPL3EAr7zeMON9eNPvl3gfXuIC7kTvw0tsQAF24ADOPG32jrvEupLwjrvEBhSg51XHAVSgb4U5TuAC7kJ3goMN6Fvhau4E3vHhX/hKVKABJ3ABd6E7wcEGFCDU/NrfL5j8u1+JBpx5weRfA0vchX7t7090vZMvUYAdOIAKNOAELuAuVKgp1Lzm/e6Bd+dNv2Xg3XnT7wh4d95Br+6DDegZfIv9KO09I95xl7gLvY4PNqAAr/n1qxnvuEtUoAEncAF3odfxQVfzLfY6PtiBA6h5Hesdd4kTeKn5bQvvuDvoR/+DDSjADhxABRpwAqG2U8284y6xAQXYgQOoQANO4Dp707z57qAf/Q82oKs1Rz270LzNLnECfSvEcRd6dR/0reiOUv/Mq/vgAEJNoCZQkwXchf0FbECodUj4Yfz62oR5b13iLvTD+PK/64fxgwLsQN8B01GBBpxAV1sX+gH7arkx761L7MAr7/b95gfsgwacwAXchV7SBy+17XvTD9gHO3AAFWjACVyFXt3bd6zX8fbp8zo+OIELuAu9jg/6IH1SvY4PduAAKtCAE7iAruY7wOv4YAMKsAMHUGu3RB0HTuBKbFG86thzdryhLlGBBvShX0vDW+diSvyHQRMF6HldzQ/CBxX4zruuZiDzhrr8ZwtYO8Ab6hKhJlDzMj04gAo0INQEElcVrqv7xvzjZIkDqEAfujhO4ALuwri/HtiAAuzAAVSgASdwFV5lul6+h1SAHTiAvhW+xWrACVzAfV6VtRavtAY2oAA7cAAVaECfHV991/E4sQEF2IED6OP1ZMszTEfP4MtzCbADPYOvvqXAax6aL8SrNhMX8Bpv8z1/1WZiAwqwAwdQga7m+21P4ALuRG+zS2zAa9av5/7mDXUxD95QlziBnrc77sL2AjagAH0rhuMAKtCAvhWu1hZwF4qrLccGFKCr+QbJACrQ1dTxUrtuBZs31K3rLT7zhrolPjvXMTaxAa+84tvmdXzQgBPoeX3bRsvF5U1yiR04gAa8Ckd82/wDEQcb8NqF4tvmb54fHEAFGnACF3AXepkevAYpPmc2gAo0oG+87yxbwF3oZXrQt8Jnxz88cbADB1CBBpzABdyF/kDcC9174BJ9K3x+vXgPGnACfSt8qr14A714DzagADvw2oqoIX8gftCAE7iAO9F74BIbUIAd6FuxHSdwAXehF+/V6mfe7ZYowA70rQhUoAEncAF3oX9X4mADXvviuhtq3teWaMAJXMBdGB9sCmxAAXbgACrQzie1LD7SdnABd6F/pO1gA/pWBPp4u+MC7kL/8JqfKcSH1w4KsAMHUIEGnMAF3IUGNYOaQc2gZlAzqBnUDGpexz2wAQXYgT476qhAA07gAu5CPzQfbEBX82Xvh+aDA6hAV5uOE7iAu9CrO3aWV/dBAXbgACrQgFgPu9aD97Wt64mYeV9bYgd63u145b3eazZvcUucwAW8tuJqmjRvcUtsQAFeasOH44fm60GaeYtbogEncAF3oR+aDzagADsQavFhxulowAlc51uKFh9pC4wPMwZeq9ovdOMjbQc7cAAVaMAJXMBd6DV/EGoDasPnLNBnx0fmNT98F+oL2IACvDKo7xY/bb7uFZu3rR286jixAQXYgdf8XnfHzZvZEg04gQu4C726Dzagq/k68+o+OIAKdDXfx17dB13Nd6xXt/rGe3UfbEABduAAKtCAE7iAUPOPLfqND29mSxTgtXb8ktab2RIVeK0dv7/jzWyJC7gTvZktsQEF2IEDqEADlpq3ra3rKYF5g9q6bqqbN6gti7+gQAPOQq/Y6y62edPZ8isqbzpLVKABJ3ABr/m9ut3Mm84SG1CAHTiACjSgqw3HBdyF4wV0te0owEvNr2696SxRgQacwAXchV7HBy81v3noDWqJHTiACjTgBC6grx2f1PjAamADCrADB9DzOnodu5F601miZ/D59Y+mHhxABRpwAhdwF/pHUw/6PAT6PPi+8Io9aMAJXMBd6Mfjg9dW+O1dby9L7MABvNT8nq63lyVO4ALuRG8vS2xAVxNHV+uOA6hAA07gAu7cF95eltiAAuzAAVSgAWchqtsbyRIF2IG+FcOxqttQ3RbV7ejV7Tbo7WWJAvTZib878M8UaECodah1qEV1BzagADsQagMSXrx+O9q7xxIb0Ie+HTtwABV45fVbzN49lriAu9AP2H594X1iyy8U/CNtiQr0vL40vHgPLuAu9JI+2IACdDXfm35oPqhAA07gAu5CPzQf9GQ+qV6xfq/YW8YSd6FX7MEGFKAP0ifVK/agAg04gQu4E71lLPGttv3K0lvGEjtwABVowJm7xVvGEnehV+xBXzvLUXN2vCMscQIXcF9q19Lw3q+YEu/9ShxAH6SriQEncF3YHWsHeO9XYgNCrUOtQ83L9KABJ3ABoTYg4VXoJ7Le2pVowAn0oV+Ly5u44uzVm7gSO9D3mzoq0IA+JT6/OIOeOIOeOIOeOIOeOIOeOIOecQYdqEADTiDUJiSmLzmfkjmACvSh+6KdE7iAu/Cqwu13kP0XBxMF2IGXmt8g9i6v7Xd6vcsrcRduz+trZzegADtwABVoQFfzvbkXcCd6l1diAwqwAwfQk1071tu19vUKrnm7VmIHDqACDeiD3I4LuAvlBWxAAXbgAF5qfjPZ27USJ3ABd+FVpoktd4u3ayV24AD62lmOu2ZnvIANKMArmd/m9r6rMyVjAhfQB+lq+gI24JXXb3N739X5Z4odoNgBCjWFmkJNd6G9gNjdht1tUDNImM+vLxjzoV+m4M1WiQ0oQAV6Bp8oL71ALz2/FeytUtvv6Xr70/abqN7+dNDL6eCl5ndOvSkqsQNH5fVyOv/VgBO4gNfZ9tXFbDt+hSawAQVY2+afIYsN8qaoxNpib3/yX9gxb3/aPdDHK44DqEADTuAC7kKvLL/75e1PiQJ0teHoaj50ryy/h+ftT9tv0Xn7k/8MkHn7U+Iu9HtBflj0Rqftd9W80Wn7XTVvdEo04AQu4C70Ijt4bYXfdvNGp8QOvNRiUq9j4Y6Reen5bTdvdNrDt9h/pOMVuAv9XvHBfn6czeIHDg8q0PP6RHmRHby2wu9HefvTQS+yg74VvkFeZAc78NoKP2D7x8kSDTiBC3ip+X0jb5VKbEABduAAKtCAnte32H+00C81vNFpa6ABJ9BH5mvHKzbQK1Z9HrxiDwrQR+bz4BV7UIEGnMAF3AenNzrt657N9EanRAF24AAq0M4WT29p2ldX5fSWpsQGFKDnFccBVKAB5/nZw3l+9jBwF8bPHgY2oAA7cACv2bnuPE1vaUrchX4sPNiAvhXTsQMHUIEGnMBLbfo8eB0Heh0fbMBLbfo8eB0fHMBLbfrIvI4PTqCrqaOr+c7yQ2jMgx9CDwqwAwdQgVfe5YP0Og70Oj7YgALshV5k11X+9A+DJV4Sy8frB8Dlc+ZFFugHwIMNKMBe6IWzfLxeOAcHUIEGnMAF3IneZJTYgALswAFUoAFLzVuP9nVpP73JaF9X7tObjPZ1gTe9ySjRgFeG62J7epNR4i70Q93BBhSg5x2OnkEdPYOPzIvhYAN6hunYgQOoQANOoKv5FnsxBPpvfb9evvX+Y9/JQqzOzXk5+2T4j3gf9mV+XeNO7yR6/2ffWhXiTjyII71Pif+Ud/IkDlmfK91gexGTrpGuka6Rrimx1Q4y7GLDLjbs4oldPLGLvbBiv/pFXexXL6zYgxO7eGEXe2HFDlrYxQu7eGEXL+zihV3sR7rYmQu7eG3sv037eNM+3gP7dU/sy0372EvR96s3Ep358k6iYiHuxKP2n/cYFRvxrP3nbUbF2MfeaJQ5G+k20m2k27CP/RtYb57OnXgQx9iWsxFP4kW8wad8ghuxEHdi170u5aZEWR024km8iDdYXbf5fol6OyzEnTh0fXuj3g4bcej6OKPeDm9w1Nt14Tsl6u2wEHdi170uc6c3CL25OS/iDZ4vYs8vvh+n5xdfM9Pzi6+NOYiV2IhD1+dhLuINXi/i0PXtXa7VffzLtbqPbblW97Et1+rxbyfxIt7gKMfDjViIQ9f3S5TpYdcdPoZtxJN4Ee/iHvV72HWvB/GzR/0e7sSDOHTN2YgncehO5w2O+j0cutvZddXHE/V7eBArsRFPYtfVyL/B8iJuxELciQexEhvxJCZdId1Oup10O+l20u2k20m3k24n3U66nXQH6Ybn+LVHD885rOCofb+66FH7hz2/Xz70qP3gqP3DjViIO/EgVmIjnsShK86he9VXD0843IiFuBMPYiU24km8iEl3ke4i3UW6i3QX6S7SXaS7SHeR7iLdTbqbdDfpbtLdpLtJd5Nu+MD1sHyOqPfr+d8cL6zD8RrEShzr0Jwn8SLe4Kj3w404dIM7cYzftaLeDxtxjP/y5BH1ez3inyPq93CM37cr6tfX0oj6PTyJF7Hnv94gmyPq93AjxjofvRMPYtLtpNtJt5Nu1G9wHNNncCMW4jgu+DzEMf2wEhvxJF7Esb3X2hhR14cbsRB34kGsxJ5/+hqL+g2O+j3ciIW4Ew9iJTbiSUy6k3QX6S7SXaS7SHeR7iLdRbqLdBfpLtLdpLtJd5PuJt1Nupt0N+lu0t2ku6GrrxdxIxbiTjyIldiIJ/EiJt1Guo10G+k20m2k20i3kW4j3Ua6jXSFdIV0hXSFdIV0hXSFdIV0hXSFdDvpdtLtpNtJt5NuJ91Oup10O+l20h2kO0h3kO4g3UG6g3QH6Q7SHaQ7SFdJV0lXSVdJV0lXSVdJV0lXSVdJ10jXSNdI10jXSNdI10jXSJf8SsmvlPxKya+U/ErJr5T8SsmvlPxKya+U/ErJr5T8Ssmv9PiVOXfiQWzlw3o8KngRw/N1v4gbsRB34kGsxKS7SXeT7oauvV7EjViIO/EgVmIjnsSLmHQb6TbSbaTbSLeRbiPdRrqNdBvpNtIV0hXSFdIV0hXSFdIV0hXSFdIV0u2k20m3k24n3U66nXQ76XbS7aTbSXeQ7iDdQbqDdAfpDtIdpDtId5DuIF0lXSVdJV0lXSVdJV0lXSVdJV06dzI6dzI6dzI6dzI6dzI6dzI6dzIjXSNdI10j3Um6k3Qn6U7SnaQ7SXeS7iTdSbqTdBfpLtJdpLtId5HuIl3yKyO/MvIrI78y8isjv7LjV9u5Ew9i1/UnIRZ+dXgSu+7VPDot/Mp5hl8dbsRC3Ild15+vzPCrw0Y8iRfxBodfHW7EQtyJSbeRbiPdRrqNdBvpCukK6QrpCukK6QrpCukK6Qrphl9dbbFzhl8dbsRC3IkHceiasxFP4tCdzhscfnW4EUf+5Ux5wn8Ob3D4jz9EmuE/h4XYx3/1hc4Z/nNYiY3Ydf250wz/ObzB4T+HI7/PSfiJP46Y4SeHF3GM3/9t+MnhRizEnXgQK3Ho+pyEnxxexBscfnK4EQtxJx7ESky6i3QX6S7S3aS7SXeT7ibdTbrhJ/58Z4afHJ7Ei3gXr/CTw41YiDvxIFZiIw7d6Ry6y3mDw08ON2Ih7sSDWImNeBKTrvtJ88dK3lNX3IhDdzt34kGs/ve7sxFP4ku3tci5we4nyY1YiDvxIFZiI57EpNtD91r/3ohX3IiFuBMPYiU24km8iElXSVdJV0N3OHfiQey6/szF2/WKJ7HrSuTcYPefZNcV33d+/pPciV3Xn6d4C1+xEW/sX/ef5o8i/etoxYNYiY14El/9LBa4Cy/3SfTB+wMd/0ZacSeOwfuELCU24quHxgIXcBfuSO4zvzvxIFZiI57Ei3gXe29gcSMW4k48iJXYiCfxIibdRrqNdBvpNtJtpNtIt5FuI91Guo10hXSFdIV0hXSFdIV0hXSFdIV0hXQ76XbS7aTbSbeTbifdTrqddDvpdtIdpDtId5DuIN1BuoN0B+kO0h2kO0hXSVdJV0lXSVdJV0lXSVdJV0lXSddI10jXSNdI10jXSNdI10jXSNdId5LuJN1JupN0J+lO0p2kO0l3ku4k3UW6i3QX6S7SXaS7SHeR7iLdRbqLdDfpbtIlv9rkV5v8apNfbfKrTX61ya82/Gq9jl+pcyMW4k48iJXYiCfxIg7ddfHxq+BGHLrm3IkHsRIb8SRexBt8/Cq4EZOukG741dVVvF7hV4eN2HWvJ+zrFX51eIPDrw43YiHuxINYiY2YdDvpdtINvxo+t8d/trMRe57r7Zn1Cv85vMHhP4cbsRD7+NXnLfznsBIbcej6OMN/Dm9w+I/6+MN/Dgtx6Pq2hP8cVmIjdl3zfRf+Yz7+8Jnrie16hc8c7sSD2PObr+3wGfPtCp8xH1v4jLlu+Exw+MzhRuy608cWPnN4ECux604ff3jL9LGFt0yv8fCW6WMLb5muFd5yuBMPYiU24knsusvHE97i3MJPRrAQd+JBrMRGPIkX8QaHnxwm3Ua6jXQb6TbSDT+5rqZXCz85vIhjG695buEnhxuxEHfiQazERjyJFzHpdtINP7nuhKwWfnK4Ew9iJTZi190+D+Enhzc4/OSw6153S1Y0rCZ3YtfdPs7wn+vux2rhP4dDV50Xcej62MJ/DjdiIe7Eg1iJjXgSL2LSNdI10jXSNdI10jXSNdI10jXSNdKdpDtJd5LuJN1JupN0J+lO0p2kO0l3ke4i3UW6i3QX6S7SXaS7SHeR7iLdTbqbdDfpbtLdpBsedd2BWS086vAkXsQ4PkZXbXIjFuJOPIiV2IhxXI7u2XbdmVly/Cc4xr+dldiIJ/Ei3uDwn8NXfrmai5cI5l8E8yCyiDc4/ORw8zzNWYg78SDGfo8O3uRJvIix32W8iBuxYDzHT4IHsRIbxuN+kryISZf8RMhPhPxEyE+E/ETIT0Sx3kRpnpXmWWme3U/OeIzm2WieyU+E/ETIT4T8RMhPhPxEyE9k0v49fhJM8zxpniftX/eTZJpn8hMhPxHyEyE/EfITIT8R8hMhP5FF+3fRPC+a50XzvGied8yzODfimOfu3IkHsRLH9vp49iRexLs4unyTG7EQd+LQnc5KHH7SnHfVdXTzytXNvqKbN1mIOzH2Y3TzJhvxJF7EGywvYuzH6OZN7sSDWImNeBIvYqyffvxnO3fiQezb1Xx+3H+k+Tjdf5IX8Qa7/yQ3YiHuxIM48ovzIt5gfRE3YiHuxINYiY2YdJV0lXSNdI10jXSNdI10jXSNdI10jXSNdCfpTtKdpDtJd5LuJN1JupN0J+lO0l2ku0h3ke4i3UW6i3QX6S7SXaS7SHeT7ibdTbqbdDfpbtLdpLtJd5Puhu54vYgbsRB34kGsxEY8iRcx6TbSbaTbSLeRbiPdRrqNdBvpNtJtpCukK6QrpCukK6QrpCukK6QrpCuk20m3k24n3U66nXQ76XbS7aTbSbeT7iDdQbqDdAfpDtIdpDtIl/xqkF8N8qtBfjXIrwb51SC/GuRXg/xqkF8N8qtBfjXIrwb51SC/GuRXg/xqkF8N8qtBfjXIrwb51SC/GuRXg/xqkF8N8qtBfjXIrwb51SC/GuRXg/xqkF8N8qtBfjXIrwb51SC/GuRXg/xqkF8N8qtBfjXIrwb51SC/GuRXg/xqkF8N8qtBfjXIr5T8SsmvlPxKya+U/ErJr5T8SsmvlPxKya+U/ErJr5T8SsmvlPxKya+U/ErJr5T8SsmvlPxKya+U/ErJr5T8SsmvlPxKya+U/ErJr5T8SsmvlPxKya+U/ErJr5T8SsmvlPxKya+U/ErJr5T8SsmvlPxKya+U/ErJr5T8SsmvlPxKj191ZyHuxINYiY14Ei/iDT5+FUy6RrpGuka6RrpGuka6RrpGupN04zruFSzEnXgQK7ERh646L+INPn5lzo1YiDvxIFbi2N7pHLrbeRFv8PGr4EYsxJ14ECuxEZPurk6SFZ3SwdEpnVwdHSs6pZM7cXR0vJyV2Ign8SLe4LhfdLgRC3EnJt1GuuFL4hz+Iz7O8J/rrd4Vnc/Jg1iJI8+1BqKTWa63dFd0Mid34kGsxEbs83+94buikzl5g8NPDjdiIe7Egzh0h7MRT+JFHPPvfDp5ghux63afz/CTw4NYiY14Ei/iDQ4/OdyISddI10jXSNdI10jXSNdId5LuJN04/4n9Huc/hwexEoeu10v4Ruzr8I3DtH7CN7qvyfCNw4M4tsvX4aL1E75xeBGT7ibdTbqb1u2mdbtp3W5at5t0N7SiG1n8GXp0Iyd34tiW+PtKbMSTOPbRdN7gOIc53IhDdzlH/u1sxJPY8/tzrug6PhznKocbsRB34kHsun6fKrqOkyfxIt7gOFc53IiFOHJ25/i3PrfhD4cbsRB34kEcY/Y5D384PIkX8QbH+cbhRizEoev7KPzhsBIb8SRexBv77vhDcCMW4lhv6jwxb1H7hzc4av9wbIuvpUlzFTV+2Igjv+vGOcPhDY7aV18ni/bRon20aB8t0l2ku0g3av/wIqa1sWltbNLdpHU6h33bT+dwsOdUX3tx/eIcncPJjViIO/Eg9m25fgt2Redw8iQO3eG8wVH7h0NXnIW4E0cHb/x9JTbiSbyINzjeRDjciIW4E0fn/3KexLFd6rzBUfuHG7EQd+JBHPM5nY14EoeujyF8Izh843DomrMQd+LotA9WYiOexIt4g+MNhcONWIg7cWzXdp7Ei9i3y/tYohM4uRH7dpmvwzh/OOzz6X0v0QmcbMSu670uKzzk8AaHhxxuxELciUPX10x4y2EjnsSLeIPP1yF8Hs5XIOK/x5tHvu3njadgI57Ei3iDzxtPwb6/Yt7OVyCCO/Egdl3vC1rnKxDBk3gR7+LoH05uxELciWPegifxIo55u9ZV9AknN+LYX9O5E8f+Ws5KbMShu50X8QbHOcbhRizEndh1ff6jTzjZiCfxIt7geLPJn/3F50jdrvb5AFWwEhvxJF7EG3w+QBXsu+vlU34+QBXciQexnu+Urfgy6cEJXMBdGJ96C2xAAXYgrQ6l1aG0OpRWh9HqMFodRqvDaHUYrQ6j1WG0OoxWh9HqMFodk1bHpNUxaXVMWh2TVsek1TFpdUxaHZNWx6TVsWh1LKyORatj0epYtDoWrY5Fq2PR6ti0Ojatjk2rY9Pq2LQ6NlbHxurYWB0bq2Pn6tjxpdODDSjADozZas6TeBFvcHjH1Wu4o2c3WYg78ThfdtzxxdODBpzABdyF8TnHwAYUYOx835xjDcGTeBFvcJyCHI7N2c5C3IkHsesuH0OcghyexK67fOriFCQ4TkEOu+7VxrdfcQpyvZy5X3EKsnxscelyWImNeBIvcFx+XKcUO9pwk+PfTudJHP92OV9vzYj/9csXEhtQgB04gJHZZyxKPPba9BzxnwXYgZ7DR3GVd6IBJ3ABd2Fce2yf5Lj2OOyTvH19xrXH4UHsw96+U7Zvuc9NXErE3MRthMOdeBD7fG/fn3Eb4fAkpvmOyw3nFpcbhxuxEEdOc57Ei/jK2a/WkR0tssmNWIg78SBW5+FsxJN4EYfutQajRTa5EYfudHbd5lp+6E9WYiOexIt4g72+kxux6163dne0yCaHrjgrsRFP4tD1bekbPF7EjViIO/EgVuLQ9f04JnHsX5+3EbrO+iJuxELciUPL15Ia8SSObdzOG2wvYtcSn0M/UUh2LfG58hOFZCV23etW84622ORFvMHuIsmNWIhD19fhHMRKbMSTeBGHrq+ZsA13snZsw//OsY1gJTbiSbyINzhuWbgHt+MzwULciUPXx3Z8JtiIJ/Ei3sXR/prciIU45k2djXgSL+INDs9xS46PxyYLcScexErsutdt4R1tscmLeIPDc65bx1vCcw4Lsetet2q3hOccVuLQNefQnc6h62MLzwkOzznciIW4E9v1MwNOs2gV7ST/IcyglhQ1ft3629G2mtyJrwOpK8XvFThZ0SxaRTspanm4VtTsdUt2e+tpjN5/lTZoFV1j9jm6avVQK5KiXjSKQsX3YFToYZ/54XstKvTwBq8Yre+1FXl8BS4jvsbr+3JFluAN9jpMbsRC3HOGds3urtndNbu7Znfn7EZLaMxptH7GnEbrp/96yI7Wz+TY8vi3izjGfO1jbwmNv31V2CEp6kWjSIs8p/p4ok7Ux3PVifrfuKrk0Ch6//vr9tj2ds5Ds2gV7aSrLg6FijgLsa/a62bojubOZCWO0V77OJo1+3VDcEezZvI13qCBOYrj6mEjnsSR3UcZx9XgOK4ebtgHUXOHOzHpKukq6SrpKukq6RrpGuka6RrpGuka6RrpGunGMfbwPpURDZyx0qOBM1mIO/EAr9hvPpqowcNGfNWg7/GrBg/tJP+J2KBWJEW9aBRpkRWVxi6NnRreOnmoFfnWXbdMd7RNJg9i3yKLv2/EPqfXLdkdbZPJGxzHwcONWIg7ceiqsxIbsetet1V3tE0mb3AcB6+bODvaJpOF+JpVz3hV+CEtsqJZtJKimq+bQTtaH/t102dH62M335Y4fz48iRexj9lvM0TrY3IjFuJOfI3atzaq3G8+RONj8iR21evFyB2Nj4ejyg+Hqs9OVPnhUPWtjSo/rMRvXT8iedvjoVW0k67qPtSKIqfPYFSq322I5sXudxWiefFw1OrhRuxjXr69UauHB7ESG/E1at/a60h7aCddl9V+LPWmxUNS1ItGkRaFim+pnxMnL3Accw/HaH2PbCW+ZjhoFq2imJ9rtNF0mNyIY36WcycOxe2sxD5yPxuOpsPuNxOi6bD7TYNoOux+0yCaDpMb8XVUHU69aBRFZueoW79NF+2D3a/no32w+7VftA/27SOP89fto/Xz1OHX7dEmmLzB1/HYXcSbBA9Jkfrf9G3skcG38apS9xVv9zvU/P8PFmffAq/Q5EGsxObsmmMSL+IN9hpNbsRC3Ikjv8+cRh6fOYu/4zNnMTafOVNiI57g+SL2PH5XIRrtkj2P31WIhrrhdwyiQW40n6s1iJXYdZvPj1dJ8iLeyO9nrOe/e/UkC3EnHpiHrcRGPIujES62NxrhYhujES65E1utnWh4G343Ixreht/BiIa3w+1F3IiFuBMP4pg3H2cz4kkcuss5dH1bvMKGX91Hg9zwuxbRIBfrPRrkkgex55fgRbzBXmGe0SssSIp85H6/Ilrght9z8BY4PwPwBrhDMTqfxagwv7sa7W/Jg1iJfVb8/mW0vyUv4g2OCjvciIW4E0d+n92oML+BG61qw69ToyVtdN/uqKTDi3iDrwrzswJvSDskRb1oFGmRFc2iVbSTVmms0lilsUpjlcYqjVUaqzRWaazS2KWxS2OXxi6NXRq7NHZq+Ccw/fzKW84OSVEvGkVaZEWzaBXtpFYarTRaabTSaKXRSqOVRiuNVhqtNKQ0pDSkNKQ0pDSkNKQ0eqyf5RzrZzjH+vEZixrxa2xvy/KrI2/KOjSK3tn8zM7brg7tpDgy+PX5jCPDYSP28fjZm7dZ+fmjN1kFXWv5UCuSol40irTIimZRaczSWLG9wTFOdbbrN5GdZtEq2kn+k+FBrUiKetEo0qLS2KWxS2OnhrdPHWpFUtSLLg1z0iIrujSm0yraSXHE8PPUaH0aI/577K/lPIkX8QbHkeFwIxbiTjyIlZh0hXSFdOOI4dfg0RKV3IiFuBMPYiU24km8iEl3kO4g3UG6/puMvof8JxmDtMiKZtFKiuOI32OKDx8Ov8e0zoefHQ04gdEj47gLz+/gODagADvQp8JvHkXX0vBT7ehaSm7Evsl++yi6lpIHsRIb8SRexBu8XsSNmHQX6cZJot90i26mZCMOXd9NcZJ42HX91kV0Mw0/9YhupuEn79HNlNyJXdcvBqKbKdl1/bZBdDMNt+XoZhp+6R/dTO7E0cx0sAEF2IEDGJmd4/Tw6tbY0a80/DI++pWSO7GP/PoG0o5+pWQjnsQLHMXuphr9R8ObA6L/aPhBIfqPkifxIt7gKOrDjViIO3HoTmclNuLQXc6LeIOjqA+Hrs9nFPXhTnzpeqHEZwoPGvAS9Vu18Y3Cg7vQTx0PNqAALzmvs/g64UEF+jb6LYzoVkpexBvsNZ/sc+VNFdF9dPiqbj8V8F6iQ73oOrT4HF3Ve2gV7aSrbg+1IinqRaNIi2I0voVRq4cXOOrTD3LRKJQsxL63/FAXjULJSnwZsW+ZNwoFraIddP0A5QvYgALswAFUoAEncAGh1qDWoNag1qDWoNag1qDWoNag1qAmUBOoxdH72iVX0DkYHPhs5r8xDiYHvvOuOz9XsCmIgr+OfFfQOBAOOgeDgxiBRWAcxAhmBDGCGHVU/nX752o3e3HQOPBifMUmePVXMDi45r0HGnACF3AXemPiwcjdInATecX0eF3r6/y1xcGmwA/yFbidvGJ6TDjoHAwOlINrK2IO42vsMTAL+ZhPC/mYqPniwOVb/Bs/Q9AWA/NThApcvoWinyRoi9R+llBBNIU7n66C4OjGCDbiSewDbucfbArcQCpoHAgHnYPBgQ9YQscP8xVMDnaNOHuUghtx9PUEd+JBHHIjAuNgchBHGotgU9DiaKMRNA6Eg+gtCB7ESmzEk3gRb3Dcmz3ciIWYdIV0hXSFdIV0hXSFdDvpdtLtpNtJt5NuJ91Ouj1me0awONgUjJjt2L+jcSAc+PKSHcHgQDkwDnwEZ1nEmUWs9tPbFPvxPIMNbsQufzYmXCeDwYFyYBxMDhYHm4LwowwaBzwC4xEYj+A8kA024km8iDf4PJINbsRCHI+mggexEseG9wgmB4uDTcGKDQ+R1TgQDpSDyBaFGjZ1RhA2lUHjQDiIbLFA/NpCRywQ958TRPNSBY0D4aBzEGeeEoFyYBxMDhYHm4JwoQwaB7E9K4LOweBAOYgR9AgmBzGCEcGmQF4cXCOYMQB3o+ROPIiV2IhDwUssWpd0WAQxlzOCwYFyYBzEluwIFgebgvCYDBoHPgKNsYXHZDA4UA6Mg8mBj0Bje+L65QRxBZNB4yBGENsTNpPB4CBGEKMOm7FYdmEzGfgIrEWwKQibsRho2EwGwkHnYHCgHBgHk4PFwaZg8ggmj2DyCCaPYPIIJo9g8ggmj2DyCCaPYPEIFo9g8QgWj2DxCBaPYPEIFo9g8QgWj2DzCDaPYPMINo9g8wg2j2DzCDaPYPMINo0gviJYQeMgRtAj6BwMDpSDawR7BE/iRbzB7mrJjViIO/Egjg2MIMzJNILGQWyGRdA5GBwoB8bB5GBR0ENnRkC7JVrJclLCojKYHCwOYre4QcfHAitoHAgHtDCiC60C5cA4mBwsDnhhhEWdsYVFZcALQ3lhhEWdsYVFZWAc8AiUR6A8AraozhbV2aI6W1Q3XprGe8F4LxjvhWNRMTbjvTB5L7BFdbaozhbV2aI6W1Rni+psUZ0tqh+LirEt3guL98LivbB4LxyL2hEoBz6C+YpgcrA42BSERc1IHRaVgXDQORgcKAfGweQgRhDlHBYVwXhRmUX7nE6NoHMwOFAOaPFFD10FiwPa9dFGV0HjQDigXR+tdBUoB8bB5GBxQMt/yIuDxkFsqUWgHBgHMb0xb2FcM0YdZ10n6C8OGgfCQedgcKAcGAeh44svmu0qaBwIB66zXhEMDpQD4yDO+2Kzw9Iy2BSEpWXQOBAOOgeDg7iSiYGeS7gTbArOJdwJXGe1CCJbjDrsKQPjwHVW7O2wpww2BWFPq0dAVyXRlldB54BHMHkEk0cQ9pTB4oCui+LbghXwCBaLhu/ENVs05FWwOIiNi6IN38kgJjGWcvhOBp2DWC6x+MJ3MjAOfARxfzU+I1jBRhA9fRX4CHaLQDjoHAwOfARxtzY6+DTuWkYLXwZhNRmEzohAOOgcDA6UA+NgchAj0Ag2BWE1GTQOhIPOweBAOYjUvkvia4AaN4/jc4AVDA6UA+NgcnBtgsXN4/goYAbuLhU0DoSDzsHgQDkwD2I3urtUsDjYFOiLg8aB0A4Od8lgcKAchAW4h8QnAHNGw1AyEA46B7FxsfiMJzEMJYNNwYxNiBHMxoFwEJMYq2rybpy8GyfvxskjmDyCySMIQ8mgccALafFCWjyCxaILd8DPD6EfbsRX3ha7PX724fAgjrURE7uNg8lBrI2TdyOI1sYKLvW4lX8+8ne4Ew9iJTbiSbyIN/j8+FUw6TbSbaTbSLeRbiPdRrqNdBvpCukK6QrpCukK6QrpCulKzPWOYHGwKfDzGYuHKPEhwQp8ETeJoHMwOPC93UYExoGP4AwnvCiDTUF4UbMIGgcxAo2gczA4iBHEcgkvysBHIK8IFgc+gnh4Es2VFTQOfAfEaOJXJw4PYiU24gm2UIgZc+Mxia0P44nHKvHBwAqMg8lBbMlJvSkIS8qgcSAcxAhiBczBgXJgHEwOFgc+grgvHd8VrKBxIBz4COJMJr4tWIFy4COIO9bxeUGLW9HxfcEKYgSx0/eLgxhBDHQLB52DwYFyYBxMDhYHG0H8OnoFjQPhoHMwOFAOjIPJweKAR9B4BI1H0HgEjUfQeASNR9B4BI1H0HgEjUcgPALhEQiPQHgEwiMQHoHwCIRHIDyCcLY4jY6vGFbQOBAO4uAYPIiV2Ign8SLe4Lh4O9yIfQNHi8A3Ix5LxGcNK4jN8EqJDxtW0DgQDjoHgwPlIHS8uuJ7hTl3xpMSFpXB4EA58N0SzyOi5baCxcGmYPLCmDyCyQtj8sKYvDAmL4zJC2PywgiLOgOdvDAWL4zFC2PxHIRFxbVsfAKxgpiDGYFxMDlYHPgINFKHRWXQOBAOOgeDA+XAOPARaCyxsKgI4kuJZ9fHpxItnrzEtxIr6BwMDhS7Mb6XWMHkYHFAuz6+mVhB44B2/WJXWuxKi11psSstdqXFrrTYlRa7UvQKm/YIBgfKQUxvzFt4j8aow3sy2BSE92TQOBAOOgeDA+UgdCyCTUGcO2XQOAidGUHnYHCgHMTxPjb7nDudYHGwKTjnTidoHAgHnYPBwcweIO8rTtyF17lTXKF4X3GiAD13PMOL7ydWoBxczUaxoZdVJS6gb1c88YtO5AoaB97RfLgTD2IlNuJJvIg3OL59drgRk+4i3UW6i3QX6S7SXaS7SHeT7ibdTbqbdDfpbtINO4qbr9GMXMHiIPq6fOqjIbmCmO0egXDQOYg2qRaBchB9Xa8IJgeLg2jU8hqLfuYKYgQjAuGgc+AzcFiJjXgSL+INjjOieAIXTc0Wz8yiq9niZn60NVewONgUhPfEM4xoba5AOOgcDA58BPFAI/qbK5gcXCOQo7nB8Rm1w95+FtsSn1E73IkHsRIb8SRexBscX4A+TLpKumFDM5ZJ2FC0VkS7cwXGweRgcbApiEu8DBoHwkHngEcQZhUPYaJVuoLJQYwgaiAs6wRhWRnECGKz48wqg86BcRCv4jrHGxGHG7EQd+JBfG1JuHd0WSdP4tiMWHFxcnSCODnKIDYjVlOcHGXQOfA1FBMUn106bMSTeBHv5Ba/um7+nKTFz65XIBy4tj9KaPHL6xUoBz65/jCjxYccK1gc+NZfDeetxbccK2gcxAhioJeV+GlM8w7rg3F6s07QOBAOOgeDA+XAh79jW8J8MlgcbArCfHaMOMwnA+HAR7BjW8J8MlAOYgQWweRgcbApiFMiP6S36LK2HdvjRjNfsQvdaSowDiYHywOJYHsQW+p2M18xUPeb+YoRuOFU0DkYHMQIYqBqHEwOFgcxgtgeN5nZYqBuMrPFinKTmS0G6iYzW4i6yVRgHEwOFgebAjeZCmIEMbYpHAxauXHFloFxMDlYHHBRrBCNzV6NA+Eg2uliQtbgQDkwDiYHi4NNgZtSBY0D4YBHsHkEO0YQu2QbB5ODxcFGEF3dFcQIZgTCQedgcBAjWBEYB5MDH4H3/bZo7Z7e99uitbsCH4E30bZo7a7AR9BjoH6KVIFyYBxMDhYHmwJ5cdA4EA54BMIjEB6B8AiERyA8AuERdB5B5xF0HkHnEXQeQecRdB5B5xF0HkHnEQweweARDB7B4BEMHsHgEQweweARDB7B4BEoj0B5BMojUB6B8giUR6A8AuURKI8gnM9vC7fo+q6gcSAcXCOIQ3Y0fScrsRFP4kW8we5/yY04NlAjCFs7QWyGRbApCFvLoHEgHHQOBgcxXVHfm3fL5knZPClhURkMDmK3hA2ERWUwOVgc0MKIvu8KGgfCQedgcKAcGMYWfd8VLA5oYcixqBVB40A44BGwRQlblLBFCVuUsEUJW5QILc3T952BcNA5GDQ2UQ6MAx4BW5SwRQlblLBFCVuUsEVJp3Ugx6JOwHuh817otA7kWFQEg/cCW5SwRQlblLBFCVuUsEUJW5SwRcngdaC8F5T3gvJeUN4Lx6J2BMqBj8Avblp0jFewONgUhEWNGFtYVAbCQedgcKAcGAeTgxhBbEKcqZ0gztQOdxhFtIVPv/Paoi28AuNgcsA7e/LOXryzF5fc4pI7JnYCXvCLd/binb14Zy/e2YsXPBufbF5um5fb5uUW9ub381s0f1ewOIgJ9XmL5u85VgSNA+GgczA4UA6Mg8nBoqDhOr5Fo3cFnYPBgXJgHLiOPypo8Y3RCjYFYWL+3KBFf3gFwkHnYHCgHPiW+kOEFv3h0++mt+gPr2BTECaWQeNAOOgcDA6UA+OARxBv68ZUx8u6wfGu7uF4VTdYiDux3/6IdRLfeTpsxJN4EW9wfOfpcCMW4k5Mukq6YUz+/KBFN/jU+H/CfjQ2Lewng8GBcuDZLBZHXPRZ7Nu46MugczA4UA6MA98bfku3RWd3BZuCcJkMGgfCQedgcBDbE3srXCaDycHiINpUnOOu1OFGHPIx0WExGQwOlAPjYHKwONgI4nflK2gcCAedg8GBcmAcTA4WBzyCxiNoPII4t4rlET3eFQwOlIMYgUWwsSKik7uCxkHozAg6B4OD0FkRGCeYHCwOeASdR9B5BF046BwMDpQDHkFn0Tg18rvuLdq6K+gceOp5/o1yYBxMDlzH7yy3aOvOIE6NMmgc+Aj8/nGLT6fOOH2IH42vYHIQOrEO4gToBHEClEHjQDjoHAwOYgSxQuIEKIPJweJgUxAnQBk0DoSDSB3LJUxnxsSH6WTQOBAOOgeDA9+EuM0bbd0VTA4WB5uCOLXJoHEgHPgIVuzG8J0MlAPjYHKwONjYwdHWXUHjQDiIzX5FMDGj0cldwaYgDCWD2LgeAU1i9GtXYBzEJsQI4mwmg01BGEpcjUe/diYQ4aBzwCMQHoHwCMJQMlgc0EKKH3+vgEfQWTScYlkEk4PFwaYgrrW8o79FJ3cFwkHnIJ72nQTKgXEwOVgcbAqiAyCDxoFwECsx9nYYSgaTg8VBbGnMThhKBo0D4cD7ueKOvZ5Pj5xAOTAOJgeLg03B+frICXxGd6z4ONnJQDkwDiYHi4JwF38TokWL9tyhEx4Sj1eiX7uCyUFkixUfHnKC8JB4ohK93BUIB7E9sbPCQzJQDoyDycHiYCOIfu4Zj2Sin7sC4aBzMDhQDvyUOpwvurfPvEX7dgWNg9BZEXQOBgfKgXEQW7ojWBxsCsJqMojbgzECt5oKOgdxZ7JHoBwYB3FzckSwONgU9Lg/+YogRqARxAhil/QYQcxoHxwoB6ETc9A3BePFQeMgdGIO4nQllnL0ZlcwOVgUxBlKBnGxExt3rnZOoBzEdVZsaXyjLIPFwabAXhw0DoSDzsHgwHdJPICLpuwKNgVxyzgDn6p4ThdN2RV0DgYHsaUngXEwOVgcbAriYX4GjQPhoHPgOhqL73zL8ASxpbF/1qZgvzhoHMSWRoLdORgcKAfGweTAtzQu4aP1+gTRel1B40A46BwMDpQD42BS0GJLT9A4EA46B7GlGoFyYBxMDmJLWwSbgvgaagaNA+GgczA4UA5in1oEm4IwlAwaB8JB52DEl2EvVKABJ3ABd+FlL3G24g3UiQLswAFUYGxRBBrjXhEIB50Dn59x/o1yYBxMDhYHm4LwlwwaB8JB54BHYDwC4xEYj8B4BMYjmDyCySM4/rIjUA6Mg8mBz2g8z46O6gzcXypoHAgHnYPBgXLgI5BYmO48FSwONgXhPP6CTYuO6gqEg87BoF1/nOcExsHkYHGwEUR7dQWNA+EgtrRHYBxMDmJLRwSxpe4I0URdQeNAOIgttQgGB8qBcRAjiIG686zoA4gm6gzceSpoHAgHnYPBgXJgHEwOeASXJ8X1qTdXJzbg5Q0xeZcXJQ7g5Q0t0IATuIC70J3oYAMKsAMHEGoDaiPmMYLwoXggEQ3SKx5FRYN0BcqBcRDZYudZZJsRdA4GB8qBcTA5iLnfEWwK4mwmg8aBcNA5GBwoBzGCWLPhNhksDjYF4TbxnC06pCvwEYxYEOE28TAsmqQrUA6Mg8nB4mBTEG6TQeNAOOARRItiDC1aFA8bsbcoxoKIFsXDuzhapcP1olM6WYg78SBWYiOexIt4gxvpNtINb4nHhNHtvOIYE+3OKx6iRL9zBuEgGTQOPFs8hoqG5xVnKNHwXMGmIM5QMmgcCAe+N+IcNhqeK1AOjIPJweJgUxAXQxnE9uwIhIPOweAgRjAiMA5iBDGjcU6TwaZAXxw0DoSDzsHgwEcQN+ej/7mCycHiYFPgZzsVNA6Eg7g9EzyIldiIJ/ECh/PEjfT42fnlLxa0+N35CuKsKVZnXC1lsDjYFMTVUgaNA+GgczA4iBmL5RAuYrE3w0VOEC6SQeNAOOgcDA5iS0M0zlkymBwsDmIE1zFDot25gsaBcNA5GBwoBzGCGUGMYEWwONgUxNlMBo0D4aDXPpVXGxwoB8bB5GBxsCkIL8qgcQAvkuiMrsA4mByEzvaAvEhe5EXyOl50AteZkSC8KAPjwHXm+TeLE2wKxosDHsHgEQweQXhRBsqBcTA54BEoi4bJzJjEMJkMlIPYuBHB5GBxsCkIk/HbLxL9zxUIB52DGEGs0TjJmbFG4yQng01BnOTMWHxhNRkIB52DwYFyYBzECGKFxElOBpuCOMnJoHEgHHQOBgeeesUuCXdZMfHhLhl0DgYHyoFx4JuwYpeEu2SwEUTHcgWNA+GgczA4iBFoBMbB5GBxsCkId8mgYQdHx3IFnYPBQey5HsHGjEYrcgWNA+EgNs4ioEmMhuMKFgehEyOIk5sMGgehsyKg3RgNxxUoBzyCziPoPIIwlBOEoWTQOBAOeASDRcMpeszB2BSEbWTQOIjUOwJcs0hT42By4Dr+QEWiXziDsI0MXGfH/qGrJml01SSNrpqkGY/AeATGIzhXTSfYFJyrphM0DngEk0XDKXZMYjhFBpuCcIodJRNOkYFw0DlwnR2FEZdDGRgHk4MYQeyfMJQdAw1DyaBzEDqxRsNQMjAOJgeLg40g+osriBHsCISDzsHgQDkwDiYHi4L4uKo/q5FoD97+BFCiPbiCycHiYFPgtlFB82BEIBx0DgYHyoFxMDlYHMQIfDdGe3AFjQPhoHMwOFDs4GgPrmBysCgID/FHlRJ9vzmjY3CgHBgHsXG++KK7NydRGwfCQejECHRwoByETqwq5d2ovBuVd6PxCIxHYDwC6xwMDnghGS8k4xEYi85IHcvSTz22P1SS6OitQDkwDjYFbg67xfSuzkFkC9F4Z7PFntvxb2JV7c7B4CBGEMtlGweTg0U6e+P/iU7bChoHwoFfgflXiCQ6bStQDowDmoPzQeXY7PNF5QyEg8jWI4jtsQhie2YEi4NNQVR9Bo0D4aBzEDO6IlAOjIMYQWxcVL3ExkXVS2xCVL3fZpLop/UfNr0C4aBzcOn0fQLXOXPQQ+f8P5uC8eKgcSAcdA4GB76lEjs4LCCDyUGMIPbCiBHEvIU5SMxOmMPZ9fGL4XE0iybaCgYHl47/1PUVLA42BWEBPaY3LCAD39J+/lrnYHDgW9pjs8MCMpgc+JbGaVF8bzmD+eKgcSAcxAhiDsIpMlAOjIPJweJgU7BeHLjOiMV3flM8NsHveuwRs+N3PSpoHPioR6zRcJcMfNQj5i3cJQPjwEc9QjTcJYONIFppK2gcCAedgxiBRqAcGAeTg8XBpiB+hzxmZ5wvtlsEgwPlwDgInRnB4mBTEL6TwbWlPa4Oo5W2gs7B4EA5MA4mB4uCOKfw+7kSDbMVdA4GB7GlJ4FxMDlYHHg1xg2i+FxyBY0D4aBzMDhQDowDn9G4vxPdsxU0DnxL4xZIfBS5gsGBb6m/DCHRV1uBb6nfRJboq61gUxC+o7F2wncyEA46B4MD5cA4iBHEGg3fyWBTEL6TQeNAOPC5zsBn9EyVu0vXWMruLhVsCtxdKmgcCAedA9+nZ1XFT3dlYBxMDmIEsX/WpmC/OGgcCAedg8GBcmAcuE64ZTTZ7tiEaLKtQDjoHAwOlAPjIPbpjGBxsCmIM6EMfEvDleOryhV0DgYHyoFxMDlYHGwK4kzIXziR6MWtYHAQW7ojMA4mB76lFtMbZ0IniDMhC9HwqgyEAx9B3AmOjy9XoBwYB5ODxcGmIM6R/PGARMtuBcJB52BwoBzEXGsEvKqUV5XyqlJeVcqrSnlVKa8q5VWlvKqUV5XyqjJeVcarynhVGa8q41VlvKqMV5XxqjJeVecXutr/+l//5R//9t/+r3/+j3/9b//+X//jv//Lv/zjn/6z/sP/+Mc//R//+Y//75//+7/8+3/845/+/X/+27/9l3/8//753/6n/6X/8f/987/7n//xz//9/f++Z/Nf/v3/fv/5Tvj//Ou//ctF/+u/4F+/Pv6n15twdv759R4bUrzvjv6SpH2cxB8reYq3XVeCKb/8e/n43/frcZH/+/cpFgYw2/Ot8CV1tuJ9TP9wK8bHSa6L/8jQev370Z/+8+7vvMdWzDkxAtFfUthNiuue7JkHDOGd6+G/t5aTYF3r37+vs35JsG7m0X/1OSbh7YQfpth3+1JqGmz2D1PczaSfsZx5WOPDmWw3S/K603JyXBeNyDF+HUa7W5ZdaxiYzvcdzOcbsnND3uf0/eMNucnx9p7M8UbsEvutOvVur153Cs9eVfkwxc3K8leRPMPqtENsP86wqkDfz8Q/znCzOK/nQrlL3w9bUKK/+ky7WZz+tDYGseeHg5Abp+lt1PJ+TyaW97Kv7Y/58f64WxXzlVbxxv1RiutuyIfTOVYa3nWQ/zDF+O4+Ff32PhX79j6dN8YvkjPxRizv9/2Y5xviP5V5NkTbhxtyszgF7v/6MMG9VWyrRUHHsN/2aG/fd++7HO/r68zxvmz++EDY++2BSKpEaDbeXv5rjrvpWLlH7KWUQZ4vDH+hIBaGUpX9vjD6zfLc/kNIJ8c2MozftuRmHIJTi/fNc+SwP9gnVSWDDwF/2Sc36zNefox9sgYdEPtvp1h3J2qmOM2yaTSS3/bLaN9fHUO+uzrut2XX+db1Lkj/eFvGnXFMOODaNJJf98zQb68P+74F3s7H7Jpzer0UcbNv190BdtbJ3/sxMs3Hb+ePd07arebjfQ8ZW7N/PXXTuwO99zDHONawj3PcnYT6G44xjvVaH+e4WafxcsOput4+znHnpjJyHNfXfehU9vkCeWiFqt+3QrXvLvX7HbukTutf4+MJvVukgsPke7F9nGN/f8fa69s79m46htZJ3PsG78dr1OT702H9B6ZjfHs6bq1jVNlfN68/HsbNGh3+ieNzP4Qs/fcct+NQbXV2vm/GcbNKTWoc74vIj23wT0zdPjT1+fr2af68O+ZP/72tM5A51scDkbspkVZT8ss5zG85blbqaHWsfD8Na1+bkGeXC1O/eblwux2zdsr7ccPr4+24OTNdr7o7sV6Gc/3+29F6rtt7C7lj52r6cY67u051t4eX6PsRwq93vm73yK6CEzrA/SXHzRpVSQt738T/WoZdZ6U0E79nuF3hmAob/eNyXbcXkrVH3neuv5hj1r2vN7av5fAXLiPHko9z3F617FfmkNeaH161rLs7T6uXfS37+Mpn7bu1UTc138uE57Q9z+GvbESO3eaHOfYPXDvtb1873br5+3QYF5PsgL/v2/3tK/z7PTvzHq/sNr62Orzl5+S4WR173q3SXsvj6ovpH5zY3o+jbtK+H+Ssj8dxVy24/3NdntN9gt/u075et09Cej0J4Xtyf5Jk+Oe+z9GJ1ulfk8j3F3t79b93tSv27ruGPz7WttfdfePorD/PqPja5bd7z69vX0DdrbP345S6Mn4/sfpSzbyP7XURNsbrwxzttf/eoumjzrO73RhAu33Y5L9EHXNqv9zxnL8luVmr74seqWcsS7+WZPtvQMUl9rS7JOMHqubuIcfDqrk7P/Xu1nCATZdRf6mZ9gMnqK39wBlqa98+RW3yA+eo/ubz905S71M8Oku9P87g8L/X62N3v3v89L7ErwPv4saBvyTR2zOROuIt4We0v5mq/L2mise87wcvr6+ZquGScIp87GV3T6Ee9SDcjoKO/lvs41HcPa+4vi6ee6V3PvqvP0jijaV56v+6SdLvHFXzaLeN74/9Xvt3j6J2nWVuOqnqqn8yjoVx7Bsju7uLe72IXjNCzv77SG5PZnZviqPuL5dUvxlzX989PtyW7vXaT9mhrY9L9/4pzqwHMNdHyfZHJ1Xj9gSg7o6LveRmJHJ3k0xwT8hujjKj/8Dx7u6Z1OPj3d1DqYfHu2E/cLwb89vHu9sUz+7K3F1D+J6PUbz338f32m4LbwsOmltvCu/2oVSfdbLKfU3Xjftfk8h3D3j34xj19FT4EuAv47g987ZqHbwetn18vnv3XCre4jiuSLdV/tJidde6h3upr4+7UJrePeWXViYik5/B/nbaffdk6vrlLfQxvuiK5venbPeGtuoxfW98WfS7od09nRpSt82G0C2ePzDW9+OkOh0Rvov4l3HcLlal23c3h3D7CWO1nzBW+76x2k8Yq33fWO3bxnp7kne981k20m7OFO8exzy+4r3z56dnNHcNozgFeD+wu7miuTvWXJ9AridluunC6LeambcjwXXAr9P6+0j07kHoa9eD0E0n4L834U77vjvfPaZ66M53T6keu/PdY6ofcufehe7A3VyzrtvzgNo5wrfx/uJFS37AFVf/AVe8e1b00BWX/oArLvu2K96m+AFXHG2hfeDm0veTx031GHDrTfnu1/fL9+6Z1cPyvXtk9bh8d/+Z8r17ulpv3LwftH7YeH176TtmtZCPxc8TfnOAcfuApd7aWcYpfrsrcffcqrcFJ3q9Pj7/vk3S0fL3y5sWf0lyZ63PXnKQu2dOz95yuE3xsCX+dXsf4FlP/N0zq6cvOtwZ6tM3HR7vlZtXHZ4uj/Gyr66x18T5zMcXivL6gdej5PUDL0jdb86sS6v3sftmc+4unpfUacQb9UN//yRJ3aldcnOO5/773eJt49vF277/Psvda05Pi/f2mdWz4m3r+8X7fK/Mm71ytzx69SCuvtfHy0Nuz2aevaok8u19e/vG1MN9e/vK1LN9e3fsf/y60m2Sh/3ccvt+zMOGbpH13VuJnyyyVxlZ7181MquWzLXax2+Myu0jJx1oUuU3Pn97afTW3EerByzvQ9XHJ1XSf8BS+/cttX/fUvsPWGr/vqX2n7DU/n1L/WR5VJf7uLbgw+Vx/wrVs+Vx98Dq4fIY33fl2xeoHi6Pu2dVD5fH3bOqx8vj8V758vIg95jta6fLo5WzD74V8pc1dvdqycNX10V/YJ3q99epfn+d6g+sU/3+OtWfWKf6/XX6yep4dBvkkxyP3niWu6dUOnG7TcbHdx/E2t96P0YbXulv+vHHIuTuKZXZrI1Z8+Yk5u4p1UZ/x4uv6NYffI8FbZXXZ8qoZF6/75q7W/8P3ziWu2dMz55C3qZ4P46rK+XrB/8+fvdI7O7Kv+OivdMLTPYHKcarnssO+XBj7h5T/cx8PHyLW+4eVMmqBs83yocb8wPfCZD57VbV2xRWl2Qm+4sp6hBj9Lqx/MmEvqegdotSA+BfZ+N2SgXeTg2Rf0mybu/6P2vN/mSZPX3BXu6eUT19w17unlE9vEq9HYfUC4zXZ7ZvxnGXBK/rXt9P+zjJ7cTO18Rlanvtm4md3/az2xTP/OzuKdVP+Nmv89Hmjb/fpnn6AQS5e1T1PkPbOEMbtIv3V5OsH0hi/atJnn3QQfbdPYCHX3SQ25vmDz/pIPv2dtWzbzrIvv+USp1PcNvanyV5+MZ8f902Wj96Zf6TgdSz9+tNp69uTX2W4fro7hd3Dqbk7aLjy0mwh0V/IAldEPw1yd2qf/gRgH730Op9nYWXeef+Wuk8/UpEb3fvBT78TERv7fulc5/kaem0H/iqyv1AnpXOJ0melc4nO6fec3jj/oEkdMD4wyRWRx2Z+sUk/JLieH0xyajTgv7LQ5I/G4nhtVy6V/KNJPbVJHjpkp/F/eGcoEVx9K/u4oFvpY4+v5qkivh9u+HLu9jQ52jzqwVoeIfsdhffJtm4Ynq1L1vBQhL5gSTt6yOZSPJVs9+CORnzB0Zye2Zxe+747KtR/e5J1uMDYJ8/cAC8TfL0AHj7aY2HB8D7gTw8AN4neXgAvN85Dw+Aj5PcHQDvkzw8AN4meXoAvE3y8AB4fxb78JNa/e6zgL9+U2t87VR4bDzV2ku/luTpV7X+YHPuJvbplfX6+PK86/ebWvrdo63e69HF+5aQ3Qzk5v7n1JlJpvKrXL+5ye3DrdHorQW6rTV/y3Hn9C/cknrRNeRfcty/hVVdz2/mDzGsP5lWpZO+eTOtt0k29s2+uYfzJ3e2Pv4kVL99EevZV8+63T80qL1zk+H7/bX97h2sP5mQ2zT6Qhq9eTG03+0e2Nr7GSKt+mV/MpSn39frdw+onn5gr9+9jvX0C3v3SR5+3q7PH3i/pc8feL+lz2+/39LnD7zf0ue332+5T/Ho/Zb7nfvw2zD97m2sxzt3vX5g5969i/Vw594/5Xq4c++ecj3cubcpvr9zn74sf79CcIth8C2GP0qiva61tG/7oiU+/CJjv30X6+EnGe+TPPwm432Spx9lvB9Jdey+Ub+YZNe9m/eqG189BOM48b60fr2+mmZR5+/Sr54QPP4uYr+7W/Gso+E2xbOOhvsUjzoaPpmPp1/OG7dPuR5+OW+8vv3Ni0/GseuxULt6JD5McteeJdUVseXDZ+afpKhN2Xzn5k/OF9fEpqy5vrzgd72pev3+9rrZwfffJHzQinCf4lErwmjf/uDFn8zH7Wn4J2km0uj4chrFfcI9Pz7RGm18e+/cpni4d+zv3js8H3cnnp/tHTww2Purx5z9woXfbqJfTfP0g15Dvv35i9sUz4459yl+4Jiztb6S1raNm2OO3H+f/UF3422K97lJ3Vh7cxtfS0L3+ic3NPxZEtzrf5/efO2QsWfH45yvHzIefwdr9Pa3pxHBdVd/8U06+2KSJl9M8vDDXqN/+6eERv+BD3vdJ9H6TdHrh1m/luS9P+q48/rlBvnvzYG335959gF5uf/gEuZE+s1vZ33ys1ePXj8f4/a3Vp+9fn6/OS90N73ufgrs9iuD9TH7OT+8Czvuvt349Lv84/bFrac/WDpu74o9+7r/fRIcd367KP6TJHPgGv+X68ffkujr2ydstymenbDdvXT17ITtk9mobk1dfd/Mxrg7p6gOOhv8uaW/JLl7yQBPDflHltcfDEPrysD0lyvhP9kWrQfUpku/nKQ2xl77y0nqtpjd/JjF/f59+IsYw9rfnOTxbxLat39q4DbFw3Po2xSPzqHvZ+PhmyifTOmzN1HG3Y9gPX0T5ZMDzbOfCblP8vD3OcbtR2Af/kDHuHuq9fQHOm6TjFH3xsfY+ybJ9+8MzO/fGZjfvjNwPxtaHvJLg/RfZ+P7d7Hm9+9irdffOxtWLxkPfrf3L7Ox5NuzcZvi4WyM75+EPO1FvvnBlPskD38g4D7Jw2/z3yfZdU41Xl81w77r1aJ3kpuR7NcPXBDtH/jJ60/2zrOfXhh3nxd89NMLtxmsrjKNLjL/Oh36E3P6E9dU67aJaqO9dPDHcH//Oc/13Tm9HcbDn6K4T2Jb8Rjr9cUkD3/PQm9/Euvh+dBtko2j3fUNqA+bHu6T2CuddfMFwJ8mqR88st6+muTZb3x4s9aHSR79xsdtivYaddb8snaT5HZjnv1QiLbb97ef/VDIbRJ51bXI+y5R/+LmzL5qXvktjz/awQtLbfHLCH+Zk/E3J5GGD/O2frNObpPgq/giPCd/STLvn4njUbR8MQm6S9vg1yL+KMmg75VzC9XvSe5+G2ssfPaIn0+0P9k53mV57qCvj+f11qWffpBe5btdrrcZnt6PUPn2lzFuUzy7H3Gf4tH9iPvZeHg/4pMpfXY/QvsPfBnjfo09/Ly39ttfcX32eW+9/aDdHHhCOejHk16/5bj9vcFH3/jSu+dWz77xdZvi2Te+9O5FpIet5Xr3ncFn3/jSuxeznn7j6/lemTd75W517PKx9yPWD7/PpXcPrHTX1bNu218cx6OP0Ovd46pnH6HXu88MitHvhPJbP799hP4+CR7wvLF9LUl7veqG5rj5HP79SLTjs7z21SQPP8yvdw+bnn+Y/7M0y5CGHvb+YRqvzpNG6esrf5qmdtKV8uPv695PcN/Y1Xza+kd7adR35WTwRcVfktzdSsMZGn/Lyf7gcPM22BcMdn3JDH45BadXCX/PofvbZmC3JwKKt6zpO51/Mem7cTyc0vtdW9fy773cv1qADV/Ia61/uQBloHLEvlyAUr1XV8qbyrk976SnnP2rp667UoyPU9xfYtUw2i/fj/izSyy83MU3wr9+sSdfvT0x6T7J+vh9GZ3ffjRwn+LRowH9/pOn2xTPni58MqH0k998AP3LhN5932cufL+Uvxvxe73cJWmKLxPwr6D+ZX3cJjG0xlrfX0yy8PlRvhnwZ0me3gOb8wfugd2OBK1SVwfnx0nuHmQ9vt9zm+Tp/Z41fuB+z92XA5/e77mf141e+9a+OiUP/fl+Sh768+Odc5Pkk4eV+EjQGB8/Z9TbH8p6+pDh+w+z9CceZumPPMy6nVZ8ELnbzUNTvf2onNL1Izcs//apar370N7cdfN47l9+Y/IPkqzepO63LP1iklkGu7a2ryXZrb79stv+eE7s7ueyHp5P3I+jPgiw+fMxf7Yxgmc3svfNxtjfuzEdJ2l9v27Gsf7ecYxV49Cbn5ez9u1m1vsUj870rH27mfV+NozO9ExvZmP8zUmePlywZt99uHCb4tnDhfsUjx4u3M/Gw4cLn0zps4cLJu0njrt3R5mHv6lu8v3nAibffy5g8u3nArcpnj0XMPn+cwGTbz8XMPmB5wLP98q82Svffy5g/fvPBT4Zx6PnAta//VzA+g88F7hP8vC5wG2Sp88F7kfy8LnAfZKHzwVs/Mhzgc/SPHwu8Emap88FPkvz8LnA/QQ/fC5wn+Thc4HbCnp2E9vk+88F7nM8ey7gt3S/aQb6A88FbsfxcEr7DzwX+GStPn0u8Emap88FPkvz8LnA/Snjo+cCn5x1Pnku8MnrJIJ3Um5efrS750dPTxhvkzy7UWP2A6+2mv3Aq63378ZYnRJ03r1/9m5Mq4bS0Zt+Mcmob02MX35z6o+STFm4sf/xmxh2+xNaP5Hk8TWj7W9fM95/ofDRNeNtimfXjLez8fSa8X5KH14z3j2CetyQdv9aGj5btX9pTf9thdy9hvUjScRgi2vLTZK7Tvv1wvdZhE3gN1u8+7zgs08p3I9jK77M8sul+B8lqR9JfD+Nal9Msjq+gvDLryT+lmT1H3D5u6ccT13+dnNE8E3q9yXXzebcrtc56Gfw9MOD5ydJ6iMVb6abvr8nuX0wUKckwk9e/7o5+/ZRJb7Oax8/mbe7V7KeflPT7l7JevpNTbv9Ovajb2ravr0iePZNTdt3v+v56Jua9ykefVPzfoWs+sXG3tqNk+xv/5Tm7Tg6Xl14F+yNGe1bZ1X67sfH7+vM1w+s1Pn6gZU6X99eqfP1Ayt1vr69Uu9TfH+lvp/W0NuyHx97592bVNJf9UNg/MrtX/fL+okVsn9ghdw+f3q2Qu5+BeXxCrl7iPVwhdymeLZC7g7eT39s+ZMk9YHEd5KPzwDm3WX80xOaeddW9/yE5u60d/MbQ/LFc+dVE9tf8vEJ+JQfeCl7Svub56TjhKa/VG425/bNoY2btrrHR+dnnyWhlqe95cMkerc5i37cot1szt2nLqyMcdj++KWfKfPbj03m3eOsZ3dK593jrKePCGb/kUcEn6R5em//s4UyUT17fdStMPtPrLa7JM/O9e6XybNnwLPbt58Bz7u3sp49A75N8ewZ8Oz728+A590932fPgOfdRwSfPgN+vlc+fgb8iYk8egY8x/j2M+B7F3n48PU+ycOHr7dJnj58vR/Jw4evn5niwween5niwyeV95v08EnlfZKHTypvD1rPHqvNT1pBnjypvM/x7EnlvP2prGfHX53ff1J5O46nU7q//6Tyk7X69EnlJ2mePqn8LM3TJ5Wf3VycdHPxo28/Txt/8x3Kp5dbn9yhpNppX7xDOXc9Q1qvm894TLv9Ue0621PjF0z+4OYif8SDPm/0Z3coZ8MzhrtL8ruHNz+SpBku+/gbOn+WZE686LLlJsndd4Xr4mQO+1qKPdB2vL6Wor2kioZ/APCvSb7/ksvtTdvW8BzqzfzV9dfvQ7m7j1WTCksb/Q+m9IX2+K/ulXqAvKd+e8fepLgvuV5Pbt8V3L6YRBbuT75uFvrSH1hit0kavsnfxvpqEjzbb+urI+l1a7Dxz5P/WRLFL0Yr/WL0HyYxXN6s/dXNqTstrcvN5tw9xHroZXcpHnrZXYrHC+3uXayHXvbJnOJXKLrOL07IMye6TfHMiR7uljsnum1DedaHdt/J8qgP7fZr0Y9G8ckHpx+N4v73InAV/0vJ/tGPThiekdjuX0yyYO37pV9L8suta7nbnLtm1Ic/f3Gb5H1WX1+d5835kxS4g27b2tdSTIxif5zi9iwXLR/zyz9L8kuS8dUkgiT94/3ihvnxY9Inb7Xdp3j0Vtu6fXb1/RQPP7B8P6H4bt/ka48/2yt1P1L4IvcPk9BIvpxkKVrY9MtJ8IzmNsntr2k98/b7H+R65O33v1ZYOd5H7C/+4GF9xHfL/KhR6/7XLB/NxSc/iPlkLj754dT6HKpO+/JPuNZvlerS1xeT7Gr7fuNXf8J1TYxkf/VnbVft3He+L/+YLD1KGF+fE3xS8cs/XI7PqAzlDtavJ/nizx8PPIUf/BT+D3+Hvb7QPKZ+8XfY3zft6snX6/XxTbs1bn+VoD4V8H72rR/eUv1sJI9uH67b51aPbh/e/5j7w9uH90ke3vlbY/7NSZ7ePrxP8vD24bp7/+rZJfdtimeX3Lcpnl5yL+3fvuS+n9ON2xhb7tbZ/oHyvX1S9Lh89w+Ur3777n+/+2WSx+V7m+Rp5Vn7m5M8Ll/7gbv/y7599/82xcPytR+4+7/s+3f/7+f0cfnemJG+6v0v/fXnHn89hK/bJLL+9z+RuH7LcXcxMWtabfJvY68/2Zj6poy2l9xsTP+BjRl/88a0ahd74xfPFbVXy4j2YV9MIhiJzJ9Isl5f3ZxqOtHe9ldHgh+O7K+vTyz6pW/q5pMkA0ns45Pwe0t7dM/7PsWje95PjfUmxf0h7+HTt08Ovs+evq3bX+N5avH3v3H07OnbJ0mePX27T/Lw6dt9kodP3z5J8uzp2yeb8+zp27p7ZPXwXOIuxcNzif0Dj3nX3Uednp5L3M/ps6dv9xPyzIluUzxzooe75S7F7UXesw25TfFsQx5eat5Z6u1NgKeWen874pml7tcPWOp9koeW+kmSZ5Z6n+Shpd4neWipnyR5ZqmfbM4zS93t25Z6m+KZpd6meLzQ2vct9ZM5fWap9xPyyInuUzxyoqe75c6J+u2XSw2/kMyfUt7tq0nsq0nwFWQu3T9LMvAQf9Bz3j9MUt17b5xfTdLqxb7BPxj3Z0kM75/Z3Uhuv8xu+LLG7S6+TbLxxRL+MvufJcH30PdLfiBJ+/pIJpLYF5NsHCf2mD8wkvHxspe7t/Of7uJPkjzbxZ8kebaLnydpXx/Jo118n+ThLn4+krtdfH8BPfDmpfLT8F+/NL/HtztY7lM8aj/ZY/6tKZ51sNxPaK+jp/T5+nhC764FtG6fW3t9dDvxfhgDPTCDz1j/Mgz59r3Rfffk6uG90fuNUfz0hop+uDGfJKnv9ovaukly91694u1A1dfXkjxrxLtP8agR75MUTxrxZH77Z5XuUzxqpJHbYrF6K/i9Xz98hfU+B1ob3vjh66f77p6ojPrUmIw2Ps5x+zMXj16S3nazY5+9JH2b4tlL0vvuvaqHL0nvu57mZy9J77t77k9fkn6+V6Z8bXX0+oWaX159/aMcKrCw/uGL1nvevmhdLYl3L1p/kuPRy9qfVMuCp1OD1V/G8e3PAdymeLjSb78O2Dq+tqYf/sbzXnefgH3yK9H3o3hYb3eHyIf1tm5/6qe6IaxR891f6u15Ev1iklE3U+yX31D6SxL77n6535Zq3zO+//hn2yJ168CE21T+LEn9FIzJ/uqu6dVwar/ck/k9yd1XAdsL3+O6mL+yIM/TbKnTwjeOryapx8ObnzH/WRJ8eHW/b1p9Mcmo06n3xcHdSG4W7NZZHda6P37ZfO/bPsAn3zu9H8eqK9y96Lryr+N4msReX01SB5o32teStFfTuhXyavMuzd0u1jK2rb/8wtwfLbaFxcZ1/GdJ6jnC7vumAJ8fwz/8Asa7xO9OV+uTD3N+eNiSu9/fHa3W/OAP4v3+Mzf3SfDpiTH2xz9h9t6Y+y8F19X/HP3jGWmvb18EvJO0754b3ed4dnIUn9365nnJ9b2u756YXEX6/SuBP9g382bf3K+Sekgj8+Ovvtwn6Vj1nX8u70+TvL6fpOMsiQ3pD5PUPn7nu0ki8u2Lm8+SPLq6+WRzBlbbsPUDSb662LpsPLtaN7tY7pv66/NPU+5K8HYoEz+dOe3GHWX/xD7ef/c+ng2bc1fG/faN/Ikf8+WXr/5wZusstq+75fb9379657i7VfLwS1L3I3n2Kan747niVr7e/MLqeyDr2/f03kn2DxzP7z4Y+PR4fvvRwYfH87tXrx4fz0f//vH87s2r58fzx/vmzmJvV8mze3ufJHl2c+89KesHfO1+0T+6Ndde+gPrVX9gvepPrFf9gfWq4/uX9+8s+v3r+3cW++4F/icT++y25zvJ+ub9tft5fX4z6ZP98/CK+JMsD6/wP8ny8M7WZ1me3dr6bF6e3dv6ZN0+vB/0B1lubgh9luXZHaH7LM9vCX02v89u5/yJZ9+cAN69lPUDt2L8d8TjrItz/NmtGJ30xvvdrZj5Az9R9M5yd9fg4efrbzdIG54uy80vdb+HMn9kg9bfvUHoEb/e0brZoLuHXt9fbmp1kq9T9904bn/jD00/1FH9l2ld/ftH1NtxdPvfXPX8b8Zx+/0+v5F2ridf9ATO/iTLa9XXb97M17Z/lGXXC5pv/vCbtZ/MSn36auzbvbP/3hzXKDfmRG9mdv/IzO4fmdn9/bUit68lP/yBvfcw9bvlcz+Qh7+w90mSZ7+w98mUPPuFvWvP/YDdt7vfxnpu93cfFnj4G3vvodzd6Xr4I3v//9quZWfS04i+S9ZZcCsKniWyIsdxopGsOJrEiyz87uGfC9Dd/g7ng+qN1TMjH0HBB9TtnCUKxWH9saGRs83J7DUUtGtJnb2GgoqtSHGqhoJrYSh1qg8RALBdKHmqhgHrYTh9qhbuxG3b44Wxi0EpVC12Cim398E0Dy4gqrAYj4QV3PsII6OTllPcaygme9ab7FlvsGe9yZ4NBns2vHnPssJ7bSSYHptS3vsqt3C+U5BiFr9TkGQWu1OwYge9U4rBTimnOwVe7KyWg/fRQPK9oQSLlwr4enKaStKd24s/5EENmxW46xgk9yXOJYD8k4/ZxLT6btMOGtJcMpwQetWSInxLFEoXrV3YiIOouu/rrMmD6IHHXIScDl9DQdEqToivgZwncH2C7f+cFJ//kn5DriWnxbfCYcX44N7V3MtcNNeCVtqguMuLQXGXl/PiLohBJte8GBR3eTkv7vJiUdzFrw1IBi92CVfcBUHY4q4ViDsHIWt2PHpnPKSlZdOwbJnZAoQrM/P5vIdmBcKl6vF0kht0AMGDkejbR8IVvPEgux8gW/DmFyJYXMHbYt+zG8W/e3nIWjWvMKBP1qothsLVqnmUDGOfOigVRteqwZFwtWrL9ywlFtziIN7iVYxQ2FAVfM1yesH+S2/U8UupyPlLCWGwL6WiBi8lRNvGvpRKtXgp0WsDD2ro81C6wS1wFyxOR+T0kMrBCxRSOhijsNrBi7GQ4sFLN45UD166caR88GJWpH7wAoUUEMbONnvuJ+w/MRLCCxBOQ7hFnc9DB8FZ1H7DkdB2hSvM6Qivdi0rJLzCYZWElziklPAiRjo1Rs+X4msgD7Gzr1VE14lcRtG4TdpA0hgnTPg4OE4Hc6LGOB3M6ho0uxwLGywSuaSywQKFVCXwIfh3o7DiBgsUUt2goRzLG2AMjkATY7AMmg3lXOEAZ8l5geM2mDOF44VdKR7OBQZFxEmvr8ru90eSAq/OAo4VuGWUxWKvRQOh4xUKRwy8QCGZgRcoJDXwCoXjBl7NiCMHbg+QcH66pXB+uqVgsePSueLxyrAcQ/DCKOTRlML50UQuDsJYFaD2Ajr/0ad39XhboaQp15gvC3MDamfi2CMxBhk6WxVwszYRE5sssrhUMTlEYa2Cm22m+Tg3N1bdbNpx44XRcFAjUoYF2HzzD1TtpqggFxgUF+QKgyGDXFDksEu0gqFXCLqXN1YI4bArBDHIFcIY1Aph7i73/ZWR566dmyxivR62gVwTgGFvjmyrD7jBi8sPBERlSOYHIAaZHwiaz/MDAZIZcvmBAPvD2PwAvzbX+QG8SbiueoxBNtVD5mA2i7sAofIUATHTcJs1hMUFyHVLQxi2WRqDkL3SGIRscl5Mh+txhiEQtsWZBwEdzgsQrsF5YROuL3lx0HNtyQGKd1F9opjIrAfOS5rju881mqHqeVY7IPku+tZCvWHsrYUwyFsrOn9+a0V3zDrrv4Sxzm8tem0UrY2eZ7UjSgKwWe3FSLia4gg7wrjEYHTVIKUNR0ImBqFJ2IQrBiETrhHFulm7wuQXm3CFIyHJtuD5mrtFSp74Sp7PV3hr8Q7kCoZ0IBcwtP8Yg3s/DumHYgzOD11gMH4o2rWsXkM89x9jyOc3cQzHFPQYg72Jwzn9u4/Rnd/EqBmMvon5tdG9PUK6j/Hce4wo7M96jwsQzns8jnSsTlbSd1QDh03P/bVowFBOYwBvLRrwk0cTenJoVdIfj9lij0CbkOEFiGEwG3av4rlwe9WCPc2CO82COc2GNw1blYxOxPPgREvWHgYn0IWZRjVDe4nPlGnyPAzY18RI8C0wuBRozMfdA9Aerm+P5NUDe2QL9reIerTYxul4HgpHtZa5s0HmmaDsSSQNIvQnZp7LMZ4R0DSkbw4vYSoAivGGKQaDloR4ieEjkvTy04nafucrHiHEhMxtU4Tgs4zi4CxzUDE+v7lRpoT9cCEG+eGi3i7SIigYWHqQtf28aj5CNSXcPocI1D5P/nyfQwx6n8N2LnafI/ai0Pk4W2bpWq8SYpCal/Br0al1UP0s0vLytRQ5/1qKnH8tRd96fjxaZArPPlsk4Wzt6BOXWUCzbmKUc4wHLdBHDFQ95bUrpXmdCPye9YwhRukUP+2nbGKUjoF0lQWfhb1ctoS0i5EGhpxjxGu5+AxbCXqUuYXu6jVGPF9biEGuLcbg1jajSsEgvX85SD3HmL6XexjdSW7hRdnDiHEwhSW3h5H6QRYfiO1vjaMrzccIlOZ5jLyJUcf9Ujf3RwqDfyBuru3gAm4/dRPDD24I2V3b3GkDUtbNby4Phli0thCjjqfQpBRw89sf2TIXzjH89jh0YOQ9jDoaBmrS83Gge64a3NnV4M6uBnd2OT/XaQxwrmMM7lyHGOS5DjHYcx3VfufeKpdySVvvj1SHvGMt1/bA79OJCqlcv099igZaMilCh98NGqO5heN1KCibI/odRWVmuy7PINATGqQwDwR4+gyCSDXdcKfcnPt/AUGppa+iU18/4IdGndcJQdvK9ARQZFuIUieiqevNAvmD9EvU+NvJOOcfn907jCJuoMjEOffiNifYrKODuX5e56ecLIoxpUmdYH6RvEwHYLQoWc9ixnptEsQ8ItpJG9tP2cOo/VUjdapHurc02g+DdgvOXKO3UEoaUYAi1zapx/Hhehwfht3vvj1mRrNQi11dBVYScr5r8D2vE66DMwuMvlVryFeBSLgsRcdcykMj8p3FLbWXRbXfKEScUAMVGfTCGFzQK6EHARf0umGRVLbtqgNF0i6K1IGiICSZFi40tTr5vPkwoVyVyerMFil1e3WGv1fr5sFY3bizqg+CAsanJyOGoI5GPJchaOVrTg7sND1OsGCMdm25UcSuPm2ijPhm+x1kF2V0ROvcV31jz1Yd9SYVndSQDNfX2ndK+y26BxPCIIePbn5/5k0QHzZBpPdnB5mqCm+BtCn0o809eE1P6XyorNAv9BDi/Bk/VVkk1D1Fp/MT6l2k0/mw0HJE1B/EfV7nc9rSAmn8yKkgDBnH0tNT2vMYg/NOdLp1njGaOc6rVzAGeYfW4+oVbI9eMSYlVmCPippsU0+55DQLeLyiQFepX37eXTvUcCDS32t5Vqq4OR3pUbGWS5J9lEnboe6jdBmD/JB1fURB20RK/3ylIozjWod6XOtQDWodqkWtg7h0XusAtc5S6uGFNOv8+edLQty5t4UxuLNI3LG3hQ0ifZ8m0QIMglS0WINADNIgPrzXIDkNic251+LVIMnAIMnAIMfEKgU29/XbKs0iHc+PGYzRSz+Se4hzuue5WKgdSjBQO/SolSb7wZIhaCDBZDoG71WszuT7GvuZxdGH8jwUlCoY2gtTRFz1xjhy5+71c/35yzhgBSl7TyCQOo7F5ulNia1Yb4Bk10m05nfEXZDeo5AjkFiLkMBxapvMc7PES8E0cmv6e6S5NRGAoOlo/P5arDpXHNyySRmGLYj/VKK8G+Wh03dmrX62CkaZeVRns7yioOZ0P0oPfA27KCO35ZNLuyhpEhqYmW5fUFCZLMuqh40bu55ymAVdXoaCSsrDON2m4pLntC6KQ5GBRgjB5WBgaTz5oMcg9Is+FYOTusIiWY5xQywUt8RAcUsMFLfEQnFLDBS3xERxSywUt+AmIQk3RKCYJke4gRxyWkUCgrAiEhWS35GEG3AkrIREhZTOtIIEhmF1AFcwrA4FtAwrQwFBWBUKGLDkOFHQ58NSokAMkhFF0P1HMqKIBphq4xhR4EhYq8LVJRUo8HalBSgwDK0/sYAh5SfwM2eK4sbdl1KnMcnpGmLxEO7j8A8V5zcfwr2/ys9hnINHOULBzpcORuYC1CekGMS2ikFsq+T3YpABQ2zUXinW7JuQUUFEKWknz0/FAe5iiPLV6F93SXZox0KUPKozcqy7KKWrgvrZdbuJUnXkUp3fRKFDF3gsIyX7UdEAUCB7Me2kQxTaSa/ZwklHNIG0k46NW0fZl/fbZmGPbGwW9simlwihuPNIc4Zll2ykOcOEFRtpRgkarT3OpbPK76uwFGKD1H4mlDoXFNwBqb63g9RZ+fgFJBskvvBAZMg1SN2cTegHfw21otnE984mjifGTLryBwOR9w7kS3HNtwi+gwPR44FgDO6dklHui1ZcRYmE6Z0yd0+87DM5jmFCCC6GCUkt2RgmBGFjmBmSZbMxTMh3RMYwM6ReI2OYOZTjGCbEIGOYObrzGGaO/jiGmVE/Fx3D5NdGUXz5PIaZDUgCPaKzomOYEISNYYoaxDDhSNgYphSTGCaGoWOYCxg2hgktw8YwIQgbw4T6QFy0TVjlTRDDFDbXC2KYOZ2zZX8JYB3HMOFIWKuqQQwTb1c6holh6BjmAoaNYcJnDhfDxC8lJoaJaMhZ71GKhfcoBsXosDYv5t4BHGer+jsgbdf3grboZRMk9Tao9EDs9gKCqhU1lBHzA6WGLh6/yCEE2dkZDF7kEIR+kWeLqgKoeJvL6PUp7nppsG/QaZ3bi21W0c53QGrnMXfBb4KU3gH12JHyDJLVgjAzqwFhpsfUijoq2rLK9SIjPkNW0jurmlilGFgF7dpQ5yKlAHYtAindV4kugK2fITMhbRXU00VbBW5bGZoG7Xe6lMvUavEyh8S10mVVk+h8gcmzVVAhpkYZvhPwBItFuKAYhAuKQbigWoQLqkG4oJqEC4pBuGCxS/peC4qcFZhj9TpIG6tug7hzEO3pxKgZbPrKlnDJpmHjVOg+h7hvgvTdFuea1GcQRdparG7EAoQLCeVFLr7+YYz7ZSTp7SMZX2DLbhqA7H6AMdRB8lcU2AS9ZnPub0gN8Fgq5xuF/3i2l0cHnxQ6ldTD2sXBi+tnF+714oFD6V0v7XguYCjpOJqjXgyiOXAkZDRn8VLS8Wqr5TLfpb5AlKmqoNawhUJmvJBgLptW0eDP30l6rsqKMch3ksK3PflOUuQ2ke8kDdngncSvDTim4SYh0yqK+gHZoxF5gHRaBYKwaRUEQqdV4EjYtAr2uui0ysJ5Y/MhcEpsPgSCsPkQFHNgz/p8ng+BGGQ+RNN5Tbcmi5puOBLWqsUgH4K3K50PwTB0PmQBw+ZDFhG7vvHb73rJB6Uw8dVQwoRyGcuB68zG/VIgvx8PaqkTeHBp7fzKxaEWVEUNX5J7aEryXGn7NBD0Jc/9p1MH+EcvKg+ivW64hajcNYjK21Ga3+TGPim7KKqj4rcGhIKkuHvWSuf8yi2MmkY1W9nEaMmX/u3M/LmvKIiIkK32zegwaG7IuNcfKNncy1gQxXE37DjcUrxjVjdqL7eXpsfZqsr58iIM+PXFnoJrH7PfBAm9DaHhoQ0P24PpjQZRhuqd96lso+TBGl22xxJ7LMfPog83UWRQ8stEyX8XJQ+vZ3IU7s6oR+x8DHBGen60IQz2aINJOHrHFXd+tC0MOxgro+iuUciDCWKQBxO5OAgDlhdwlTC4QoGqhAmng8BcalxHIWTcHC7+w5d7i7YzD+7PXOMmSBnn/CwVf5P7c6jYuACmk4oBgyhGIbXvMQanfb/AoLTv4dpoDyZ9hHM2F/gBJO2ChAESwdIUd94jgzG4HoriwnsxyKg0Nupgo9HZM7m3Mj1qGWYv+CbINJJtkNJTS+3nNkh/R2AQyMLN3TOYyJs64xfSAh2kXd278gQ961eDXhU3QbUG7r5Lp7bAOhyd60t0zlncwRjiF1LE7WHUXgbbfm7qgRQd49jVJSl9VRvcri7JlGlI2/YoA+N6XaDWy+g0TzJFRvYx9vRi0qgQS3OF2C2MwXefFOwx6AjV/v5oFxmI5BXUJ5Ryb0pNucplpHUxEi6mWGBGi4opImeKDSlCDDYWWKAmlwkKHVHEKGxEsaA2LtLthhik2w0xaLe7oFuXdbuxYeuIZ9QADOtNvmKYXyC/4tVQyM84nacGgsF3jEHoT9AkwQBR+A85WaQGSjpPDUAM9kNOFqmBIgapAWxY8kOGKnKud9bIowJHeJ4OapYNpb8bw/zmK88gYDpZu2WzzmpW5cZsOpWBeBfQbIrFbOp7ZzOqgdvPvZejxF5cIjHlPYwwxhHUAKO4zbn02hSJvm6OY0iKRLdt0zpsKpsYaWBkIEWJDzQu9o0xuNg3e7AiDHjvsUk5fAOTSbkCizvpIx6isEm5BQqZlMMobFIOo7BJuQUKmZRbzIhMyhXkNbGPCoTBPiqKRRq4IEUu+lGBDUsm5bBRyIMJYpAHE7k4EAO6f+RcIAY5F9INBRjF4IwtJkdsNTliq8kRW02O2GpyxFaTI7aaHLHV4oit7vyIhRjkEQsx6B1XncURWy2OWGwU7ljCGNyxxC4OwED+Vox5EpqfQi/Vb2LkTYw60q/TJ3wLI41Mf5oSwfcw4uipm9Th72H40WY4y6Tcwug8eO0nGAfkts1DvxitLcSog6ZiZra9hTG4ZKsL5xh+exw6MPIeRh2XRE16Po4E9nowWNtgsLbBYG2DwdoGg7UNBmsbztc2of630FlDQpA5L/7Ev1DjeUELxuCKUWoM78XgClqgTeOQkY7qkE0F1gp8jyteC9HCYaRREZPml+rrMPQ8SFphFQkXJIWzkUFYLkEuZ4MxOmNCkAwsEgtEGR2FIm4ThSzPwxhced4CgynPS8eFpOm4kDQeF/fE4+IeSEfqZk1Bp9eSBQuU0QjSUOIlSvMpIM4X/shvOF7zJg67TyEGuU8xBrNPUSlJO6G+f7cPRNxRwg2M7nHXWP0lBlKN5PfJAoXeJ8lonySDfZIM9kna2yc/tD/8+NOnz3/95deffvzvp1//9Z/2//3+AfX5049/++Xnb3/8x2//+mn61//+79/f/+Vvnz/98sunf/71359//ennv//2+ecPpI9/+5P79p+/+PAhDOFD9uWHP/8ptr9pB5+E9tt/+2cNf/74r378lf/yVzl8/FUO6YffPwb5fw==","expression_width":{"Bounded":{"width":4}}},{"name":"public_dispatch","hash":"5946815526093338869","is_unconstrained":true,"custom_attributes":["abi_public"],"abi":{"parameters":[{"name":"selector","type":{"kind":"field"},"visibility":"private"}],"return_type":null,"error_types":{"459713770342432051":{"error_kind":"string","string":"Not initialized"},"9967937311635654895":{"error_kind":"string","string":"Initialization hash does not match"},"13455385521185560676":{"error_kind":"string","string":"Storage slot 0 not allowed. Storage slots must start from 1."},"14415304921900233953":{"error_kind":"string","string":"Initializer address is not the contract deployer"},"14990209321349310352":{"error_kind":"string","string":"attempt to add with overflow"},"15764276373176857197":{"error_kind":"string","string":"Stack too deep"},"16431471497789672479":{"error_kind":"string","string":"Index out of bounds"},"16810041750452690220":{"error_kind":"fmtstring","length":27,"item_types":[{"kind":"field"}]}}},"bytecode":"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","debug_symbols":"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","expression_width":{"Bounded":{"width":4}}},{"name":"sync_private_state","hash":"3004307266969092657","is_unconstrained":true,"custom_attributes":["abi_utility"],"abi":{"parameters":[],"return_type":null,"error_types":{"361444214588792908":{"error_kind":"string","string":"attempt to multiply with overflow"},"992401946138144806":{"error_kind":"string","string":"Attempted to read past end of BoundedVec"},"1998584279744703196":{"error_kind":"string","string":"attempt to subtract with overflow"},"3080037330898348111":{"error_kind":"fmtstring","length":132,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"4261968856572588300":{"error_kind":"string","string":"Value does not fit in field"},"4440399188109668273":{"error_kind":"string","string":"Input length must be a multiple of 32"},"6504742485148360234":{"error_kind":"fmtstring","length":40,"item_types":[]},"7564993426627941149":{"error_kind":"fmtstring","length":48,"item_types":[{"kind":"field"},{"kind":"field"}]},"7995966536718645961":{"error_kind":"fmtstring","length":61,"item_types":[{"kind":"field"},{"kind":"field"}]},"9791669845391776238":{"error_kind":"string","string":"0 has a square root; you cannot claim it is not square"},"9885968605480832328":{"error_kind":"string","string":"Attempted to read past the length of a CapsuleArray"},"10791800398362570014":{"error_kind":"string","string":"extend_from_bounded_vec out of bounds"},"11021520179822076911":{"error_kind":"string","string":"Attempted to delete past the length of a CapsuleArray"},"12469291177396340830":{"error_kind":"string","string":"call to assert_max_bit_size"},"12913276134398371456":{"error_kind":"string","string":"push out of bounds"},"13060541637244024094":{"error_kind":"fmtstring","length":98,"item_types":[]},"13450089406971132036":{"error_kind":"fmtstring","length":144,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"14990209321349310352":{"error_kind":"string","string":"attempt to add with overflow"},"15764276373176857197":{"error_kind":"string","string":"Stack too deep"},"16431471497789672479":{"error_kind":"string","string":"Index out of bounds"},"16792019527863081935":{"error_kind":"fmtstring","length":77,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"17154023812102399658":{"error_kind":"fmtstring","length":128,"item_types":[{"kind":"integer","sign":"unsigned","width":32}]},"17803644318014042523":{"error_kind":"fmtstring","length":58,"item_types":[{"kind":"field"}]}}},"bytecode":"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","debug_symbols":"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","expression_width":{"Bounded":{"width":4}}}],"outputs":{"structs":{"functions":[{"kind":"struct","path":"SimpleLogging::get_counter_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"SimpleLogging::get_counter_parameters","fields":[{"name":"_owner","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}}]}},{"name":"return_type","type":{"kind":"integer","sign":"unsigned","width":64}}]},{"kind":"struct","path":"SimpleLogging::increment_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"SimpleLogging::increment_parameters","fields":[{"name":"_owner","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}}]}}]},{"kind":"struct","path":"SimpleLogging::initialize_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"SimpleLogging::initialize_parameters","fields":[{"name":"_headstart","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"_owner","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}}]}}]},{"kind":"struct","path":"SimpleLogging::process_message_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"SimpleLogging::process_message_parameters","fields":[{"name":"message_ciphertext","type":{"kind":"struct","path":"std::collections::bounded_vec::BoundedVec","fields":[{"name":"storage","type":{"kind":"array","length":17,"type":{"kind":"field"}}},{"name":"len","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"message_context","type":{"kind":"struct","path":"aztec::messages::processing::message_context::MessageContext","fields":[{"name":"tx_hash","type":{"kind":"field"}},{"name":"unique_note_hashes_in_tx","type":{"kind":"struct","path":"std::collections::bounded_vec::BoundedVec","fields":[{"name":"storage","type":{"kind":"array","length":64,"type":{"kind":"field"}}},{"name":"len","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"first_nullifier_in_tx","type":{"kind":"field"}},{"name":"recipient","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}}]}}]}}]},{"kind":"struct","path":"SimpleLogging::sync_private_state_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"SimpleLogging::sync_private_state_parameters","fields":[]}}]}]},"globals":{"storage":[{"kind":"struct","fields":[{"name":"contract_name","value":{"kind":"string","value":"SimpleLogging"}},{"name":"fields","value":{"kind":"struct","fields":[{"name":"counters","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000001"}}]}}]}}]}]}},"file_map":{"3":{"source":"use crate::cmp::{Eq, Ord};\nuse crate::convert::From;\nuse crate::runtime::is_unconstrained;\n\nmod check_shuffle;\nmod quicksort;\n\nimpl<T, let N: u32> [T; N] {\n    /// Returns the length of this array.\n    ///\n    /// ```noir\n    /// fn len(self) -> Field\n    /// ```\n    ///\n    /// example\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let array = [42, 42];\n    ///     assert(array.len() == 2);\n    /// }\n    /// ```\n    #[builtin(array_len)]\n    pub fn len(self) -> u32 {}\n\n    /// Returns this array as a slice.\n    ///\n    /// ```noir\n    /// let array = [1, 2];\n    /// let slice = array.as_slice();\n    /// assert_eq(slice, &[1, 2]);\n    /// ```\n    #[builtin(as_slice)]\n    pub fn as_slice(self) -> [T] {}\n\n    /// Applies a function to each element of this array, returning a new array containing the mapped elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let b = a.map(|a| a * 2);\n    /// assert_eq(b, [2, 4, 6]);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> [U; N] {\n        let uninitialized = crate::mem::zeroed();\n        let mut ret = [uninitialized; N];\n\n        for i in 0..self.len() {\n            ret[i] = f(self[i]);\n        }\n\n        ret\n    }\n\n    /// Applies a function to each element of this array along with its index,\n    /// returning a new array containing the mapped elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let b = a.mapi(|i, a| i + a * 2);\n    /// assert_eq(b, [2, 5, 8]);\n    /// ```\n    pub fn mapi<U, Env>(self, f: fn[Env](u32, T) -> U) -> [U; N] {\n        let uninitialized = crate::mem::zeroed();\n        let mut ret = [uninitialized; N];\n\n        for i in 0..self.len() {\n            ret[i] = f(i, self[i]);\n        }\n\n        ret\n    }\n\n    /// Applies a function to each element of this array.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let mut b = [0; 3];\n    /// let mut i = 0;\n    /// a.for_each(|x| {\n    ///     b[i] = x;\n    ///     i += 1;\n    /// });\n    /// assert_eq(a, b);\n    /// ```\n    pub fn for_each<Env>(self, f: fn[Env](T) -> ()) {\n        for i in 0..self.len() {\n            f(self[i]);\n        }\n    }\n\n    /// Applies a function to each element of this array along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let mut b = [0; 3];\n    /// a.for_eachi(|i, x| {\n    ///     b[i] = x;\n    /// });\n    /// assert_eq(a, b);\n    /// ```\n    pub fn for_eachi<Env>(self, f: fn[Env](u32, T) -> ()) {\n        for i in 0..self.len() {\n            f(i, self[i]);\n        }\n    }\n\n    /// Applies a function to each element of the array, returning the final accumulated value. The first\n    /// parameter is the initial value.\n    ///\n    /// This is a left fold, so the given function will be applied to the accumulator and first element of\n    /// the array, then the second, and so on. For a given call the expected result would be equivalent to:\n    ///\n    /// ```rust\n    /// let a1 = [1];\n    /// let a2 = [1, 2];\n    /// let a3 = [1, 2, 3];\n    ///\n    /// let f = |a, b| a - b;\n    /// a1.fold(10, f); //=> f(10, 1)\n    /// a2.fold(10, f); //=> f(f(10, 1), 2)\n    /// a3.fold(10, f); //=> f(f(f(10, 1), 2), 3)\n    ///\n    /// assert_eq(a3.fold(10, f), 10 - 1 - 2 - 3);\n    /// ```\n    pub fn fold<U, Env>(self, mut accumulator: U, f: fn[Env](U, T) -> U) -> U {\n        for elem in self {\n            accumulator = f(accumulator, elem);\n        }\n        accumulator\n    }\n\n    /// Same as fold, but uses the first element as the starting element.\n    ///\n    /// Requires the input array to be non-empty.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [1, 2, 3, 4];\n    ///     let reduced = arr.reduce(|a, b| a + b);\n    ///     assert(reduced == 10);\n    /// }\n    /// ```\n    pub fn reduce<Env>(self, f: fn[Env](T, T) -> T) -> T {\n        let mut accumulator = self[0];\n        for i in 1..self.len() {\n            accumulator = f(accumulator, self[i]);\n        }\n        accumulator\n    }\n\n    /// Returns true if all the elements in this array satisfy the given predicate.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [2, 2, 2, 2, 2];\n    ///     let all = arr.all(|a| a == 2);\n    ///     assert(all);\n    /// }\n    /// ```\n    pub fn all<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = true;\n        for elem in self {\n            ret &= predicate(elem);\n        }\n        ret\n    }\n\n    /// Returns true if any of the elements in this array satisfy the given predicate.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [2, 2, 2, 2, 5];\n    ///     let any = arr.any(|a| a == 5);\n    ///     assert(any);\n    /// }\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        for elem in self {\n            ret |= predicate(elem);\n        }\n        ret\n    }\n\n    /// Concatenates this array with another array.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr1 = [1, 2, 3, 4];\n    ///     let arr2 = [6, 7, 8, 9, 10, 11];\n    ///     let concatenated_arr = arr1.concat(arr2);\n    ///     assert(concatenated_arr == [1, 2, 3, 4, 6, 7, 8, 9, 10, 11]);\n    /// }\n    /// ```\n    pub fn concat<let M: u32>(self, array2: [T; M]) -> [T; N + M] {\n        let mut result = [crate::mem::zeroed(); N + M];\n        for i in 0..N {\n            result[i] = self[i];\n        }\n        for i in 0..M {\n            result[i + N] = array2[i];\n        }\n        result\n    }\n}\n\nimpl<T, let N: u32> [T; N]\nwhere\n    T: Ord + Eq,\n{\n    /// Returns a new sorted array. The original array remains untouched. Notice that this function will\n    /// only work for arrays of fields or integers, not for any arbitrary type. This is because the sorting\n    /// logic it uses internally is optimized specifically for these values. If you need a sort function to\n    /// sort any type, you should use the [`Self::sort_via`] function.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let arr = [42, 32];\n    ///     let sorted = arr.sort();\n    ///     assert(sorted == [32, 42]);\n    /// }\n    /// ```\n    pub fn sort(self) -> Self {\n        self.sort_via(|a, b| a <= b)\n    }\n}\n\nimpl<T, let N: u32> [T; N]\nwhere\n    T: Eq,\n{\n    /// Returns a new sorted array by sorting it with a custom comparison function.\n    /// The original array remains untouched.\n    /// The ordering function must return true if the first argument should be sorted to be before the second argument or is equal to the second argument.\n    ///\n    /// Using this method with an operator like `<` that does not return `true` for equal values will result in an assertion failure for arrays with equal elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let arr = [42, 32]\n    ///     let sorted_ascending = arr.sort_via(|a, b| a <= b);\n    ///     assert(sorted_ascending == [32, 42]); // verifies\n    ///\n    ///     let sorted_descending = arr.sort_via(|a, b| a >= b);\n    ///     assert(sorted_descending == [32, 42]); // does not verify\n    /// }\n    /// ```\n    pub fn sort_via<Env>(self, ordering: fn[Env](T, T) -> bool) -> Self {\n        // Safety: `sorted` array is checked to be:\n        // a. a permutation of `input`'s elements\n        // b. satisfying the predicate `ordering`\n        let sorted = unsafe { quicksort::quicksort(self, ordering) };\n\n        if !is_unconstrained() {\n            for i in 0..N - 1 {\n                assert(\n                    ordering(sorted[i], sorted[i + 1]),\n                    \"Array has not been sorted correctly according to `ordering`.\",\n                );\n            }\n            check_shuffle::check_shuffle(self, sorted);\n        }\n        sorted\n    }\n}\n\nimpl<let N: u32> [u8; N] {\n    /// Converts a byte array of type `[u8; N]` to a string. Note that this performs no UTF-8 validation -\n    /// the given array is interpreted as-is as a string.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let hi = [104, 105].as_str_unchecked();\n    ///     assert_eq(hi, \"hi\");\n    /// }\n    /// ```\n    #[builtin(array_as_str_unchecked)]\n    pub fn as_str_unchecked(self) -> str<N> {}\n}\n\nimpl<let N: u32> From<str<N>> for [u8; N] {\n    /// Returns an array of the string bytes.\n    fn from(s: str<N>) -> Self {\n        s.as_bytes()\n    }\n}\n\nmod test {\n    #[test]\n    fn map_empty() {\n        assert_eq([].map(|x| x + 1), []);\n    }\n\n    global arr_with_100_values: [u32; 100] = [\n        42, 123, 87, 93, 48, 80, 50, 5, 104, 84, 70, 47, 119, 66, 71, 121, 3, 29, 42, 118, 2, 54,\n        89, 44, 81, 0, 26, 106, 68, 96, 84, 48, 95, 54, 45, 32, 89, 100, 109, 19, 37, 41, 19, 98,\n        53, 114, 107, 66, 6, 74, 13, 19, 105, 64, 123, 28, 44, 50, 89, 58, 123, 126, 21, 43, 86, 35,\n        21, 62, 82, 0, 108, 120, 72, 72, 62, 80, 12, 71, 70, 86, 116, 73, 38, 15, 127, 81, 30, 8,\n        125, 28, 26, 69, 114, 63, 27, 28, 61, 42, 13, 32,\n    ];\n    global expected_with_100_values: [u32; 100] = [\n        0, 0, 2, 3, 5, 6, 8, 12, 13, 13, 15, 19, 19, 19, 21, 21, 26, 26, 27, 28, 28, 28, 29, 30, 32,\n        32, 35, 37, 38, 41, 42, 42, 42, 43, 44, 44, 45, 47, 48, 48, 50, 50, 53, 54, 54, 58, 61, 62,\n        62, 63, 64, 66, 66, 68, 69, 70, 70, 71, 71, 72, 72, 73, 74, 80, 80, 81, 81, 82, 84, 84, 86,\n        86, 87, 89, 89, 89, 93, 95, 96, 98, 100, 104, 105, 106, 107, 108, 109, 114, 114, 116, 118,\n        119, 120, 121, 123, 123, 123, 125, 126, 127,\n    ];\n    fn sort_u32(a: u32, b: u32) -> bool {\n        a <= b\n    }\n\n    #[test]\n    fn test_sort() {\n        let mut arr: [u32; 7] = [3, 6, 8, 10, 1, 2, 1];\n\n        let sorted = arr.sort();\n\n        let expected: [u32; 7] = [1, 1, 2, 3, 6, 8, 10];\n        assert(sorted == expected);\n    }\n\n    #[test]\n    fn test_sort_100_values() {\n        let mut arr: [u32; 100] = [\n            42, 123, 87, 93, 48, 80, 50, 5, 104, 84, 70, 47, 119, 66, 71, 121, 3, 29, 42, 118, 2,\n            54, 89, 44, 81, 0, 26, 106, 68, 96, 84, 48, 95, 54, 45, 32, 89, 100, 109, 19, 37, 41,\n            19, 98, 53, 114, 107, 66, 6, 74, 13, 19, 105, 64, 123, 28, 44, 50, 89, 58, 123, 126, 21,\n            43, 86, 35, 21, 62, 82, 0, 108, 120, 72, 72, 62, 80, 12, 71, 70, 86, 116, 73, 38, 15,\n            127, 81, 30, 8, 125, 28, 26, 69, 114, 63, 27, 28, 61, 42, 13, 32,\n        ];\n\n        let sorted = arr.sort();\n\n        let expected: [u32; 100] = [\n            0, 0, 2, 3, 5, 6, 8, 12, 13, 13, 15, 19, 19, 19, 21, 21, 26, 26, 27, 28, 28, 28, 29, 30,\n            32, 32, 35, 37, 38, 41, 42, 42, 42, 43, 44, 44, 45, 47, 48, 48, 50, 50, 53, 54, 54, 58,\n            61, 62, 62, 63, 64, 66, 66, 68, 69, 70, 70, 71, 71, 72, 72, 73, 74, 80, 80, 81, 81, 82,\n            84, 84, 86, 86, 87, 89, 89, 89, 93, 95, 96, 98, 100, 104, 105, 106, 107, 108, 109, 114,\n            114, 116, 118, 119, 120, 121, 123, 123, 123, 125, 126, 127,\n        ];\n        assert(sorted == expected);\n    }\n\n    #[test]\n    fn test_sort_100_values_comptime() {\n        let sorted = arr_with_100_values.sort();\n        assert(sorted == expected_with_100_values);\n    }\n\n    #[test]\n    fn test_sort_via() {\n        let mut arr: [u32; 7] = [3, 6, 8, 10, 1, 2, 1];\n\n        let sorted = arr.sort_via(sort_u32);\n\n        let expected: [u32; 7] = [1, 1, 2, 3, 6, 8, 10];\n        assert(sorted == expected);\n    }\n\n    #[test]\n    fn test_sort_via_100_values() {\n        let mut arr: [u32; 100] = [\n            42, 123, 87, 93, 48, 80, 50, 5, 104, 84, 70, 47, 119, 66, 71, 121, 3, 29, 42, 118, 2,\n            54, 89, 44, 81, 0, 26, 106, 68, 96, 84, 48, 95, 54, 45, 32, 89, 100, 109, 19, 37, 41,\n            19, 98, 53, 114, 107, 66, 6, 74, 13, 19, 105, 64, 123, 28, 44, 50, 89, 58, 123, 126, 21,\n            43, 86, 35, 21, 62, 82, 0, 108, 120, 72, 72, 62, 80, 12, 71, 70, 86, 116, 73, 38, 15,\n            127, 81, 30, 8, 125, 28, 26, 69, 114, 63, 27, 28, 61, 42, 13, 32,\n        ];\n\n        let sorted = arr.sort_via(sort_u32);\n\n        let expected: [u32; 100] = [\n            0, 0, 2, 3, 5, 6, 8, 12, 13, 13, 15, 19, 19, 19, 21, 21, 26, 26, 27, 28, 28, 28, 29, 30,\n            32, 32, 35, 37, 38, 41, 42, 42, 42, 43, 44, 44, 45, 47, 48, 48, 50, 50, 53, 54, 54, 58,\n            61, 62, 62, 63, 64, 66, 66, 68, 69, 70, 70, 71, 71, 72, 72, 73, 74, 80, 80, 81, 81, 82,\n            84, 84, 86, 86, 87, 89, 89, 89, 93, 95, 96, 98, 100, 104, 105, 106, 107, 108, 109, 114,\n            114, 116, 118, 119, 120, 121, 123, 123, 123, 125, 126, 127,\n        ];\n        assert(sorted == expected);\n    }\n\n    #[test]\n    fn mapi_empty() {\n        assert_eq([].mapi(|i, x| i * x + 1), []);\n    }\n\n    #[test]\n    fn for_each_empty() {\n        let empty_array: [Field; 0] = [];\n        empty_array.for_each(|_x| assert(false));\n    }\n\n    #[test]\n    fn for_eachi_empty() {\n        let empty_array: [Field; 0] = [];\n        empty_array.for_eachi(|_i, _x| assert(false));\n    }\n\n    #[test]\n    fn map_example() {\n        let a = [1, 2, 3];\n        let b = a.map(|a| a * 2);\n        assert_eq(b, [2, 4, 6]);\n    }\n\n    #[test]\n    fn mapi_example() {\n        let a = [1, 2, 3];\n        let b = a.mapi(|i, a| i + a * 2);\n        assert_eq(b, [2, 5, 8]);\n    }\n\n    #[test]\n    fn for_each_example() {\n        let a = [1, 2, 3];\n        let mut b = [0, 0, 0];\n        let b_ref = &mut b;\n        let mut i = 0;\n        let i_ref = &mut i;\n        a.for_each(|x| {\n            b_ref[*i_ref] = x * 2;\n            *i_ref += 1;\n        });\n        assert_eq(b, [2, 4, 6]);\n        assert_eq(i, 3);\n    }\n\n    #[test]\n    fn for_eachi_example() {\n        let a = [1, 2, 3];\n        let mut b = [0, 0, 0];\n        let b_ref = &mut b;\n        a.for_eachi(|i, a| { b_ref[i] = i + a * 2; });\n        assert_eq(b, [2, 5, 8]);\n    }\n\n    #[test]\n    fn concat() {\n        let arr1 = [1, 2, 3, 4];\n        let arr2 = [6, 7, 8, 9, 10, 11];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, [1, 2, 3, 4, 6, 7, 8, 9, 10, 11]);\n    }\n\n    #[test]\n    fn concat_zero_length_with_something() {\n        let arr1 = [];\n        let arr2 = [1];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, [1]);\n    }\n\n    #[test]\n    fn concat_something_with_zero_length() {\n        let arr1 = [1];\n        let arr2 = [];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, [1]);\n    }\n\n    #[test]\n    fn concat_zero_lengths() {\n        let arr1: [Field; 0] = [];\n        let arr2: [Field; 0] = [];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, []);\n    }\n}\n","path":"std/array/mod.nr"},"5":{"source":"use crate::meta::derive_via;\n\n#[derive_via(derive_eq)]\n// docs:start:eq-trait\npub trait Eq {\n    fn eq(self, other: Self) -> bool;\n}\n// docs:end:eq-trait\n\n// docs:start:derive_eq\ncomptime fn derive_eq(s: TypeDefinition) -> Quoted {\n    let signature = quote { fn eq(_self: Self, _other: Self) -> bool };\n    let for_each_field = |name| quote { (_self.$name == _other.$name) };\n    let body = |fields| {\n        if s.fields_as_written().len() == 0 {\n            quote { true }\n        } else {\n            fields\n        }\n    };\n    crate::meta::make_trait_impl(\n        s,\n        quote { $crate::cmp::Eq },\n        signature,\n        for_each_field,\n        quote { & },\n        body,\n    )\n}\n// docs:end:derive_eq\n\nimpl Eq for Field {\n    fn eq(self, other: Field) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for u128 {\n    fn eq(self, other: u128) -> bool {\n        self == other\n    }\n}\nimpl Eq for u64 {\n    fn eq(self, other: u64) -> bool {\n        self == other\n    }\n}\nimpl Eq for u32 {\n    fn eq(self, other: u32) -> bool {\n        self == other\n    }\n}\nimpl Eq for u16 {\n    fn eq(self, other: u16) -> bool {\n        self == other\n    }\n}\nimpl Eq for u8 {\n    fn eq(self, other: u8) -> bool {\n        self == other\n    }\n}\nimpl Eq for u1 {\n    fn eq(self, other: u1) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for i8 {\n    fn eq(self, other: i8) -> bool {\n        self == other\n    }\n}\nimpl Eq for i16 {\n    fn eq(self, other: i16) -> bool {\n        self == other\n    }\n}\nimpl Eq for i32 {\n    fn eq(self, other: i32) -> bool {\n        self == other\n    }\n}\nimpl Eq for i64 {\n    fn eq(self, other: i64) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for () {\n    fn eq(_self: Self, _other: ()) -> bool {\n        true\n    }\n}\nimpl Eq for bool {\n    fn eq(self, other: bool) -> bool {\n        self == other\n    }\n}\n\nimpl<T, let N: u32> Eq for [T; N]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T; N]) -> bool {\n        let mut result = true;\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<T> Eq for [T]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T]) -> bool {\n        let mut result = self.len() == other.len();\n        if result {\n            for i in 0..self.len() {\n                result &= self[i].eq(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<let N: u32> Eq for str<N> {\n    fn eq(self, other: str<N>) -> bool {\n        let self_bytes = self.as_bytes();\n        let other_bytes = other.as_bytes();\n        self_bytes == other_bytes\n    }\n}\n\nimpl<A, B> Eq for (A, B)\nwhere\n    A: Eq,\n    B: Eq,\n{\n    fn eq(self, other: (A, B)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1)\n    }\n}\n\nimpl<A, B, C> Eq for (A, B, C)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n{\n    fn eq(self, other: (A, B, C)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2)\n    }\n}\n\nimpl<A, B, C, D> Eq for (A, B, C, D)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n{\n    fn eq(self, other: (A, B, C, D)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2) & self.3.eq(other.3)\n    }\n}\n\nimpl<A, B, C, D, E> Eq for (A, B, C, D, E)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n    E: Eq,\n{\n    fn eq(self, other: (A, B, C, D, E)) -> bool {\n        self.0.eq(other.0)\n            & self.1.eq(other.1)\n            & self.2.eq(other.2)\n            & self.3.eq(other.3)\n            & self.4.eq(other.4)\n    }\n}\n\nimpl Eq for Ordering {\n    fn eq(self, other: Ordering) -> bool {\n        self.result == other.result\n    }\n}\n\n// Noir doesn't have enums yet so we emulate (Lt | Eq | Gt) with a struct\n// that has 3 public functions for constructing the struct.\npub struct Ordering {\n    result: Field,\n}\n\nimpl Ordering {\n    // Implementation note: 0, 1, and 2 for Lt, Eq, and Gt are built\n    // into the compiler, do not change these without also updating\n    // the compiler itself!\n    pub fn less() -> Ordering {\n        Ordering { result: 0 }\n    }\n\n    pub fn equal() -> Ordering {\n        Ordering { result: 1 }\n    }\n\n    pub fn greater() -> Ordering {\n        Ordering { result: 2 }\n    }\n}\n\n#[derive_via(derive_ord)]\n// docs:start:ord-trait\npub trait Ord {\n    fn cmp(self, other: Self) -> Ordering;\n}\n// docs:end:ord-trait\n\n// docs:start:derive_ord\ncomptime fn derive_ord(s: TypeDefinition) -> Quoted {\n    let name = quote { $crate::cmp::Ord };\n    let signature = quote { fn cmp(_self: Self, _other: Self) -> $crate::cmp::Ordering };\n    let for_each_field = |name| quote {\n        if result == $crate::cmp::Ordering::equal() {\n            result = _self.$name.cmp(_other.$name);\n        }\n    };\n    let body = |fields| quote {\n        let mut result = $crate::cmp::Ordering::equal();\n        $fields\n        result\n    };\n    crate::meta::make_trait_impl(s, name, signature, for_each_field, quote {}, body)\n}\n// docs:end:derive_ord\n\n// Note: Field deliberately does not implement Ord\n\nimpl Ord for u128 {\n    fn cmp(self, other: u128) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\nimpl Ord for u64 {\n    fn cmp(self, other: u64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u32 {\n    fn cmp(self, other: u32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u16 {\n    fn cmp(self, other: u16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u8 {\n    fn cmp(self, other: u8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i8 {\n    fn cmp(self, other: i8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i16 {\n    fn cmp(self, other: i16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i32 {\n    fn cmp(self, other: i32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i64 {\n    fn cmp(self, other: i64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for () {\n    fn cmp(_self: Self, _other: ()) -> Ordering {\n        Ordering::equal()\n    }\n}\n\nimpl Ord for bool {\n    fn cmp(self, other: bool) -> Ordering {\n        if self {\n            if other {\n                Ordering::equal()\n            } else {\n                Ordering::greater()\n            }\n        } else if other {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl<T, let N: u32> Ord for [T; N]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T; N]) -> Ordering {\n        let mut result = Ordering::equal();\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<T> Ord for [T]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T]) -> Ordering {\n        let self_len = self.len();\n        let other_len = other.len();\n        let min_len = if self_len < other_len {\n            self_len\n        } else {\n            other_len\n        };\n\n        let mut result = Ordering::equal();\n        for i in 0..min_len {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n\n        if result != Ordering::equal() {\n            result\n        } else {\n            self_len.cmp(other_len)\n        }\n    }\n}\n\nimpl<A, B> Ord for (A, B)\nwhere\n    A: Ord,\n    B: Ord,\n{\n    fn cmp(self, other: (A, B)) -> Ordering {\n        let result = self.0.cmp(other.0);\n\n        if result != Ordering::equal() {\n            result\n        } else {\n            self.1.cmp(other.1)\n        }\n    }\n}\n\nimpl<A, B, C> Ord for (A, B, C)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n{\n    fn cmp(self, other: (A, B, C)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D> Ord for (A, B, C, D)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n{\n    fn cmp(self, other: (A, B, C, D)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D, E> Ord for (A, B, C, D, E)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n    E: Ord,\n{\n    fn cmp(self, other: (A, B, C, D, E)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        if result == Ordering::equal() {\n            result = self.4.cmp(other.4);\n        }\n\n        result\n    }\n}\n\n// Compares and returns the maximum of two values.\n//\n// Returns the second argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::max(1, 2), 2);\n// assert_eq(cmp::max(2, 2), 2);\n// ```\npub fn max<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v1\n    } else {\n        v2\n    }\n}\n\n// Compares and returns the minimum of two values.\n//\n// Returns the first argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::min(1, 2), 1);\n// assert_eq(cmp::min(2, 2), 2);\n// ```\npub fn min<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v2\n    } else {\n        v1\n    }\n}\n\nmod cmp_tests {\n    use super::{Eq, max, min, Ord};\n\n    #[test]\n    fn sanity_check_min() {\n        assert_eq(min(0_u64, 1), 0);\n        assert_eq(min(0_u64, 0), 0);\n        assert_eq(min(1_u64, 1), 1);\n        assert_eq(min(255_u8, 0), 0);\n    }\n\n    #[test]\n    fn sanity_check_max() {\n        assert_eq(max(0_u64, 1), 1);\n        assert_eq(max(0_u64, 0), 0);\n        assert_eq(max(1_u64, 1), 1);\n        assert_eq(max(255_u8, 0), 255);\n    }\n\n    #[test]\n    fn correctly_handles_unequal_length_slices() {\n        let slice_1 = &[0, 1, 2, 3];\n        let slice_2 = &[0, 1, 2];\n        assert(!slice_1.eq(slice_2));\n    }\n\n    #[test]\n    fn lexicographic_ordering_for_slices() {\n        assert(&[2_u32].cmp(&[1_u32, 1_u32, 1_u32]) == super::Ordering::greater());\n        assert(&[1_u32, 2_u32].cmp(&[1_u32, 2_u32, 3_u32]) == super::Ordering::less());\n    }\n}\n","path":"std/cmp.nr"},"6":{"source":"use crate::{cmp::Eq, convert::From, runtime::is_unconstrained, static_assert};\n\n/// A `BoundedVec<T, MaxLen>` is a growable storage similar to a [`Vec`][crate::collections::vec::Vec]`<T>` except that it\n/// is bounded with a maximum possible length. Unlike `Vec`, `BoundedVec` is not implemented\n/// via slices and thus is not subject to the same restrictions slices are (notably, nested\n/// slices - and thus nested vectors as well - are disallowed).\n///\n/// Since a BoundedVec is backed by a normal array under the hood, growing the BoundedVec by\n/// pushing an additional element is also more efficient - the length only needs to be increased\n/// by one.\n///\n/// For these reasons `BoundedVec<T, N>` should generally be preferred over `Vec<T>` when there\n/// is a reasonable maximum bound that can be placed on the vector.\n///\n/// Example:\n///\n/// ```noir\n/// let mut vector: BoundedVec<Field, 10> = BoundedVec::new();\n/// for i in 0..5 {\n///     vector.push(i);\n/// }\n/// assert(vector.len() == 5);\n/// assert(vector.max_len() == 10);\n/// ```\npub struct BoundedVec<T, let MaxLen: u32> {\n    storage: [T; MaxLen],\n    len: u32,\n}\n\nimpl<T, let MaxLen: u32> BoundedVec<T, MaxLen> {\n    /// Creates a new, empty vector of length zero.\n    ///\n    /// Since this container is backed by an array internally, it still needs an initial value\n    /// to give each element. To resolve this, each element is zeroed internally. This value\n    /// is guaranteed to be inaccessible unless `get_unchecked` is used.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let empty_vector: BoundedVec<Field, 10> = BoundedVec::new();\n    /// assert(empty_vector.len() == 0);\n    /// ```\n    ///\n    /// Note that whenever calling `new` the maximum length of the vector should always be specified\n    /// via a type signature:\n    ///\n    /// ```noir\n    /// fn good() -> BoundedVec<Field, 10> {\n    ///     // Ok! MaxLen is specified with a type annotation\n    ///     let v1: BoundedVec<Field, 3> = BoundedVec::new();\n    ///     let v2 = BoundedVec::new();\n    ///\n    ///     // Ok! MaxLen is known from the type of `good`'s return value\n    ///     v2\n    /// }\n    ///\n    /// fn bad() {\n    ///     // Error: Type annotation needed\n    ///     // The compiler can't infer `MaxLen` from the following code:\n    ///     let mut v3 = BoundedVec::new();\n    ///     v3.push(5);\n    /// }\n    /// ```\n    ///\n    /// This defaulting of `MaxLen` (and numeric generics in general) to zero may change in future noir versions\n    /// but for now make sure to use type annotations when using bounded vectors. Otherwise, you will receive a\n    /// constraint failure at runtime when the vec is pushed to.\n    pub fn new() -> Self {\n        let zeroed = crate::mem::zeroed();\n        BoundedVec { storage: [zeroed; MaxLen], len: 0 }\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this\n    /// will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     let last = v.get(v.len() - 1);\n    ///     assert(first != last);\n    /// }\n    /// ```\n    pub fn get(self, index: u32) -> T {\n        assert(index < self.len, \"Attempted to read past end of BoundedVec\");\n        self.get_unchecked(index)\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero, without\n    /// performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element,\n    /// it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn sum_of_first_three<let N: u32>(v: BoundedVec<u32, N>) -> u32 {\n    ///     // Always ensure the length is larger than the largest\n    ///     // index passed to get_unchecked\n    ///     assert(v.len() > 2);\n    ///     let first = v.get_unchecked(0);\n    ///     let second = v.get_unchecked(1);\n    ///     let third = v.get_unchecked(2);\n    ///     first + second + third\n    /// }\n    /// ```\n    pub fn get_unchecked(self, index: u32) -> T {\n        self.storage[index]\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     assert(first != 42);\n    ///     v.set(0, 42);\n    ///     let new_first = v.get(0);\n    ///     assert(new_first == 42);\n    /// }\n    /// ```\n    pub fn set(&mut self, index: u32, value: T) {\n        assert(index < self.len, \"Attempted to write past end of BoundedVec\");\n        self.set_unchecked(index, value)\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero, without performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element, it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn set_unchecked_example() {\n    ///     let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n    ///     vec.extend_from_array([1, 2]);\n    ///\n    ///     // Here we're safely writing within the valid range of `vec`\n    ///     // `vec` now has the value [42, 2]\n    ///     vec.set_unchecked(0, 42);\n    ///\n    ///     // We can then safely read this value back out of `vec`.\n    ///     // Notice that we use the checked version of `get` which would prevent reading unsafe values.\n    ///     assert_eq(vec.get(0), 42);\n    ///\n    ///     // We've now written past the end of `vec`.\n    ///     // As this index is still within the maximum potential length of `v`,\n    ///     // it won't cause a constraint failure.\n    ///     vec.set_unchecked(2, 42);\n    ///     println(vec);\n    ///\n    ///     // This will write past the end of the maximum potential length of `vec`,\n    ///     // it will then trigger a constraint failure.\n    ///     vec.set_unchecked(5, 42);\n    ///     println(vec);\n    /// }\n    /// ```\n    pub fn set_unchecked(&mut self, index: u32, value: T) {\n        self.storage[index] = value;\n    }\n\n    /// Pushes an element to the end of the vector. This increases the length\n    /// of the vector by one.\n    ///\n    /// Panics if the new length of the vector will be greater than the max length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    ///\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// // Panics with failed assertion \"push out of bounds\"\n    /// v.push(3);\n    /// ```\n    pub fn push(&mut self, elem: T) {\n        assert(self.len < MaxLen, \"push out of bounds\");\n\n        self.storage[self.len] = elem;\n        self.len += 1;\n    }\n\n    /// Returns the current length of this vector\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 4> = BoundedVec::new();\n    /// assert(v.len() == 0);\n    ///\n    /// v.push(100);\n    /// assert(v.len() == 1);\n    ///\n    /// v.push(200);\n    /// v.push(300);\n    /// v.push(400);\n    /// assert(v.len() == 4);\n    ///\n    /// let _ = v.pop();\n    /// let _ = v.pop();\n    /// assert(v.len() == 2);\n    /// ```\n    pub fn len(self) -> u32 {\n        self.len\n    }\n\n    /// Returns the maximum length of this vector. This is always\n    /// equal to the `MaxLen` parameter this vector was initialized with.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.max_len() == 5);\n    /// v.push(10);\n    /// assert(v.max_len() == 5);\n    /// ```\n    pub fn max_len(_self: BoundedVec<T, MaxLen>) -> u32 {\n        MaxLen\n    }\n\n    /// Returns the internal array within this vector.\n    ///\n    /// Since arrays in Noir are immutable, mutating the returned storage array will not mutate\n    /// the storage held internally by this vector.\n    ///\n    /// Note that uninitialized elements may be zeroed out!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.storage() == [0, 0, 0, 0, 0]);\n    ///\n    /// v.push(57);\n    /// assert(v.storage() == [57, 0, 0, 0, 0]);\n    /// ```\n    pub fn storage(self) -> [T; MaxLen] {\n        self.storage\n    }\n\n    /// Pushes each element from the given array to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_array([2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_array<let Len: u32>(&mut self, array: [T; Len]) {\n        let new_len = self.len + array.len();\n        assert(new_len <= MaxLen, \"extend_from_array out of bounds\");\n        for i in 0..array.len() {\n            self.storage[self.len + i] = array[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the given slice to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_slice(&[2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_slice(&mut self, slice: [T]) {\n        let new_len = self.len + slice.len();\n        assert(new_len <= MaxLen, \"extend_from_slice out of bounds\");\n        for i in 0..slice.len() {\n            self.storage[self.len + i] = slice[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the other vector to this vector. The length of\n    /// the other vector is left unchanged.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// ```noir\n    /// let mut v1: BoundedVec<Field, 5> = BoundedVec::new();\n    /// let mut v2: BoundedVec<Field, 7> = BoundedVec::new();\n    ///\n    /// v2.extend_from_array([1, 2, 3]);\n    /// v1.extend_from_bounded_vec(v2);\n    ///\n    /// assert(v1.storage() == [1, 2, 3, 0, 0]);\n    /// assert(v2.storage() == [1, 2, 3, 0, 0, 0, 0]);\n    /// ```\n    pub fn extend_from_bounded_vec<let Len: u32>(&mut self, vec: BoundedVec<T, Len>) {\n        let append_len = vec.len();\n        let new_len = self.len + append_len;\n        assert(new_len <= MaxLen, \"extend_from_bounded_vec out of bounds\");\n\n        if is_unconstrained() {\n            for i in 0..append_len {\n                self.storage[self.len + i] = vec.get_unchecked(i);\n            }\n        } else {\n            let mut exceeded_len = false;\n            for i in 0..Len {\n                exceeded_len |= i == append_len;\n                if !exceeded_len {\n                    self.storage[self.len + i] = vec.get_unchecked(i);\n                }\n            }\n        }\n        self.len = new_len;\n    }\n\n    /// Creates a new vector, populating it with values derived from an array input.\n    /// The maximum length of the vector is determined based on the type signature.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array([1, 2, 3])\n    /// ```\n    pub fn from_array<let Len: u32>(array: [T; Len]) -> Self {\n        static_assert(Len <= MaxLen, \"from array out of bounds\");\n        let mut vec: BoundedVec<T, MaxLen> = BoundedVec::new();\n        vec.extend_from_array(array);\n        vec\n    }\n\n    /// Pops the element at the end of the vector. This will decrease the length\n    /// of the vector by one.\n    ///\n    /// Panics if the vector is empty.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// let two = v.pop();\n    /// let one = v.pop();\n    ///\n    /// assert(two == 2);\n    /// assert(one == 1);\n    ///\n    /// // error: cannot pop from an empty vector\n    /// let _ = v.pop();\n    /// ```\n    pub fn pop(&mut self) -> T {\n        assert(self.len > 0, \"cannot pop from an empty vector\");\n        self.len -= 1;\n\n        let elem = self.storage[self.len];\n        self.storage[self.len] = crate::mem::zeroed();\n        elem\n    }\n\n    /// Returns true if the given predicate returns true for any element\n    /// in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<u32, 3> = BoundedVec::new();\n    /// v.extend_from_array([2, 4, 6]);\n    ///\n    /// let all_even = !v.any(|elem: u32| elem % 2 != 0);\n    /// assert(all_even);\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        if is_unconstrained() {\n            for i in 0..self.len {\n                ret |= predicate(self.storage[i]);\n            }\n        } else {\n            let mut exceeded_len = false;\n            for i in 0..MaxLen {\n                exceeded_len |= i == self.len;\n                if !exceeded_len {\n                    ret |= predicate(self.storage[i]);\n                }\n            }\n        }\n        ret\n    }\n\n    /// Creates a new vector of equal size by calling a closure on each element in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let result = vec.map(|value| value * 2);\n    ///\n    /// let expected = BoundedVec::from_array([2, 4, 6, 8]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                ret.storage[i] = f(self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    ret.storage[i] = f(self.get_unchecked(i));\n                }\n            }\n        }\n\n        ret\n    }\n\n    /// Creates a new vector of equal size by calling a closure on each element\n    /// in this vector, along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let result = vec.mapi(|i, value| i + value * 2);\n    ///\n    /// let expected = BoundedVec::from_array([2, 5, 8, 11]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn mapi<U, Env>(self, f: fn[Env](u32, T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                ret.storage[i] = f(i, self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    ret.storage[i] = f(i, self.get_unchecked(i));\n                }\n            }\n        }\n\n        ret\n    }\n\n    /// Calls a closure on each element in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let mut result = BoundedVec::<u32, 4>::new();\n    /// vec.for_each(|value| result.push(value * 2));\n    ///\n    /// let expected = BoundedVec::from_array([2, 4, 6, 8]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn for_each<Env>(self, f: fn[Env](T) -> ()) {\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                f(self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    f(self.get_unchecked(i));\n                }\n            }\n        }\n    }\n\n    /// Calls a closure on each element in this vector, along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let mut result = BoundedVec::<u32, 4>::new();\n    /// vec.for_eachi(|i, value| result.push(i + value * 2));\n    ///\n    /// let expected = BoundedVec::from_array([2, 5, 8, 11]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn for_eachi<Env>(self, f: fn[Env](u32, T) -> ()) {\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                f(i, self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    f(i, self.get_unchecked(i));\n                }\n            }\n        }\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function will zero out any elements at or past index `len` of `array`.\n    /// This incurs an extra runtime cost of O(MaxLen). If you are sure your array is\n    /// zeroed after that index, you can use [`from_parts_unchecked`][Self::from_parts_unchecked] to remove the extra loop.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    /// ```\n    pub fn from_parts(mut array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        let zeroed = crate::mem::zeroed();\n\n        if is_unconstrained() {\n            for i in len..MaxLen {\n                array[i] = zeroed;\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i >= len {\n                    array[i] = zeroed;\n                }\n            }\n        }\n\n        BoundedVec { storage: array, len }\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function is unsafe because it expects all elements past the `len` index\n    /// of `array` to be zeroed, but does not check for this internally. Use `from_parts`\n    /// for a safe version of this function which does zero out any indices past the\n    /// given length. Invalidating this assumption can notably cause `BoundedVec::eq`\n    /// to give incorrect results since it will check even elements past `len`.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    ///\n    /// // invalid use!\n    /// let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n    /// let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n    ///\n    /// // both vecs have length 3 so we'd expect them to be equal, but this\n    /// // fails because elements past the length are still checked in eq\n    /// assert_eq(vec1, vec2); // fails\n    /// ```\n    pub fn from_parts_unchecked(array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        BoundedVec { storage: array, len }\n    }\n}\n\nimpl<T, let MaxLen: u32> Eq for BoundedVec<T, MaxLen>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: BoundedVec<T, MaxLen>) -> bool {\n        // TODO: https://github.com/noir-lang/noir/issues/4837\n        //\n        // We make the assumption that the user has used the proper interface for working with `BoundedVec`s\n        // rather than directly manipulating the internal fields as this can result in an inconsistent internal state.\n        if self.len == other.len {\n            self.storage == other.storage\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T, let MaxLen: u32, let Len: u32> From<[T; Len]> for BoundedVec<T, MaxLen> {\n    fn from(array: [T; Len]) -> BoundedVec<T, MaxLen> {\n        BoundedVec::from_array(array)\n    }\n}\n\nmod bounded_vec_tests {\n\n    mod get {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test(should_fail_with = \"Attempted to read past end of BoundedVec\")]\n        fn panics_when_reading_elements_past_end_of_vec() {\n            let vec: BoundedVec<Field, 5> = BoundedVec::new();\n\n            let _ = vec.get(0);\n        }\n\n        #[test(should_fail_with = \"Attempted to read past end of BoundedVec\")]\n        fn panics_when_reading_beyond_length() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3]);\n            let _ = vec.get(3);\n        }\n\n        #[test]\n        fn get_works_within_bounds() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3, 4, 5]);\n            assert_eq(vec.get(0), 1);\n            assert_eq(vec.get(2), 3);\n            assert_eq(vec.get(4), 5);\n        }\n\n        #[test]\n        fn get_unchecked_works() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3]);\n            assert_eq(vec.get_unchecked(0), 1);\n            assert_eq(vec.get_unchecked(2), 3);\n        }\n\n        #[test]\n        fn get_unchecked_works_past_len() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3]);\n            assert_eq(vec.get_unchecked(4), 0);\n        }\n    }\n\n    mod set {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn set_updates_values_properly() {\n            let mut vec = BoundedVec::from_array([0, 0, 0, 0, 0]);\n\n            vec.set(0, 42);\n            assert_eq(vec.storage, [42, 0, 0, 0, 0]);\n\n            vec.set(1, 43);\n            assert_eq(vec.storage, [42, 43, 0, 0, 0]);\n\n            vec.set(2, 44);\n            assert_eq(vec.storage, [42, 43, 44, 0, 0]);\n\n            vec.set(1, 10);\n            assert_eq(vec.storage, [42, 10, 44, 0, 0]);\n\n            vec.set(0, 0);\n            assert_eq(vec.storage, [0, 10, 44, 0, 0]);\n        }\n\n        #[test(should_fail_with = \"Attempted to write past end of BoundedVec\")]\n        fn panics_when_writing_elements_past_end_of_vec() {\n            let mut vec: BoundedVec<Field, 5> = BoundedVec::new();\n            vec.set(0, 42);\n        }\n\n        #[test(should_fail_with = \"Attempted to write past end of BoundedVec\")]\n        fn panics_when_setting_beyond_length() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3]);\n            vec.set(3, 4);\n        }\n\n        #[test]\n        fn set_unchecked_operations() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n            vec.push(1);\n            vec.push(2);\n\n            vec.set_unchecked(0, 10);\n            assert_eq(vec.get(0), 10);\n        }\n\n        #[test(should_fail_with = \"Attempted to read past end of BoundedVec\")]\n        fn set_unchecked_operations_past_len() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n            vec.push(1);\n            vec.push(2);\n\n            vec.set_unchecked(3, 40);\n            assert_eq(vec.get(3), 40);\n        }\n\n        #[test]\n        fn set_preserves_other_elements() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3, 4, 5]);\n\n            vec.set(2, 30);\n            assert_eq(vec.get(0), 1);\n            assert_eq(vec.get(1), 2);\n            assert_eq(vec.get(2), 30);\n            assert_eq(vec.get(3), 4);\n            assert_eq(vec.get(4), 5);\n        }\n    }\n\n    mod any {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn returns_false_if_predicate_not_satisfied() {\n            let vec: BoundedVec<bool, 4> = BoundedVec::from_array([false, false, false, false]);\n            let result = vec.any(|value| value);\n\n            assert(!result);\n        }\n\n        #[test]\n        fn returns_true_if_predicate_satisfied() {\n            let vec: BoundedVec<bool, 4> = BoundedVec::from_array([false, false, true, true]);\n            let result = vec.any(|value| value);\n\n            assert(result);\n        }\n\n        #[test]\n        fn returns_false_on_empty_boundedvec() {\n            let vec: BoundedVec<bool, 0> = BoundedVec::new();\n            let result = vec.any(|value| value);\n\n            assert(!result);\n        }\n\n        #[test]\n        fn any_with_complex_predicates() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3, 4, 5]);\n\n            assert(vec.any(|x| x > 3));\n            assert(!vec.any(|x| x > 10));\n            assert(vec.any(|x| x % 2 == 0)); // has a even number\n            assert(vec.any(|x| x == 3)); // has a specific value\n        }\n\n        #[test]\n        fn any_with_partial_vector() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n            vec.push(1);\n            vec.push(2);\n\n            assert(vec.any(|x| x == 1));\n            assert(vec.any(|x| x == 2));\n            assert(!vec.any(|x| x == 3));\n        }\n    }\n\n    mod map {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-map-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| value * 2);\n            // docs:end:bounded-vec-map-example\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| (value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.map(|value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n\n        #[test]\n        fn map_with_conditional_logic() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n\n            let result = vec.map(|x| if x % 2 == 0 { x * 2 } else { x });\n            let expected = BoundedVec::from_array([1, 4, 3, 8]);\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn map_preserves_length() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|x| x * 2);\n\n            assert_eq(result.len(), vec.len());\n            assert_eq(result.max_len(), vec.max_len());\n        }\n\n        #[test]\n        fn map_on_empty_vector() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::new();\n            let result = vec.map(|x| x * 2);\n            assert_eq(result, vec);\n            assert_eq(result.len(), 0);\n            assert_eq(result.max_len(), 5);\n        }\n    }\n\n    mod mapi {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-mapi-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.mapi(|i, value| i + value * 2);\n            // docs:end:bounded-vec-mapi-example\n            let expected = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.mapi(|i, value| (i + value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.mapi(|_, value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n\n        #[test]\n        fn mapi_with_index_branching_logic() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n\n            let result = vec.mapi(|i, x| if i % 2 == 0 { x * 2 } else { x });\n            let expected = BoundedVec::from_array([2, 2, 6, 4]);\n            assert_eq(result, expected);\n        }\n    }\n\n    mod for_each {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        // map in terms of for_each\n        fn for_each_map<T, U, Env, let MaxLen: u32>(\n            input: BoundedVec<T, MaxLen>,\n            f: fn[Env](T) -> U,\n        ) -> BoundedVec<U, MaxLen> {\n            let mut output = BoundedVec::<U, MaxLen>::new();\n            let output_ref = &mut output;\n            input.for_each(|x| output_ref.push(f(x)));\n            output\n        }\n\n        #[test]\n        fn smoke_test() {\n            let mut acc = 0;\n            let acc_ref = &mut acc;\n            // docs:start:bounded-vec-for-each-example\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            vec.for_each(|value| { *acc_ref += value; });\n            // docs:end:bounded-vec-for-each-example\n            assert_eq(acc, 6);\n        }\n\n        #[test]\n        fn applies_function_correctly() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_each_map(vec, |value| value * 2);\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_each_map(vec, |value| (value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = for_each_map(vec, |value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n\n        #[test]\n        fn for_each_on_empty_vector() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::new();\n            let mut count = 0;\n            let count_ref = &mut count;\n            vec.for_each(|_| { *count_ref += 1; });\n            assert_eq(count, 0);\n        }\n\n        #[test]\n        fn for_each_with_side_effects() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            let mut seen = BoundedVec::<u32, 3>::new();\n            let seen_ref = &mut seen;\n            vec.for_each(|x| seen_ref.push(x));\n            assert_eq(seen, vec);\n        }\n    }\n\n    mod for_eachi {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        // mapi in terms of for_eachi\n        fn for_eachi_mapi<T, U, Env, let MaxLen: u32>(\n            input: BoundedVec<T, MaxLen>,\n            f: fn[Env](u32, T) -> U,\n        ) -> BoundedVec<U, MaxLen> {\n            let mut output = BoundedVec::<U, MaxLen>::new();\n            let output_ref = &mut output;\n            input.for_eachi(|i, x| output_ref.push(f(i, x)));\n            output\n        }\n\n        #[test]\n        fn smoke_test() {\n            let mut acc = 0;\n            let acc_ref = &mut acc;\n            // docs:start:bounded-vec-for-eachi-example\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            vec.for_eachi(|i, value| { *acc_ref += i * value; });\n            // docs:end:bounded-vec-for-eachi-example\n\n            // 0 * 1 + 1 * 2 + 2 * 3\n            assert_eq(acc, 8);\n        }\n\n        #[test]\n        fn applies_function_correctly() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_eachi_mapi(vec, |i, value| i + value * 2);\n            let expected = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_eachi_mapi(vec, |i, value| (i + value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = for_eachi_mapi(vec, |_, value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n\n        #[test]\n        fn for_eachi_on_empty_vector() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::new();\n            let mut count = 0;\n            let count_ref = &mut count;\n            vec.for_eachi(|_, _| { *count_ref += 1; });\n            assert_eq(count, 0);\n        }\n\n        #[test]\n        fn for_eachi_with_index_tracking() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([10, 20, 30]);\n            let mut indices = BoundedVec::<u32, 3>::new();\n            let indices_ref = &mut indices;\n            vec.for_eachi(|i, _| indices_ref.push(i));\n\n            let expected = BoundedVec::from_array([0, 1, 2]);\n            assert_eq(indices, expected);\n        }\n\n    }\n\n    mod from_array {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty() {\n            let empty_array: [Field; 0] = [];\n            let bounded_vec = BoundedVec::from_array([]);\n\n            assert_eq(bounded_vec.max_len(), 0);\n            assert_eq(bounded_vec.len(), 0);\n            assert_eq(bounded_vec.storage(), empty_array);\n        }\n\n        #[test]\n        fn equal_len() {\n            let array = [1, 2, 3];\n            let bounded_vec = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 3);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.storage(), array);\n        }\n\n        #[test]\n        fn max_len_greater_then_array_len() {\n            let array = [1, 2, 3];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n            assert_eq(bounded_vec.get(2), 3);\n        }\n\n        #[test(should_fail_with = \"from array out of bounds\")]\n        fn max_len_lower_then_array_len() {\n            let _: BoundedVec<Field, 2> = BoundedVec::from_array([0; 3]);\n        }\n\n        #[test]\n        fn from_array_preserves_order() {\n            let array = [5, 3, 1, 4, 2];\n            let vec: BoundedVec<u32, 5> = BoundedVec::from_array(array);\n            for i in 0..array.len() {\n                assert_eq(vec.get(i), array[i]);\n            }\n        }\n\n        #[test]\n        fn from_array_with_different_types() {\n            let bool_array = [true, false, true];\n            let bool_vec: BoundedVec<bool, 3> = BoundedVec::from_array(bool_array);\n            assert_eq(bool_vec.len(), 3);\n            assert_eq(bool_vec.get(0), true);\n            assert_eq(bool_vec.get(1), false);\n        }\n    }\n\n    mod trait_from {\n        use crate::collections::bounded_vec::BoundedVec;\n        use crate::convert::From;\n\n        #[test]\n        fn simple() {\n            let array = [1, 2];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 2);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n        }\n    }\n\n    mod trait_eq {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty_equality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n\n            assert_eq(bounded_vec1, bounded_vec2);\n        }\n\n        #[test]\n        fn inequality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n            bounded_vec1.push(1);\n            bounded_vec2.push(2);\n\n            assert(bounded_vec1 != bounded_vec2);\n        }\n    }\n\n    mod from_parts {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn from_parts() {\n            // docs:start:from-parts\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // Any elements past the given length are zeroed out, so these\n            // two BoundedVecs will be completely equal\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 2], 3);\n            assert_eq(vec1, vec2);\n            // docs:end:from-parts\n        }\n\n        #[test]\n        fn from_parts_unchecked() {\n            // docs:start:from-parts-unchecked\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // invalid use!\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n\n            // both vecs have length 3 so we'd expect them to be equal, but this\n            // fails because elements past the length are still checked in eq\n            assert(vec1 != vec2);\n            // docs:end:from-parts-unchecked\n        }\n    }\n\n    mod push_pop {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn push_and_pop_operations() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n\n            assert_eq(vec.len(), 0);\n\n            vec.push(1);\n            assert_eq(vec.len(), 1);\n            assert_eq(vec.get(0), 1);\n\n            vec.push(2);\n            assert_eq(vec.len(), 2);\n            assert_eq(vec.get(1), 2);\n\n            let popped = vec.pop();\n            assert_eq(popped, 2);\n            assert_eq(vec.len(), 1);\n\n            let popped2 = vec.pop();\n            assert_eq(popped2, 1);\n            assert_eq(vec.len(), 0);\n        }\n\n        #[test(should_fail_with = \"push out of bounds\")]\n        fn push_to_full_vector() {\n            let mut vec: BoundedVec<u32, 2> = BoundedVec::new();\n            vec.push(1);\n            vec.push(2);\n            vec.push(3); // should panic\n        }\n\n        #[test(should_fail_with = \"cannot pop from an empty vector\")]\n        fn pop_from_empty_vector() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n            let _ = vec.pop(); // should panic\n        }\n\n        #[test]\n        fn push_pop_cycle() {\n            let mut vec: BoundedVec<u32, 3> = BoundedVec::new();\n\n            // push to full\n            vec.push(1);\n            vec.push(2);\n            vec.push(3);\n            assert_eq(vec.len(), 3);\n\n            // pop all\n            assert_eq(vec.pop(), 3);\n            assert_eq(vec.pop(), 2);\n            assert_eq(vec.pop(), 1);\n            assert_eq(vec.len(), 0);\n\n            // push again\n            vec.push(4);\n            assert_eq(vec.len(), 1);\n            assert_eq(vec.get(0), 4);\n        }\n    }\n\n    mod extend {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn extend_from_array() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n            vec.push(1);\n            vec.extend_from_array([2, 3]);\n\n            assert_eq(vec.len(), 3);\n            assert_eq(vec.get(0), 1);\n            assert_eq(vec.get(1), 2);\n            assert_eq(vec.get(2), 3);\n        }\n\n        #[test]\n        fn extend_from_slice() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n            vec.push(1);\n            vec.extend_from_slice(&[2, 3]);\n\n            assert_eq(vec.len(), 3);\n            assert_eq(vec.get(0), 1);\n            assert_eq(vec.get(1), 2);\n            assert_eq(vec.get(2), 3);\n        }\n\n        #[test]\n        fn extend_from_bounded_vec() {\n            let mut vec1: BoundedVec<u32, 5> = BoundedVec::new();\n            let mut vec2: BoundedVec<u32, 3> = BoundedVec::new();\n\n            vec1.push(1);\n            vec2.push(2);\n            vec2.push(3);\n\n            vec1.extend_from_bounded_vec(vec2);\n\n            assert_eq(vec1.len(), 3);\n            assert_eq(vec1.get(0), 1);\n            assert_eq(vec1.get(1), 2);\n            assert_eq(vec1.get(2), 3);\n        }\n\n        #[test(should_fail_with = \"extend_from_array out of bounds\")]\n        fn extend_array_beyond_max_len() {\n            let mut vec: BoundedVec<u32, 3> = BoundedVec::new();\n            vec.push(1);\n            vec.extend_from_array([2, 3, 4]); // should panic\n        }\n\n        #[test(should_fail_with = \"extend_from_slice out of bounds\")]\n        fn extend_slice_beyond_max_len() {\n            let mut vec: BoundedVec<u32, 3> = BoundedVec::new();\n            vec.push(1);\n            vec.extend_from_slice(&[2, 3, 4]); // S]should panic\n        }\n\n        #[test(should_fail_with = \"extend_from_bounded_vec out of bounds\")]\n        fn extend_bounded_vec_beyond_max_len() {\n            let mut vec: BoundedVec<u32, 3> = BoundedVec::new();\n            let other: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3, 4, 5]);\n            vec.extend_from_bounded_vec(other); // should panic\n        }\n\n        #[test]\n        fn extend_with_empty_collections() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n            let original_len = vec.len();\n\n            vec.extend_from_array([]);\n            assert_eq(vec.len(), original_len);\n\n            vec.extend_from_slice(&[]);\n            assert_eq(vec.len(), original_len);\n\n            let empty: BoundedVec<u32, 3> = BoundedVec::new();\n            vec.extend_from_bounded_vec(empty);\n            assert_eq(vec.len(), original_len);\n        }\n    }\n\n    mod storage {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn storage_consistency() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n\n            // test initial storage state\n            assert_eq(vec.storage(), [0, 0, 0, 0, 0]);\n\n            vec.push(1);\n            vec.push(2);\n\n            // test storage after modifications\n            assert_eq(vec.storage(), [1, 2, 0, 0, 0]);\n\n            // storage doesn't change length\n            assert_eq(vec.len(), 2);\n            assert_eq(vec.max_len(), 5);\n        }\n\n        #[test]\n        fn storage_after_pop() {\n            let mut vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n\n            let _ = vec.pop();\n            // after pop, the last element should be zeroed\n            assert_eq(vec.storage(), [1, 2, 0]);\n            assert_eq(vec.len(), 2);\n        }\n\n        #[test]\n        fn vector_immutable() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            let storage = vec.storage();\n\n            assert_eq(storage, [1, 2, 3]);\n\n            // Verify that the original vector is unchanged\n            assert_eq(vec.len(), 3);\n            assert_eq(vec.get(0), 1);\n            assert_eq(vec.get(1), 2);\n            assert_eq(vec.get(2), 3);\n        }\n    }\n}\n","path":"std/collections/bounded_vec.nr"},"17":{"source":"use crate::field::field_less_than;\nuse crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\npub(crate) global PLO: Field = 53438638232309528389504892708671455233;\npub(crate) global PHI: Field = 64323764613183177041862057485226039389;\n\npub(crate) global TWO_POW_128: Field = 0x100000000000000000000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(x: Field) -> (Field, Field) {\n    // Here's we're taking advantage of truncating 128 bit limbs from the input field\n    // and then subtracting them from the input such the field division is equivalent to integer division.\n    let low = (x as u128) as Field;\n    let high = (x - low) / TWO_POW_128;\n\n    (low, high)\n}\n\npub(crate) unconstrained fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nunconstrained fn lte_hint(x: Field, y: Field) -> bool {\n    if x == y {\n        true\n    } else {\n        field_less_than(x, y)\n    }\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    // Safety: borrow is enforced to be boolean due to its type.\n    // if borrow is 0, it asserts that (alo > blo && ahi >= bhi)\n    // if borrow is 1, it asserts that (alo <= blo && ahi > bhi)\n    unsafe {\n        let borrow = lte_hint(alo, blo);\n\n        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n        let rhi = ahi - bhi - (borrow as Field);\n\n        rlo.assert_max_bit_size::<128>();\n        rhi.assert_max_bit_size::<128>();\n    }\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        // Safety: decomposition is properly checked below\n        unsafe {\n            // Take hints of the decomposition\n            let (xlo, xhi) = decompose_hint(x);\n\n            // Range check the limbs\n            xlo.assert_max_bit_size::<128>();\n            xhi.assert_max_bit_size::<128>();\n\n            // Check that the decomposition is correct\n            assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n            // Assert that the decomposition of P is greater than the decomposition of x\n            assert_gt_limbs((PLO, PHI), (xlo, xhi));\n            (xlo, xhi)\n        }\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(\n            // Safety: already unconstrained\n            unsafe { field_less_than(b, a) },\n        );\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unsafe in unconstrained\n        unsafe {\n            field_less_than(b, a)\n        }\n    } else if a == b {\n        false\n    } else {\n        // Safety: Take a hint of the comparison and verify it\n        unsafe {\n            if field_less_than(a, b) {\n                assert_gt(b, a);\n                false\n            } else {\n                assert_gt(a, b);\n                true\n            }\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{assert_gt, decompose, gt, lt, lte_hint, PHI, PLO, TWO_POW_128};\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_lte_hint() {\n        assert(lte_hint(0, 1));\n        assert(lte_hint(0, 0x100));\n        assert(lte_hint(0x100, TWO_POW_128 - 1));\n        assert(!lte_hint(0 - 1, 0));\n\n        assert(lte_hint(0, 0));\n        assert(lte_hint(0x100, 0x100));\n        assert(lte_hint(0 - 1, 0 - 1));\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n\n    #[test]\n    fn check_decompose_edge_cases() {\n        assert_eq(decompose(0), (0, 0));\n        assert_eq(decompose(TWO_POW_128 - 1), (TWO_POW_128 - 1, 0));\n        assert_eq(decompose(TWO_POW_128 + 1), (1, 1));\n        assert_eq(decompose(TWO_POW_128 * 2), (0, 2));\n        assert_eq(decompose(TWO_POW_128 * 2 + 0x1234567890), (0x1234567890, 2));\n    }\n\n    #[test]\n    fn check_decompose_large_values() {\n        let large_field = 0xffffffffffffffff;\n        let (lo, hi) = decompose(large_field);\n        assert_eq(large_field, lo + TWO_POW_128 * hi);\n\n        let large_value = large_field - TWO_POW_128;\n        let (lo2, hi2) = decompose(large_value);\n        assert_eq(large_value, lo2 + TWO_POW_128 * hi2);\n    }\n\n    #[test]\n    fn check_lt_comprehensive() {\n        assert(lt(0, 1));\n        assert(!lt(1, 0));\n        assert(!lt(0, 0));\n        assert(!lt(42, 42));\n\n        assert(lt(TWO_POW_128 - 1, TWO_POW_128));\n        assert(!lt(TWO_POW_128, TWO_POW_128 - 1));\n    }\n}\n","path":"std/field/bn254.nr"},"18":{"source":"pub mod bn254;\nuse crate::{runtime::is_unconstrained, static_assert};\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        static_assert(\n            BIT_SIZE < modulus_num_bits() as u32,\n            \"BIT_SIZE must be less than modulus_num_bits\",\n        );\n        __assert_max_bit_size(self, BIT_SIZE);\n    }\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_le_bits\n        let bits = __to_le_bits(self);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[N - 1 - i] != p[N - 1 - i]) {\n                        assert(p[N - 1 - i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_be_bits\n        let bits = __to_be_bits(self);\n\n        if !is_unconstrained() {\n            // Ensure that the decomposition does not overflow the modulus\n            let p = modulus_be_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[i] != p[i]) {\n                        assert(p[i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        __to_le_radix(self, radix)\n    }\n\n    fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        __to_be_radix(self, radix)\n    }\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(apply_range_constraint)]\nfn __assert_max_bit_size(value: Field, bit_size: u32) {}\n\n// `_radix` must be less than 256\n#[builtin(to_le_radix)]\nfn __to_le_radix<let N: u32>(value: Field, radix: u32) -> [u8; N] {}\n\n// `_radix` must be less than 256\n#[builtin(to_be_radix)]\nfn __to_be_radix<let N: u32>(value: Field, radix: u32) -> [u8; N] {}\n\n/// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n/// This slice will be zero padded should not all bits be necessary to represent `self`.\n///\n/// # Failures\n/// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n/// be able to represent the original `Field`.\n///\n/// # Safety\n/// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n/// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n/// wrap around due to overflow when verifying the decomposition.\n#[builtin(to_le_bits)]\nfn __to_le_bits<let N: u32>(value: Field) -> [u1; N] {}\n\n/// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n/// This array will be zero padded should not all bits be necessary to represent `self`.\n///\n/// # Failures\n/// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n/// be able to represent the original `Field`.\n///\n/// # Safety\n/// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n/// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n/// wrap around due to overflow when verifying the decomposition.\n#[builtin(to_be_bits)]\nfn __to_be_bits<let N: u32>(value: Field) -> [u1; N] {}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unconstrained context\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use crate::{panic::panic, runtime, static_assert};\n    use super::{\n        field_less_than, modulus_be_bits, modulus_be_bytes, modulus_le_bits, modulus_le_bytes,\n    };\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        // 259, in base 256, big endian, is [1, 3].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 1, 3]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        // 259, in base 256, little endian, is [3, 1].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [3, 1, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    // Updated test to account for Brillig restriction that radix must be greater than 2\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_brillig_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 1;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be a power of 2\")]\n    fn test_to_le_radix_3() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(3);\n        } else {\n            panic(f\"radix must be a power of 2\");\n        }\n    }\n\n    #[test]\n    fn test_to_le_radix_brillig_3() {\n        // this test should only fail in constrained mode\n        if runtime::is_unconstrained() {\n            let field = 1;\n            let out: [u8; 8] = field.to_le_radix(3);\n            let mut expected = [0; 8];\n            expected[0] = 1;\n            assert(out == expected, \"unexpected result\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be less than or equal to 256\")]\n    fn test_to_le_radix_512() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(512);\n        } else {\n            panic(f\"radix must be less than or equal to 256\")\n        }\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 16 limbs\")]\n    unconstrained fn not_enough_limbs_brillig() {\n        let _: [u8; 16] = 0x100000000000000000000000000000000.to_le_bytes();\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 16 limbs\")]\n    fn not_enough_limbs() {\n        let _: [u8; 16] = 0x100000000000000000000000000000000.to_le_bytes();\n    }\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n\n    #[test]\n    unconstrained fn test_large_field_values_unconstrained() {\n        let large_field = 0xffffffffffffffff;\n\n        let bits: [u1; 64] = large_field.to_le_bits();\n        assert_eq(bits[0], 1);\n\n        let bytes: [u8; 8] = large_field.to_le_bytes();\n        assert_eq(Field::from_le_bytes::<8>(bytes), large_field);\n\n        let radix_bytes: [u8; 8] = large_field.to_le_radix(256);\n        assert_eq(Field::from_le_bytes::<8>(radix_bytes), large_field);\n    }\n\n    #[test]\n    fn test_large_field_values() {\n        let large_val = 0xffffffffffffffff;\n\n        let bits: [u1; 64] = large_val.to_le_bits();\n        assert_eq(bits[0], 1);\n\n        let bytes: [u8; 8] = large_val.to_le_bytes();\n        assert_eq(Field::from_le_bytes::<8>(bytes), large_val);\n\n        let radix_bytes: [u8; 8] = large_val.to_le_radix(256);\n        assert_eq(Field::from_le_bytes::<8>(radix_bytes), large_val);\n    }\n\n    #[test]\n    fn test_decomposition_edge_cases() {\n        let zero_bits: [u1; 8] = 0.to_le_bits();\n        assert_eq(zero_bits, [0; 8]);\n\n        let zero_bytes: [u8; 8] = 0.to_le_bytes();\n        assert_eq(zero_bytes, [0; 8]);\n\n        let one_bits: [u1; 8] = 1.to_le_bits();\n        let expected: [u1; 8] = [1, 0, 0, 0, 0, 0, 0, 0];\n        assert_eq(one_bits, expected);\n\n        let pow2_bits: [u1; 8] = 4.to_le_bits();\n        let expected: [u1; 8] = [0, 0, 1, 0, 0, 0, 0, 0];\n        assert_eq(pow2_bits, expected);\n    }\n\n    #[test]\n    fn test_pow_32() {\n        assert_eq(2.pow_32(3), 8);\n        assert_eq(3.pow_32(2), 9);\n        assert_eq(5.pow_32(0), 1);\n        assert_eq(7.pow_32(1), 7);\n\n        assert_eq(2.pow_32(10), 1024);\n\n        assert_eq(0.pow_32(5), 0);\n        assert_eq(0.pow_32(0), 1);\n\n        assert_eq(1.pow_32(100), 1);\n    }\n\n    #[test]\n    fn test_sgn0() {\n        assert_eq(0.sgn0(), 0);\n        assert_eq(2.sgn0(), 0);\n        assert_eq(4.sgn0(), 0);\n        assert_eq(100.sgn0(), 0);\n\n        assert_eq(1.sgn0(), 1);\n        assert_eq(3.sgn0(), 1);\n        assert_eq(5.sgn0(), 1);\n        assert_eq(101.sgn0(), 1);\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 8 limbs\")]\n    fn test_bit_decomposition_overflow() {\n        // 8 bits can't represent large field values\n        let large_val = 0x1000000000000000;\n        let _: [u1; 8] = large_val.to_le_bits();\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 4 limbs\")]\n    fn test_byte_decomposition_overflow() {\n        // 4 bytes can't represent large field values\n        let large_val = 0x1000000000000000;\n        let _: [u8; 4] = large_val.to_le_bytes();\n    }\n\n    #[test]\n    fn test_to_from_be_bytes_bn254_edge_cases() {\n        if crate::compat::is_bn254() {\n            // checking that decrementing this byte produces the expected 32 BE bytes for (modulus - 1)\n            let mut p_minus_1_bytes: [u8; 32] = modulus_be_bytes().as_array();\n            assert(p_minus_1_bytes[32 - 1] > 0);\n            p_minus_1_bytes[32 - 1] -= 1;\n\n            let p_minus_1 = Field::from_be_bytes::<32>(p_minus_1_bytes);\n            assert_eq(p_minus_1 + 1, 0);\n\n            // checking that converting (modulus - 1) from and then to 32 BE bytes produces the same bytes\n            let p_minus_1_converted_bytes: [u8; 32] = p_minus_1.to_be_bytes();\n            assert_eq(p_minus_1_converted_bytes, p_minus_1_bytes);\n\n            // checking that incrementing this byte produces 32 BE bytes for (modulus + 1)\n            let mut p_plus_1_bytes: [u8; 32] = modulus_be_bytes().as_array();\n            assert(p_plus_1_bytes[32 - 1] < 255);\n            p_plus_1_bytes[32 - 1] += 1;\n\n            let p_plus_1 = Field::from_be_bytes::<32>(p_plus_1_bytes);\n            assert_eq(p_plus_1, 1);\n\n            // checking that converting p_plus_1 to 32 BE bytes produces the same\n            // byte set to 1 as p_plus_1_bytes and otherwise zeroes\n            let mut p_plus_1_converted_bytes: [u8; 32] = p_plus_1.to_be_bytes();\n            assert_eq(p_plus_1_converted_bytes[32 - 1], 1);\n            p_plus_1_converted_bytes[32 - 1] = 0;\n            assert_eq(p_plus_1_converted_bytes, [0; 32]);\n\n            // checking that Field::from_be_bytes::<32> on the Field modulus produces 0\n            assert_eq(modulus_be_bytes().len(), 32);\n            let p = Field::from_be_bytes::<32>(modulus_be_bytes().as_array());\n            assert_eq(p, 0);\n\n            // checking that converting 0 to 32 BE bytes produces 32 zeroes\n            let p_bytes: [u8; 32] = 0.to_be_bytes();\n            assert_eq(p_bytes, [0; 32]);\n        }\n    }\n\n    #[test]\n    fn test_to_from_le_bytes_bn254_edge_cases() {\n        if crate::compat::is_bn254() {\n            // checking that decrementing this byte produces the expected 32 LE bytes for (modulus - 1)\n            let mut p_minus_1_bytes: [u8; 32] = modulus_le_bytes().as_array();\n            assert(p_minus_1_bytes[0] > 0);\n            p_minus_1_bytes[0] -= 1;\n\n            let p_minus_1 = Field::from_le_bytes::<32>(p_minus_1_bytes);\n            assert_eq(p_minus_1 + 1, 0);\n\n            // checking that converting (modulus - 1) from and then to 32 BE bytes produces the same bytes\n            let p_minus_1_converted_bytes: [u8; 32] = p_minus_1.to_le_bytes();\n            assert_eq(p_minus_1_converted_bytes, p_minus_1_bytes);\n\n            // checking that incrementing this byte produces 32 LE bytes for (modulus + 1)\n            let mut p_plus_1_bytes: [u8; 32] = modulus_le_bytes().as_array();\n            assert(p_plus_1_bytes[0] < 255);\n            p_plus_1_bytes[0] += 1;\n\n            let p_plus_1 = Field::from_le_bytes::<32>(p_plus_1_bytes);\n            assert_eq(p_plus_1, 1);\n\n            // checking that converting p_plus_1 to 32 LE bytes produces the same\n            // byte set to 1 as p_plus_1_bytes and otherwise zeroes\n            let mut p_plus_1_converted_bytes: [u8; 32] = p_plus_1.to_le_bytes();\n            assert_eq(p_plus_1_converted_bytes[0], 1);\n            p_plus_1_converted_bytes[0] = 0;\n            assert_eq(p_plus_1_converted_bytes, [0; 32]);\n\n            // checking that Field::from_le_bytes::<32> on the Field modulus produces 0\n            assert_eq(modulus_le_bytes().len(), 32);\n            let p = Field::from_le_bytes::<32>(modulus_le_bytes().as_array());\n            assert_eq(p, 0);\n\n            // checking that converting 0 to 32 LE bytes produces 32 zeroes\n            let p_bytes: [u8; 32] = 0.to_le_bytes();\n            assert_eq(p_bytes, [0; 32]);\n        }\n    }\n\n    /// Convert a little endian bit array to a field element.\n    /// If the provided bit array overflows the field modulus then the Field will silently wrap around.\n    fn from_le_bits<let N: u32>(bits: [u1; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bits().len(),\n            \"N must be less than or equal to modulus_le_bits().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bits[i] as Field) * v;\n            v = v * 2;\n        }\n        result\n    }\n\n    /// Convert a big endian bit array to a field element.\n    /// If the provided bit array overflows the field modulus then the Field will silently wrap around.\n    fn from_be_bits<let N: u32>(bits: [u1; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bits[N - 1 - i] as Field) * v;\n            v = v * 2;\n        }\n        result\n    }\n\n    #[test]\n    fn test_to_from_be_bits_bn254_edge_cases() {\n        if crate::compat::is_bn254() {\n            // checking that decrementing this bit produces the expected 254 BE bits for (modulus - 1)\n            let mut p_minus_1_bits: [u1; 254] = modulus_be_bits().as_array();\n            assert(p_minus_1_bits[254 - 1] > 0);\n            p_minus_1_bits[254 - 1] -= 1;\n\n            let p_minus_1 = from_be_bits::<254>(p_minus_1_bits);\n            assert_eq(p_minus_1 + 1, 0);\n\n            // checking that converting (modulus - 1) from and then to 254 BE bits produces the same bits\n            let p_minus_1_converted_bits: [u1; 254] = p_minus_1.to_be_bits();\n            assert_eq(p_minus_1_converted_bits, p_minus_1_bits);\n\n            // checking that incrementing this bit produces 254 BE bits for (modulus + 4)\n            let mut p_plus_4_bits: [u1; 254] = modulus_be_bits().as_array();\n            assert(p_plus_4_bits[254 - 3] < 1);\n            p_plus_4_bits[254 - 3] += 1;\n\n            let p_plus_4 = from_be_bits::<254>(p_plus_4_bits);\n            assert_eq(p_plus_4, 4);\n\n            // checking that converting p_plus_4 to 254 BE bits produces the same\n            // bit set to 1 as p_plus_4_bits and otherwise zeroes\n            let mut p_plus_4_converted_bits: [u1; 254] = p_plus_4.to_be_bits();\n            assert_eq(p_plus_4_converted_bits[254 - 3], 1);\n            p_plus_4_converted_bits[254 - 3] = 0;\n            assert_eq(p_plus_4_converted_bits, [0; 254]);\n\n            // checking that Field::from_be_bits::<254> on the Field modulus produces 0\n            assert_eq(modulus_be_bits().len(), 254);\n            let p = from_be_bits::<254>(modulus_be_bits().as_array());\n            assert_eq(p, 0);\n\n            // checking that converting 0 to 254 BE bytes produces 254 zeroes\n            let p_bits: [u1; 254] = 0.to_be_bits();\n            assert_eq(p_bits, [0; 254]);\n        }\n    }\n\n    #[test]\n    fn test_to_from_le_bits_bn254_edge_cases() {\n        if crate::compat::is_bn254() {\n            // checking that decrementing this bit produces the expected 254 LE bits for (modulus - 1)\n            let mut p_minus_1_bits: [u1; 254] = modulus_le_bits().as_array();\n            assert(p_minus_1_bits[0] > 0);\n            p_minus_1_bits[0] -= 1;\n\n            let p_minus_1 = from_le_bits::<254>(p_minus_1_bits);\n            assert_eq(p_minus_1 + 1, 0);\n\n            // checking that converting (modulus - 1) from and then to 254 BE bits produces the same bits\n            let p_minus_1_converted_bits: [u1; 254] = p_minus_1.to_le_bits();\n            assert_eq(p_minus_1_converted_bits, p_minus_1_bits);\n\n            // checking that incrementing this bit produces 254 LE bits for (modulus + 4)\n            let mut p_plus_4_bits: [u1; 254] = modulus_le_bits().as_array();\n            assert(p_plus_4_bits[2] < 1);\n            p_plus_4_bits[2] += 1;\n\n            let p_plus_4 = from_le_bits::<254>(p_plus_4_bits);\n            assert_eq(p_plus_4, 4);\n\n            // checking that converting p_plus_4 to 254 LE bits produces the same\n            // bit set to 1 as p_plus_4_bits and otherwise zeroes\n            let mut p_plus_4_converted_bits: [u1; 254] = p_plus_4.to_le_bits();\n            assert_eq(p_plus_4_converted_bits[2], 1);\n            p_plus_4_converted_bits[2] = 0;\n            assert_eq(p_plus_4_converted_bits, [0; 254]);\n\n            // checking that Field::from_le_bits::<254> on the Field modulus produces 0\n            assert_eq(modulus_le_bits().len(), 254);\n            let p = from_le_bits::<254>(modulus_le_bits().as_array());\n            assert_eq(p, 0);\n\n            // checking that converting 0 to 254 LE bytes produces 254 zeroes\n            let p_bits: [u1; 254] = 0.to_le_bits();\n            assert_eq(p_bits, [0; 254]);\n        }\n    }\n}\n","path":"std/field/mod.nr"},"19":{"source":"// Exposed only for usage in `std::meta`\npub(crate) mod poseidon2;\n\nuse crate::default::Default;\nuse crate::embedded_curve_ops::{\n    EmbeddedCurvePoint, EmbeddedCurveScalar, multi_scalar_mul, multi_scalar_mul_array_return,\n};\nuse crate::meta::derive_via;\n\n#[foreign(sha256_compression)]\n// docs:start:sha256_compression\npub fn sha256_compression(input: [u32; 16], state: [u32; 8]) -> [u32; 8] {}\n// docs:end:sha256_compression\n\n#[foreign(keccakf1600)]\n// docs:start:keccakf1600\npub fn keccakf1600(input: [u64; 25]) -> [u64; 25] {}\n// docs:end:keccakf1600\n\npub mod keccak {\n    #[deprecated(\"This function has been moved to std::hash::keccakf1600\")]\n    pub fn keccakf1600(input: [u64; 25]) -> [u64; 25] {\n        super::keccakf1600(input)\n    }\n}\n\n#[foreign(blake2s)]\n// docs:start:blake2s\npub fn blake2s<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake2s\n{}\n\n// docs:start:blake3\npub fn blake3<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake3\n{\n    if crate::runtime::is_unconstrained() {\n        // Temporary measure while Barretenberg is main proving system.\n        // Please open an issue if you're working on another proving system and running into problems due to this.\n        crate::static_assert(\n            N <= 1024,\n            \"Barretenberg cannot prove blake3 hashes with inputs larger than 1024 bytes\",\n        );\n    }\n    __blake3(input)\n}\n\n#[foreign(blake3)]\nfn __blake3<let N: u32>(input: [u8; N]) -> [u8; 32] {}\n\n// docs:start:pedersen_commitment\npub fn pedersen_commitment<let N: u32>(input: [Field; N]) -> EmbeddedCurvePoint {\n    // docs:end:pedersen_commitment\n    pedersen_commitment_with_separator(input, 0)\n}\n\n#[inline_always]\npub fn pedersen_commitment_with_separator<let N: u32>(\n    input: [Field; N],\n    separator: u32,\n) -> EmbeddedCurvePoint {\n    let mut points = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N];\n    for i in 0..N {\n        // we use the unsafe version because the multi_scalar_mul will constrain the scalars.\n        points[i] = from_field_unsafe(input[i]);\n    }\n    let generators = derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n    multi_scalar_mul(generators, points)\n}\n\n// docs:start:pedersen_hash\npub fn pedersen_hash<let N: u32>(input: [Field; N]) -> Field\n// docs:end:pedersen_hash\n{\n    pedersen_hash_with_separator(input, 0)\n}\n\n#[no_predicates]\npub fn pedersen_hash_with_separator<let N: u32>(input: [Field; N], separator: u32) -> Field {\n    let mut scalars: [EmbeddedCurveScalar; N + 1] = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N + 1];\n    let mut generators: [EmbeddedCurvePoint; N + 1] =\n        [EmbeddedCurvePoint::point_at_infinity(); N + 1];\n    let domain_generators: [EmbeddedCurvePoint; N] =\n        derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n\n    for i in 0..N {\n        scalars[i] = from_field_unsafe(input[i]);\n        generators[i] = domain_generators[i];\n    }\n    scalars[N] = EmbeddedCurveScalar { lo: N as Field, hi: 0 as Field };\n\n    let length_generator: [EmbeddedCurvePoint; 1] =\n        derive_generators(\"pedersen_hash_length\".as_bytes(), 0);\n    generators[N] = length_generator[0];\n    multi_scalar_mul_array_return(generators, scalars, true)[0].x\n}\n\n#[field(bn254)]\n#[inline_always]\npub fn derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {\n    crate::assert_constant(domain_separator_bytes);\n    // TODO(https://github.com/noir-lang/noir/issues/5672): Add back assert_constant on starting_index\n    __derive_generators(domain_separator_bytes, starting_index)\n}\n\n#[builtin(derive_pedersen_generators)]\n#[field(bn254)]\nfn __derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {}\n\n#[field(bn254)]\n// Decompose the input 'bn254 scalar' into two 128 bits limbs.\n// It is called 'unsafe' because it does not assert the limbs are 128 bits\n// Assuming the limbs are 128 bits:\n// Assert the decomposition does not overflow the field size.\nfn from_field_unsafe(scalar: Field) -> EmbeddedCurveScalar {\n    // Safety: xlo and xhi decomposition is checked below\n    let (xlo, xhi) = unsafe { crate::field::bn254::decompose_hint(scalar) };\n    // Check that the decomposition is correct\n    assert_eq(scalar, xlo + crate::field::bn254::TWO_POW_128 * xhi);\n    // Check that the decomposition does not overflow the field size\n    let (a, b) = if xhi == crate::field::bn254::PHI {\n        (xlo, crate::field::bn254::PLO)\n    } else {\n        (xhi, crate::field::bn254::PHI)\n    };\n    crate::field::bn254::assert_lt(a, b);\n\n    EmbeddedCurveScalar { lo: xlo, hi: xhi }\n}\n\npub fn poseidon2_permutation<let N: u32>(input: [Field; N], state_len: u32) -> [Field; N] {\n    assert_eq(input.len(), state_len);\n    poseidon2_permutation_internal(input)\n}\n\n#[foreign(poseidon2_permutation)]\nfn poseidon2_permutation_internal<let N: u32>(input: [Field; N]) -> [Field; N] {}\n\n// Generic hashing support.\n// Partially ported and impacted by rust.\n\n// Hash trait shall be implemented per type.\n#[derive_via(derive_hash)]\npub trait Hash {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher;\n}\n\n// docs:start:derive_hash\ncomptime fn derive_hash(s: TypeDefinition) -> Quoted {\n    let name = quote { $crate::hash::Hash };\n    let signature = quote { fn hash<H>(_self: Self, _state: &mut H) where H: $crate::hash::Hasher };\n    let for_each_field = |name| quote { _self.$name.hash(_state); };\n    crate::meta::make_trait_impl(\n        s,\n        name,\n        signature,\n        for_each_field,\n        quote {},\n        |fields| fields,\n    )\n}\n// docs:end:derive_hash\n\n// Hasher trait shall be implemented by algorithms to provide hash-agnostic means.\n// TODO: consider making the types generic here ([u8], [Field], etc.)\npub trait Hasher {\n    fn finish(self) -> Field;\n\n    fn write(&mut self, input: Field);\n}\n\n// BuildHasher is a factory trait, responsible for production of specific Hasher.\npub trait BuildHasher {\n    type H: Hasher;\n\n    fn build_hasher(self) -> H;\n}\n\npub struct BuildHasherDefault<H>;\n\nimpl<H> BuildHasher for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    type H = H;\n\n    fn build_hasher(_self: Self) -> H {\n        H::default()\n    }\n}\n\nimpl<H> Default for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    fn default() -> Self {\n        BuildHasherDefault {}\n    }\n}\n\nimpl Hash for Field {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self);\n    }\n}\n\nimpl Hash for u1 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u128 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u8 as Field);\n    }\n}\n\nimpl Hash for i16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u16 as Field);\n    }\n}\n\nimpl Hash for i32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u32 as Field);\n    }\n}\n\nimpl Hash for i64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u64 as Field);\n    }\n}\n\nimpl Hash for bool {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for () {\n    fn hash<H>(_self: Self, _state: &mut H)\n    where\n        H: Hasher,\n    {}\n}\n\nimpl<T, let N: u32> Hash for [T; N]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<T> Hash for [T]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.len().hash(state);\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<A, B> Hash for (A, B)\nwhere\n    A: Hash,\n    B: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n    }\n}\n\nimpl<A, B, C> Hash for (A, B, C)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n    }\n}\n\nimpl<A, B, C, D> Hash for (A, B, C, D)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n    }\n}\n\nimpl<A, B, C, D, E> Hash for (A, B, C, D, E)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n    E: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n        self.4.hash(state);\n    }\n}\n\n// Some test vectors for Pedersen hash and Pedersen Commitment.\n// They have been generated using the same functions so the tests are for now useless\n// but they will be useful when we switch to Noir implementation.\n#[test]\nfn assert_pedersen() {\n    assert_eq(\n        pedersen_hash_with_separator([1], 1),\n        0x1b3f4b1a83092a13d8d1a59f7acb62aba15e7002f4440f2275edb99ebbc2305f,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1], 1),\n        EmbeddedCurvePoint {\n            x: 0x054aa86a73cb8a34525e5bbed6e43ba1198e860f5f3950268f71df4591bde402,\n            y: 0x209dcfbf2cfb57f9f6046f44d71ac6faf87254afc7407c04eb621a6287cac126,\n            is_infinite: false,\n        },\n    );\n\n    assert_eq(\n        pedersen_hash_with_separator([1, 2], 2),\n        0x26691c129448e9ace0c66d11f0a16d9014a9e8498ee78f4d69f0083168188255,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2], 2),\n        EmbeddedCurvePoint {\n            x: 0x2e2b3b191e49541fe468ec6877721d445dcaffe41728df0a0eafeb15e87b0753,\n            y: 0x2ff4482400ad3a6228be17a2af33e2bcdf41be04795f9782bd96efe7e24f8778,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3], 3),\n        0x0bc694b7a1f8d10d2d8987d07433f26bd616a2d351bc79a3c540d85b6206dbe4,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3], 3),\n        EmbeddedCurvePoint {\n            x: 0x1fee4e8cf8d2f527caa2684236b07c4b1bad7342c01b0f75e9a877a71827dc85,\n            y: 0x2f9fedb9a090697ab69bf04c8bc15f7385b3e4b68c849c1536e5ae15ff138fd1,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4], 4),\n        0xdae10fb32a8408521803905981a2b300d6a35e40e798743e9322b223a5eddc,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4], 4),\n        EmbeddedCurvePoint {\n            x: 0x07ae3e202811e1fca39c2d81eabe6f79183978e6f12be0d3b8eda095b79bdbc9,\n            y: 0x0afc6f892593db6fbba60f2da558517e279e0ae04f95758587760ba193145014,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5], 5),\n        0xfc375b062c4f4f0150f7100dfb8d9b72a6d28582dd9512390b0497cdad9c22,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5], 5),\n        EmbeddedCurvePoint {\n            x: 0x1754b12bd475a6984a1094b5109eeca9838f4f81ac89c5f0a41dbce53189bb29,\n            y: 0x2da030e3cfcdc7ddad80eaf2599df6692cae0717d4e9f7bfbee8d073d5d278f7,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6], 6),\n        0x1696ed13dc2730062a98ac9d8f9de0661bb98829c7582f699d0273b18c86a572,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6], 6),\n        EmbeddedCurvePoint {\n            x: 0x190f6c0e97ad83e1e28da22a98aae156da083c5a4100e929b77e750d3106a697,\n            y: 0x1f4b60f34ef91221a0b49756fa0705da93311a61af73d37a0c458877706616fb,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        0x128c0ff144fc66b6cb60eeac8a38e23da52992fc427b92397a7dffd71c45ede3,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        EmbeddedCurvePoint {\n            x: 0x015441e9d29491b06563fac16fc76abf7a9534c715421d0de85d20dbe2965939,\n            y: 0x1d2575b0276f4e9087e6e07c2cb75aa1baafad127af4be5918ef8a2ef2fea8fc,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        0x2f960e117482044dfc99d12fece2ef6862fba9242be4846c7c9a3e854325a55c,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        EmbeddedCurvePoint {\n            x: 0x1657737676968887fceb6dd516382ea13b3a2c557f509811cd86d5d1199bc443,\n            y: 0x1f39f0cb569040105fa1e2f156521e8b8e08261e635a2b210bdc94e8d6d65f77,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        0x0c96db0790602dcb166cc4699e2d306c479a76926b81c2cb2aaa92d249ec7be7,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        EmbeddedCurvePoint {\n            x: 0x0a3ceae42d14914a432aa60ec7fded4af7dad7dd4acdbf2908452675ec67e06d,\n            y: 0xfc19761eaaf621ad4aec9a8b2e84a4eceffdba78f60f8b9391b0bd9345a2f2,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        0x2cd37505871bc460a62ea1e63c7fe51149df5d0801302cf1cbc48beb8dff7e94,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        EmbeddedCurvePoint {\n            x: 0x2fb3f8b3d41ddde007c8c3c62550f9a9380ee546fcc639ffbb3fd30c8d8de30c,\n            y: 0x300783be23c446b11a4c0fabf6c91af148937cea15fcf5fb054abf7f752ee245,\n            is_infinite: false,\n        },\n    );\n}\n","path":"std/hash/mod.nr"},"42":{"source":"use crate::cmp::{Eq, Ord, Ordering};\nuse crate::default::Default;\nuse crate::hash::{Hash, Hasher};\n\npub struct Option<T> {\n    _is_some: bool,\n    _value: T,\n}\n\nimpl<T> Option<T> {\n    /// Constructs a None value\n    pub fn none() -> Self {\n        Self { _is_some: false, _value: crate::mem::zeroed() }\n    }\n\n    /// Constructs a Some wrapper around the given value\n    pub fn some(_value: T) -> Self {\n        Self { _is_some: true, _value }\n    }\n\n    /// True if this Option is None\n    pub fn is_none(self) -> bool {\n        !self._is_some\n    }\n\n    /// True if this Option is Some\n    pub fn is_some(self) -> bool {\n        self._is_some\n    }\n\n    /// Asserts `self.is_some()` and returns the wrapped value.\n    pub fn unwrap(self) -> T {\n        assert(self._is_some);\n        self._value\n    }\n\n    /// Returns the inner value without asserting `self.is_some()`\n    /// Note that if `self` is `None`, there is no guarantee what value will be returned,\n    /// only that it will be of type `T`.\n    pub fn unwrap_unchecked(self) -> T {\n        self._value\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, returns the given default value.\n    pub fn unwrap_or(self, default: T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default\n        }\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, calls the given function to return\n    /// a default value.\n    pub fn unwrap_or_else<Env>(self, default: fn[Env]() -> T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default()\n        }\n    }\n\n    /// Asserts `self.is_some()` with a provided custom message and returns the contained `Some` value\n    pub fn expect<let N: u32, MessageTypes>(self, message: fmtstr<N, MessageTypes>) -> T {\n        assert(self.is_some(), message);\n        self._value\n    }\n\n    /// If self is `Some(x)`, this returns `Some(f(x))`. Otherwise, this returns `None`.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> Option<U> {\n        if self._is_some {\n            Option::some(f(self._value))\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns the given default value.\n    pub fn map_or<U, Env>(self, default: U, f: fn[Env](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns `default()`.\n    pub fn map_or_else<U, Env1, Env2>(self, default: fn[Env1]() -> U, f: fn[Env2](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default()\n        }\n    }\n\n    /// Returns None if self is None. Otherwise, this returns `other`.\n    pub fn and(self, other: Self) -> Self {\n        if self.is_none() {\n            Option::none()\n        } else {\n            other\n        }\n    }\n\n    /// If self is None, this returns None. Otherwise, this calls the given function\n    /// with the Some value contained within self, and returns the result of that call.\n    ///\n    /// In some languages this function is called `flat_map` or `bind`.\n    pub fn and_then<U, Env>(self, f: fn[Env](T) -> Option<U>) -> Option<U> {\n        if self._is_some {\n            f(self._value)\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `other`.\n    pub fn or(self, other: Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            other\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `default()`.\n    pub fn or_else<Env>(self, default: fn[Env]() -> Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            default()\n        }\n    }\n\n    // If only one of the two Options is Some, return that option.\n    // Otherwise, if both options are Some or both are None, None is returned.\n    pub fn xor(self, other: Self) -> Self {\n        if self._is_some {\n            if other._is_some {\n                Option::none()\n            } else {\n                self\n            }\n        } else if other._is_some {\n            other\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Returns `Some(x)` if self is `Some(x)` and `predicate(x)` is true.\n    /// Otherwise, this returns `None`\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        if self._is_some {\n            if predicate(self._value) {\n                self\n            } else {\n                Option::none()\n            }\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Flattens an Option<Option<T>> into a Option<T>.\n    /// This returns None if the outer Option is None. Otherwise, this returns the inner Option.\n    pub fn flatten(option: Option<Option<T>>) -> Option<T> {\n        if option._is_some {\n            option._value\n        } else {\n            Option::none()\n        }\n    }\n}\n\nimpl<T> Default for Option<T> {\n    fn default() -> Self {\n        Option::none()\n    }\n}\n\nimpl<T> Eq for Option<T>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: Self) -> bool {\n        if self._is_some == other._is_some {\n            if self._is_some {\n                self._value == other._value\n            } else {\n                true\n            }\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T> Hash for Option<T>\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self._is_some.hash(state);\n        if self._is_some {\n            self._value.hash(state);\n        }\n    }\n}\n\n// For this impl we're declaring Option::none < Option::some\nimpl<T> Ord for Option<T>\nwhere\n    T: Ord,\n{\n    fn cmp(self, other: Self) -> Ordering {\n        if self._is_some {\n            if other._is_some {\n                self._value.cmp(other._value)\n            } else {\n                Ordering::greater()\n            }\n        } else if other._is_some {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n","path":"std/option.nr"},"43":{"source":"pub fn panic<T, U, let N: u32>(message: fmtstr<N, T>) -> U {\n    assert(false, message);\n    crate::mem::zeroed()\n}\n","path":"std/panic.nr"},"51":{"source":"use dep::aztec::macros::aztec;\n\n#[aztec]\npub contract SimpleLogging {\n    use aztec::{\n        macros::{\n            functions::{external, initializer},\n            storage::storage,\n        },\n        protocol_types::address::AztecAddress,\n        state_vars::{Map, PublicMutable},\n    };\n\n    #[storage]\n    struct Storage<Context> {\n        counters: Map<AztecAddress, PublicMutable<u64, Context>, Context>,\n    }\n\n    #[initializer]\n    #[external(\"public\")]\n    fn initialize(headstart: u64, owner: AztecAddress) {\n        self.storage.counters.at(owner).write(headstart);\n    }\n\n    #[external(\"public\")]\n    fn increment(owner: AztecAddress) {\n        let new_value = self.storage.counters.at(owner).read() + 1;\n        self.storage.counters.at(owner).write(new_value);\n    }\n\n    #[external(\"utility\")]\n    unconstrained fn get_counter(owner: AztecAddress) -> u64 {\n        self.storage.counters.at(owner).read()\n    }\n}\n","path":"/home/filip/c/chicmoz/services/event-cannon/src/contract-projects/SimpleLogging/src/main.nr"},"60":{"source":"use crate::oracle::capsules;\nuse protocol_types::{address::AztecAddress, traits::{Deserialize, Serialize}};\n\n/// A dynamically sized array backed by PXE's non-volatile database (called capsules). Values are persisted until\n/// deleted, so they can be e.g. stored during simulation of a transaction and later retrieved during witness\n/// generation. All values are scoped per contract address, so external contracts cannot access them.\npub struct CapsuleArray<T> {\n    contract_address: AztecAddress,\n    /// The base slot is where the array length is stored in capsules. Array elements are stored in consecutive slots\n    /// after the base slot. For example, with base slot 5: the length is at slot 5, the first element (index 0) is at\n    /// slot 6, the second element (index 1) is at slot 7, and so on.\n    base_slot: Field,\n}\n\nimpl<T> CapsuleArray<T> {\n    /// Returns a CapsuleArray connected to a contract's capsules at a base slot. Array elements are stored in\n    /// contiguous slots following the base slot, so there should be sufficient space between array base slots to\n    /// accommodate elements. A reasonable strategy is to make the base slot a hash of a unique value.\n    pub unconstrained fn at(contract_address: AztecAddress, base_slot: Field) -> Self {\n        Self { contract_address, base_slot }\n    }\n\n    /// Returns the number of elements stored in the array.\n    pub unconstrained fn len(self) -> u32 {\n        // An uninitialized array defaults to a length of 0.\n        capsules::load(self.contract_address, self.base_slot).unwrap_or(0) as u32\n    }\n\n    /// Stores a value at the end of the array.\n    pub unconstrained fn push(self, value: T)\n    where\n        T: Serialize,\n    {\n        let current_length = self.len();\n\n        // The slot corresponding to the index `current_length` is the first slot immediately after the end of the\n        // array, which is where we want to place the new value.\n        capsules::store(self.contract_address, self.slot_at(current_length), value);\n\n        // Then we simply update the length.\n        let new_length = current_length + 1;\n        capsules::store(self.contract_address, self.base_slot, new_length);\n    }\n\n    /// Retrieves the value stored in the array at `index`. Throws if the index is out of bounds.\n    pub unconstrained fn get(self, index: u32) -> T\n    where\n        T: Deserialize,\n    {\n        assert(index < self.len(), \"Attempted to read past the length of a CapsuleArray\");\n\n        capsules::load(self.contract_address, self.slot_at(index)).unwrap()\n    }\n\n    /// Deletes the value stored in the array at `index`. Throws if the index is out of bounds.\n    pub unconstrained fn remove(self, index: u32) {\n        let current_length = self.len();\n        assert(index < current_length, \"Attempted to delete past the length of a CapsuleArray\");\n\n        // In order to be able to remove elements at arbitrary indices, we need to shift the entire contents of the\n        // array past the removed element one slot backward so that we don't end up with a gap and preserve the\n        // contiguous slots. We can skip this when deleting the last element however.\n        if index != current_length - 1 {\n            // The source and destination regions overlap, but `copy` supports this.\n            capsules::copy(\n                self.contract_address,\n                self.slot_at(index + 1),\n                self.slot_at(index),\n                current_length - index - 1,\n            );\n        }\n\n        // We can now delete the last element (which has either been copied to the slot immediately before it, or was\n        // the element we meant to delete in the first place) and update the length.\n        capsules::delete(self.contract_address, self.slot_at(current_length - 1));\n        capsules::store(self.contract_address, self.base_slot, current_length - 1);\n    }\n\n    /// Iterates over the entire array, calling the callback with all values and their array index. The order in which\n    /// values are processed is arbitrary.\n    ///\n    /// It is safe to delete the current element (and only the current element) from inside the callback via `remove`:\n    /// ```noir\n    /// array.for_each(|index, value| {\n    ///   if some_condition(value) {\n    ///     array.remove(index); // safe only for this index\n    ///   }\n    /// }\n    /// ```\n    ///\n    /// If all elements in the array need to iterated over and then removed, then using `for_each` results in optimal\n    /// efficiency.\n    ///\n    /// It is **not** safe to push new elements into the array from inside the callback.\n    pub unconstrained fn for_each<Env>(self, f: unconstrained fn[Env](u32, T) -> ())\n    where\n        T: Deserialize,\n    {\n        // Iterating over all elements is simple, but we want to do it in such a way that a) deleting the current\n        // element is safe to do, and b) deleting *all* elements is optimally efficient. This is because CapsuleArrays\n        // are typically used to hold pending tasks, so iterating them while clearing completed tasks (sometimes\n        // unconditionally, resulting in a full clear) is a very common access pattern.\n        //\n        // The way we achieve this is by iterating backwards: each element can always be deleted since it won't change\n        // any preceding (lower) indices, and if every element is deleted then every element will (in turn) be the last\n        // element. This results in an optimal full clear since `remove` will be able to skip the `capsules::copy` call\n        // to shift any elements past the deleted one (because there will be none).\n        let mut i = self.len();\n        while i > 0 {\n            i -= 1;\n            f(i, self.get(i));\n        }\n    }\n\n    unconstrained fn slot_at(self, index: u32) -> Field {\n        // Elements are stored immediately after the base slot, so we add 1 to it to compute the slot for the first\n        // element.\n        self.base_slot + 1 + index as Field\n    }\n}\n\nmod test {\n    use crate::test::helpers::test_environment::TestEnvironment;\n    use super::CapsuleArray;\n\n    global SLOT: Field = 1230;\n\n    #[test]\n    unconstrained fn empty_array() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let array: CapsuleArray<Field> = CapsuleArray::at(contract_address, SLOT);\n            assert_eq(array.len(), 0);\n        });\n    }\n\n    #[test(should_fail_with = \"Attempted to read past the length of a CapsuleArray\")]\n    unconstrained fn empty_array_read() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let array = CapsuleArray::at(contract_address, SLOT);\n            let _: Field = array.get(0);\n        });\n    }\n\n    #[test]\n    unconstrained fn array_push() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let array = CapsuleArray::at(contract_address, SLOT);\n            array.push(5);\n\n            assert_eq(array.len(), 1);\n            assert_eq(array.get(0), 5);\n        });\n    }\n\n    #[test(should_fail_with = \"Attempted to read past the length of a CapsuleArray\")]\n    unconstrained fn read_past_len() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let array = CapsuleArray::at(contract_address, SLOT);\n            array.push(5);\n\n            let _ = array.get(1);\n        });\n    }\n\n    #[test]\n    unconstrained fn array_remove_last() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let array = CapsuleArray::at(contract_address, SLOT);\n\n            array.push(5);\n            array.remove(0);\n\n            assert_eq(array.len(), 0);\n        });\n    }\n\n    #[test]\n    unconstrained fn array_remove_some() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let array = CapsuleArray::at(contract_address, SLOT);\n\n            array.push(7);\n            array.push(8);\n            array.push(9);\n\n            assert_eq(array.len(), 3);\n            assert_eq(array.get(0), 7);\n            assert_eq(array.get(1), 8);\n            assert_eq(array.get(2), 9);\n\n            array.remove(1);\n\n            assert_eq(array.len(), 2);\n            assert_eq(array.get(0), 7);\n            assert_eq(array.get(1), 9);\n        });\n    }\n\n    #[test]\n    unconstrained fn array_remove_all() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let array = CapsuleArray::at(contract_address, SLOT);\n\n            array.push(7);\n            array.push(8);\n            array.push(9);\n\n            array.remove(1);\n            array.remove(1);\n            array.remove(0);\n\n            assert_eq(array.len(), 0);\n        });\n    }\n\n    #[test]\n    unconstrained fn for_each_called_with_all_elements() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n            let array = CapsuleArray::at(contract_address, SLOT);\n\n            array.push(4);\n            array.push(5);\n            array.push(6);\n\n            // We store all values that we were called with and check that all (value, index) tuples are present. Note that\n            // we do not care about the order in which each tuple was passed to the closure.\n            let called_with = &mut BoundedVec::<(u32, Field), 3>::new();\n            array.for_each(|index, value| { called_with.push((index, value)); });\n\n            assert_eq(called_with.len(), 3);\n            assert(called_with.any(|(index, value)| (index == 0) & (value == 4)));\n            assert(called_with.any(|(index, value)| (index == 1) & (value == 5)));\n            assert(called_with.any(|(index, value)| (index == 2) & (value == 6)));\n        });\n    }\n\n    #[test]\n    unconstrained fn for_each_remove_some() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n            let array = CapsuleArray::at(contract_address, SLOT);\n\n            array.push(4);\n            array.push(5);\n            array.push(6);\n\n            array.for_each(|index, _| {\n                if index == 1 {\n                    array.remove(index);\n                }\n            });\n\n            assert_eq(array.len(), 2);\n            assert_eq(array.get(0), 4);\n            assert_eq(array.get(1), 6);\n        });\n    }\n\n    #[test]\n    unconstrained fn for_each_remove_all() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n            let array = CapsuleArray::at(contract_address, SLOT);\n\n            array.push(4);\n            array.push(5);\n            array.push(6);\n\n            array.for_each(|index, _| { array.remove(index); });\n\n            assert_eq(array.len(), 0);\n        });\n    }\n\n    #[test]\n    unconstrained fn for_each_remove_all_no_copy() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n            let array = CapsuleArray::at(contract_address, SLOT);\n\n            array.push(4);\n            array.push(5);\n            array.push(6);\n\n            // We test that the utilityCopyCapsule was never called, which is the expensive operation we want to avoid.\n            let mock = std::test::OracleMock::mock(\"utilityCopyCapsule\");\n\n            array.for_each(|index, _| { array.remove(index); });\n\n            assert_eq(mock.times_called(), 0);\n        });\n    }\n}\n","path":"/home/filip/nargo/github.com/AztecProtocol/aztec-packages/v3.0.1-rc.1/noir-projects/aztec-nr/aztec/src/capsules/mod.nr"},"70":{"source":"use crate::context::gas::GasOpts;\nuse crate::hash::{\n    compute_l1_to_l2_message_hash, compute_l1_to_l2_message_nullifier, compute_secret_hash,\n};\nuse dep::protocol_types::abis::function_selector::FunctionSelector;\nuse dep::protocol_types::address::{AztecAddress, EthAddress};\nuse dep::protocol_types::constants::{MAX_U32_VALUE, NULL_MSG_SENDER_CONTRACT_ADDRESS};\nuse dep::protocol_types::traits::{Empty, FromField, Packable, Serialize, ToField};\n\n/// # PublicContext\n///\n/// The **main interface** between an #[external(\"public\")] function and the Aztec blockchain.\n///\n/// An instance of the PublicContext is initialized automatically at the outset\n/// of every public function, within the #[external(\"public\")] macro, so you'll never\n/// need to consciously instantiate this yourself.\n///\n/// The instance is always named `context`, and it will always be available\n/// within the body of every #[external(\"public\")] function in your smart contract.\n///\n/// Typical usage for a smart contract developer will be to call getter\n/// methods of the PublicContext.\n///\n/// _Pushing_ data and requests to the context is mostly handled within\n/// aztec-nr's own functions, so typically a smart contract developer won't\n/// need to call any setter methods directly.\n///\n/// ## Responsibilities\n/// - Exposes contextual data to a public function:\n///   - Data relating to how this public function was called:\n///     - msg_sender, this_address\n///   - Data relating to the current blockchain state:\n///     - timestamp, block_number, chain_id, version\n///   - Gas and fee information\n/// - Provides state access:\n///   - Read/write public storage (key-value mapping)\n///   - Check existence of notes and nullifiers\n///     (Some patterns use notes & nullifiers to store public (not private)\n///     information)\n///   - Enables consumption of L1->L2 messages.\n/// - Enables calls to other public smart contract functions:\n/// - Writes data to the blockchain:\n///   - Updates to public state variables\n///   - New public logs (for events)\n///   - New L2->L1 messages\n///   - New notes & nullifiers\n///     (E.g. pushing public info to notes/nullifiers, or for completing\n///     \"partial notes\")\n///\n/// ## Key Differences from Private Execution\n///\n/// Unlike private functions -- which are executed on the user's device and which\n/// can only reference historic state -- public functions are executed by a block\n/// proposer and are executed \"live\" on the _current_ tip of the chain.\n/// This means public functions can:\n/// - Read and write _current_ public state\n/// - Immediately see the effects of earlier transactions in the same block\n///\n/// Also, public functions are executed within a zkVM (the \"AVM\"), so that they\n/// can _revert_ whilst still ensuring payment to the proposer and prover.\n/// (Private functions cannot revert: they either succeed, or they cannot be\n/// included).\n///\n/// ## Optimising Public Functions\n///\n/// Using the AVM to execute public functions means they compile down to \"AVM\n/// bytecode\" instead of the ACIR that private functions (standalone circuits)\n/// compile to. Therefore the approach to optimising a public function is\n/// fundamentally different from optimising a public function.\n///\npub struct PublicContext {\n    pub args_hash: Option<Field>,\n    pub compute_args_hash: fn() -> Field,\n}\n\nimpl Eq for PublicContext {\n    fn eq(self, other: Self) -> bool {\n        (self.args_hash == other.args_hash)\n        // Can't compare the function compute_args_hash\n    }\n}\n\nimpl PublicContext {\n    /// Creates a new PublicContext instance.\n    ///\n    /// Low-level function: This is called automatically by the #[external(\"public\")]\n    /// macro, so you shouldn't need to be called directly by smart contract\n    /// developers.\n    ///\n    /// # Arguments\n    /// * `compute_args_hash` - Function to compute the args_hash\n    ///\n    /// # Returns\n    /// * A new PublicContext instance\n    ///\n    pub fn new(compute_args_hash: fn() -> Field) -> Self {\n        PublicContext { args_hash: Option::none(), compute_args_hash }\n    }\n\n    /// Emits a _public_ log that will be visible onchain to everyone.\n    ///\n    /// # Arguments\n    /// * `log` - The data to log, must implement Serialize trait\n    ///\n    pub fn emit_public_log<T>(_self: Self, log: T)\n    where\n        T: Serialize,\n    {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { emit_public_log(Serialize::serialize(log).as_slice()) };\n    }\n\n    /// Checks if a given note hash exists in the note hash tree at a particular\n    /// leaf_index.\n    ///\n    /// # Arguments\n    /// * `note_hash` - The note hash to check for existence\n    /// * `leaf_index` - The index where the note hash should be located\n    ///\n    /// # Returns\n    /// * `bool` - True if the note hash exists at the specified index\n    ///\n    pub fn note_hash_exists(_self: Self, note_hash: Field, leaf_index: u64) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { note_hash_exists(note_hash, leaf_index) } == 1\n    }\n\n    /// Checks if a specific L1-to-L2 message exists in the L1-to-L2 message\n    /// tree at a particular leaf index.\n    ///\n    /// Common use cases include token bridging, cross-chain governance, and\n    /// triggering L2 actions based on L1 events.\n    ///\n    /// This function should be called before attempting to consume an L1-to-L2\n    /// message.\n    ///\n    /// # Arguments\n    /// * `msg_hash` - Hash of the L1-to-L2 message to check\n    /// * `msg_leaf_index` - The index where the message should be located\n    ///\n    /// # Returns\n    /// * `bool` - True if the message exists at the specified index\n    ///\n    /// # Advanced\n    /// * Uses the AVM l1_to_l2_msg_exists opcode for tree lookup\n    /// * Messages are copied from L1 Inbox to L2 by block proposers\n    ///\n    pub fn l1_to_l2_msg_exists(_self: Self, msg_hash: Field, msg_leaf_index: Field) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        // TODO(alvaro): Make l1l2msg leaf index a u64 upstream\n        unsafe { l1_to_l2_msg_exists(msg_hash, msg_leaf_index as u64) } == 1\n    }\n\n    /// Checks if a specific nullifier has been emitted by a given contract.\n    ///\n    /// Whilst nullifiers are primarily intended as a _privacy-preserving_\n    /// record of a one-time action, they can also be used to efficiently\n    /// record _public_ one-time actions too. An example is to check\n    /// whether a contract has been published: we emit a nullifier that is\n    /// deterministic, but whose preimage is _not_ private. This is more\n    /// efficient than using mutable storage, and can be done directly\n    /// from a private function.\n    ///\n    /// Nullifiers can be tested for non-existence in public, which is not the\n    /// case in private. Because private functions do not have access to\n    /// the tip of the blockchain (but only the anchor block they are built\n    /// at) they can only prove nullifier non-existence in the past. But between\n    /// an anchor block and the block in which a tx is included, the nullifier\n    /// might have been inserted into the nullifier tree by some other\n    /// transaction.\n    /// Public functions _do_ have access to the tip of the state, and so\n    /// this pattern is safe.\n    ///\n    /// # Arguments\n    /// * `unsiloed_nullifier` - The raw nullifier value (before siloing with\n    ///                          the contract address that emitted it).\n    /// * `address` - The claimed contract address that emitted the nullifier\n    ///\n    /// # Returns\n    /// * `bool` - True if the nullifier has been emitted by the specified contract\n    ///\n    pub fn nullifier_exists(_self: Self, unsiloed_nullifier: Field, address: AztecAddress) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { nullifier_exists(unsiloed_nullifier, address.to_field()) } == 1\n    }\n\n    /// Consumes a message sent from Ethereum (L1) to Aztec (L2) -- effectively\n    /// marking it as \"read\".\n    ///\n    /// Use this function if you only want the message to ever be \"referred to\"\n    /// once. Once consumed using this method, the message cannot be consumed\n    /// again, because a nullifier is emitted.\n    /// If your use case wants for the message to be read unlimited times, then\n    /// you can always read any historic message from the L1-to-L2 messages tree,\n    /// using the `l1_to_l2_msg_exists` method. Messages never technically get\n    /// deleted from that tree.\n    ///\n    /// The message will first be inserted into an Aztec \"Inbox\" smart contract\n    /// on L1. It will not be available for consumption immediately. Messages\n    /// get copied-over from the L1 Inbox to L2 by the next Proposer in batches.\n    /// So you will need to wait until the messages are copied before you can\n    /// consume them.\n    ///\n    /// # Arguments\n    /// * `content` - The message content that was sent from L1\n    /// * `secret` - Secret value used for message privacy (if needed)\n    /// * `sender` - Ethereum address that sent the message\n    /// * `leaf_index` - Index of the message in the L1-to-L2 message tree\n    ///\n    /// # Advanced\n    /// * Validates message existence in the L1-to-L2 message tree\n    /// * Prevents double-consumption by emitting a nullifier\n    /// * Message hash is computed from all parameters + chain context\n    /// * Will revert if message doesn't exist or was already consumed\n    ///\n    pub fn consume_l1_to_l2_message(\n        self: Self,\n        content: Field,\n        secret: Field,\n        sender: EthAddress,\n        leaf_index: Field,\n    ) {\n        let secret_hash = compute_secret_hash(secret);\n        let message_hash = compute_l1_to_l2_message_hash(\n            sender,\n            self.chain_id(),\n            /*recipient=*/\n            self.this_address(),\n            self.version(),\n            content,\n            secret_hash,\n            leaf_index,\n        );\n        let nullifier = compute_l1_to_l2_message_nullifier(message_hash, secret);\n\n        assert(\n            !self.nullifier_exists(nullifier, self.this_address()),\n            \"L1-to-L2 message is already nullified\",\n        );\n        assert(\n            self.l1_to_l2_msg_exists(message_hash, leaf_index),\n            \"Tried to consume nonexistent L1-to-L2 message\",\n        );\n\n        self.push_nullifier(nullifier);\n    }\n\n    /// Sends an \"L2 -> L1 message\" from this function (Aztec, L2) to a smart\n    /// contract on Ethereum (L1). L1 contracts which are designed to\n    /// send/receive messages to/from Aztec are called \"Portal Contracts\".\n    ///\n    /// Common use cases include withdrawals, cross-chain asset transfers, and\n    /// triggering L1 actions based on L2 state changes.\n    ///\n    /// The message will be inserted into an Aztec \"Outbox\" contract on L1,\n    /// when this transaction's block is proposed to L1.\n    /// Sending the message will not result in any immediate state changes in\n    /// the target portal contract. The message will need to be manually\n    /// consumed from the Outbox through a separate Ethereum transaction: a user\n    /// will need to call a function of the portal contract -- a function\n    /// specifically designed to make a call to the Outbox to consume the\n    /// message.\n    /// The message will only be available for consumption once the _epoch_\n    /// proof has been submitted. Given that there are multiple Aztec blocks\n    /// within an epoch, it might take some time for this epoch proof to be\n    /// submitted -- especially if the block was near the start of an epoch.\n    ///\n    /// # Arguments\n    /// * `recipient` - Ethereum address that will receive the message\n    /// * `content` - Message content (32 bytes as a Field element)\n    ///\n    pub fn message_portal(_self: Self, recipient: EthAddress, content: Field) {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { send_l2_to_l1_msg(recipient, content) };\n    }\n\n    /// Calls a public function on another contract.\n    ///\n    /// Will revert if the called function reverts or runs out of gas.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract to call\n    /// * `function_selector` - Function to call on the target contract\n    /// * `args` - Arguments to pass to the function\n    /// * `gas_opts` - An optional allocation of gas to the called function.\n    ///\n    /// # Returns\n    /// * `[Field]` - Return data from the called function\n    ///\n    pub unconstrained fn call_public_function<let N: u32>(\n        _self: Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; N],\n        gas_opts: GasOpts,\n    ) -> [Field] {\n        let calldata = [function_selector.to_field()].concat(args);\n\n        call(\n            gas_opts.l2_gas.unwrap_or(MAX_U32_VALUE),\n            gas_opts.da_gas.unwrap_or(MAX_U32_VALUE),\n            contract_address,\n            calldata,\n        );\n        // Use success_copy to determine whether the call succeeded\n        let success = success_copy();\n\n        let result_data = returndata_copy(0, returndata_size());\n        if !success {\n            // Rethrow the revert data.\n            avm_revert(result_data);\n        }\n        result_data\n    }\n\n    /// Makes a read-only call to a public function on another contract.\n    ///\n    /// This is similar to Solidity's `staticcall`. The called function\n    /// cannot modify state or emit events. Any nested calls are constrained to\n    /// also be staticcalls.\n    ///\n    /// Useful for querying data from other contracts safely.\n    ///\n    /// Will revert if the called function reverts or runs out of gas.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract to call\n    /// * `function_selector` - Function to call on the target contract\n    /// * `args` - Array of arguments to pass to the called function\n    /// * `gas_opts` - An optional allocation of gas to the called function.\n    ///\n    /// # Returns\n    /// * `[Field]` - Return data from the called function\n    ///\n    pub unconstrained fn static_call_public_function<let N: u32>(\n        _self: Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; N],\n        gas_opts: GasOpts,\n    ) -> [Field] {\n        let calldata = [function_selector.to_field()].concat(args);\n\n        call_static(\n            gas_opts.l2_gas.unwrap_or(MAX_U32_VALUE),\n            gas_opts.da_gas.unwrap_or(MAX_U32_VALUE),\n            contract_address,\n            calldata,\n        );\n        // Use success_copy to determine whether the call succeeded\n        let success = success_copy();\n\n        let result_data = returndata_copy(0, returndata_size());\n        if !success {\n            // Rethrow the revert data.\n            avm_revert(result_data);\n        }\n        result_data\n    }\n\n    /// Adds a new note hash to the Aztec blockchain's global Note Hash Tree.\n    ///\n    /// Notes are ordinarily constructed and emitted by _private_ functions, to\n    /// ensure that both the content of the note, and the contract that emitted\n    /// the note, stay private.\n    ///\n    /// There are however some useful patterns whereby a note needs to contain\n    /// _public_ data. The ability to push a new note_hash from a _public_\n    /// function means that notes can be injected with public data immediately\n    /// -- as soon as the public value is known. The slower alternative would\n    /// be to submit a follow-up transaction so that a private function can\n    /// inject the data. Both are possible on Aztec.\n    ///\n    /// Search \"Partial Note\" for a very common pattern which enables a note\n    /// to be \"partially\" populated with some data in a _private_ function, and\n    /// then later \"completed\" with some data in a public function.\n    ///\n    /// # Arguments\n    /// * `note_hash` - The hash of the note to add to the tree\n    ///\n    /// # Advanced\n    /// * The note hash will be siloed with the contract address by the protocol\n    ///\n    pub fn push_note_hash(_self: Self, note_hash: Field) {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { emit_note_hash(note_hash) };\n    }\n\n    /// Adds a new nullifier to the Aztec blockchain's global Nullifier Tree.\n    ///\n    /// Whilst nullifiers are primarily intended as a _privacy-preserving_\n    /// record of a one-time action, they can also be used to efficiently\n    /// record _public_ one-time actions too. Hence why you're seeing this\n    /// function within the PublicContext.\n    /// An example is to check whether a contract has been published: we emit\n    /// a nullifier that is deterministic, but whose preimage is _not_ private.\n    ///\n    /// # Arguments\n    /// * `nullifier` - A unique field element that represents the consumed\n    ///   state\n    ///\n    /// # Advanced\n    /// * Nullifier is immediately added to the global nullifier tree\n    /// * Emitted nullifiers are immediately visible to all\n    ///   subsequent transactions in the same block\n    /// * Automatically siloed with the contract address by the protocol\n    /// * Used for preventing double-spending and ensuring one-time actions\n    ///\n    pub fn push_nullifier(_self: Self, nullifier: Field) {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { emit_nullifier(nullifier) };\n    }\n\n    /// Returns the address of the current contract being executed.\n    ///\n    /// This is equivalent to `address(this)` in Solidity (hence the name).\n    /// Use this to identify the current contract's address, commonly needed for\n    /// access control or when interacting with other contracts.\n    ///\n    /// # Returns\n    /// * `AztecAddress` - The contract address of the current function being\n    ///                    executed.\n    ///\n    pub fn this_address(_self: Self) -> AztecAddress {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            address()\n        }\n    }\n\n    /// Returns the contract address that initiated this function call.\n    ///\n    /// This is similar to `msg.sender` in Solidity (hence the name).\n    ///\n    /// Important Note: If the calling function is a _private_ function, then\n    /// it had the option of hiding its address when enqueuing this public\n    /// function call. In such cases, this `context.msg_sender()` method will\n    /// return `Option<AztecAddress>::none`.\n    /// If the calling function is a _public_ function, it will always return\n    /// an `Option<AztecAddress>::some` (i.e. a non-null value).\n    ///\n    /// # Returns\n    /// * `Option<AztecAddress>` - The address of the smart contract that called\n    ///   this function (be it an app contract or a user's account contract).\n    ///\n    /// # Advanced\n    /// * Value is provided by the AVM sender opcode\n    /// * In nested calls, this is the immediate caller, not the original\n    ///   transaction sender\n    ///\n    pub fn msg_sender(_self: Self) -> Option<AztecAddress> {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        let maybe_msg_sender = unsafe { sender() };\n        if maybe_msg_sender == NULL_MSG_SENDER_CONTRACT_ADDRESS {\n            Option::none()\n        } else {\n            Option::some(maybe_msg_sender)\n        }\n    }\n\n    /// \"Unsafe\" versus calling `context.msg_sender()`, because it doesn't\n    /// translate `NULL_MSG_SENDER_CONTRACT_ADDRESS` as\n    /// `Option<AztecAddress>::none`.\n    /// Used by some internal aztecnr functions.\n    pub fn msg_sender_unsafe(_self: Self) -> AztecAddress {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            sender()\n        }\n    }\n\n    /// Returns the function selector of the currently-executing function.\n    ///\n    /// This is similar to `msg.sig` in Solidity, returning the first 4\n    /// bytes of the function signature.\n    ///\n    /// # Returns\n    /// * `FunctionSelector` - The 4-byte function identifier\n    ///\n    /// # Advanced\n    /// * Extracted from the first element of calldata\n    /// * Used internally for function dispatch in the AVM\n    ///\n    pub fn selector(_self: Self) -> FunctionSelector {\n        // The selector is the first element of the calldata when calling a public function through dispatch.\n        // Safety: AVM opcodes are constrained by the AVM itself\n        let raw_selector: [Field; 1] = unsafe { calldata_copy(0, 1) };\n        FunctionSelector::from_field(raw_selector[0])\n    }\n\n    /// Returns the hash of the arguments passed to the current function.\n    ///\n    /// Very low-level function: The #[external(\"public\")] macro uses this internally.\n    /// Smart contract developers typically won't need to access this\n    /// directly as arguments are automatically made available.\n    ///\n    /// # Returns\n    /// * `Field` - Hash of the function arguments\n    ///\n    pub fn get_args_hash(mut self) -> Field {\n        if !self.args_hash.is_some() {\n            self.args_hash = Option::some((self.compute_args_hash)());\n        }\n\n        self.args_hash.unwrap_unchecked()\n    }\n\n    /// Returns the \"transaction fee\" for the current transaction.\n    /// This is the final tx fee that will be deducted from the fee_payer's\n    /// \"fee-juice\" balance (in the protocol's Base Rollup circuit).\n    ///\n    /// # Returns\n    /// * `Field` - The actual, final cost of the transaction, taking into account:\n    ///             the actual gas used during the setup and app-logic phases,\n    ///             and the fixed amount of gas that's been allocated by the user\n    ///             for the teardown phase.\n    ///             I.e. effectiveL2FeePerGas * l2GasUsed + effectiveDAFeePerGas * daGasUsed\n    ///\n    /// This will return `0` during the \"setup\" and \"app-logic\" phases of\n    /// tx execution (because the final tx fee is not known at that time).\n    /// This will only return a nonzero value during the \"teardown\" phase of\n    /// execution, where the final tx fee can actually be computed.\n    ///\n    /// Regardless of _when_ this function is called during the teardown phase,\n    /// it will always return the same final tx fee value. The teardown phase\n    /// does not consume a variable amount of gas: it always consumes a\n    /// pre-allocated amount of gas, as specified by the user when they generate\n    /// their tx.\n    ///\n    pub fn transaction_fee(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            transaction_fee()\n        }\n    }\n\n    /// Returns the chain ID of the current network.\n    ///\n    /// This is similar to `block.chainid` in Solidity. Returns the unique\n    /// identifier for the blockchain network this transaction is executing on.\n    ///\n    /// Helps prevent cross-chain replay attacks. Useful if implementing\n    /// multi-chain contract logic.\n    ///\n    /// # Returns\n    /// * `Field` - The chain ID as a field element\n    ///\n    pub fn chain_id(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            chain_id()\n        }\n    }\n\n    /// Returns the Aztec protocol version that this transaction is executing\n    /// under. Different versions may have different rules, opcodes, or\n    /// cryptographic primitives.\n    ///\n    /// This is similar to how Ethereum has different EVM versions.\n    ///\n    /// Useful for forward/backward compatibility checks\n    ///\n    /// Not to be confused with contract versions; this is the protocol version.\n    ///\n    /// # Returns\n    /// * `Field` - The protocol version as a field element\n    ///\n    pub fn version(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            version()\n        }\n    }\n    /// Returns the current block number.\n    ///\n    /// This is similar to `block.number` in Solidity.\n    ///\n    /// Note: the current block number is only available within a public function\n    /// (as opposed to a private function).\n    ///\n    /// Note: the time intervals between blocks should not be relied upon as\n    /// being consistent:\n    /// - Timestamps of blocks fall within a range, rather than at exact regular\n    ///   intervals.\n    /// - Slots can be missed.\n    /// - Protocol upgrades can completely change the intervals between blocks\n    ///   (and indeed the current roadmap plans to reduce the time between\n    ///   blocks, eventually).\n    /// Use `context.timestamp()` for more-reliable time-based logic.\n    ///\n    /// # Returns\n    /// * `u32` - The current block number\n    ///\n    pub fn block_number(_self: Self) -> u32 {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            block_number()\n        }\n    }\n\n    /// Returns the timestamp of the current block.\n    ///\n    /// This is similar to `block.timestamp` in Solidity.\n    ///\n    /// All functions of all transactions in a block share the exact same\n    /// timestamp (even though technically each transaction is executed\n    /// one-after-the-other).\n    ///\n    /// Important note: Timestamps of Aztec blocks are not at reliably-fixed\n    /// intervals. The proposer of the block has some flexibility to choose a\n    /// timestamp which is in a valid _range_: Obviously the timestamp of this\n    /// block must be strictly greater than that of the previous block, and must\n    /// must be less than the timestamp of whichever ethereum block the aztec\n    /// block is proposed to. Furthermore, if the timestamp is not deemed close\n    /// enough to the actual current time, the committee of validators will not\n    /// attest to the block.\n    ///\n    /// # Returns\n    /// * `u64` - Unix timestamp in seconds\n    ///\n    pub fn timestamp(_self: Self) -> u64 {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            timestamp()\n        }\n    }\n\n    /// Returns the fee per unit of L2 gas for this transaction (aka the \"L2 gas\n    /// price\"), as chosen by the user.\n    ///\n    /// L2 gas covers the cost of executing public functions and handling\n    /// side-effects within the AVM.\n    ///\n    /// # Returns\n    /// * `u128` - Fee per unit of L2 gas\n    ///\n    /// Wallet developers should be mindful that the choice of gas price (which\n    /// is publicly visible) can leak information about the user, e.g.:\n    /// - which wallet software the user is using;\n    /// - the amount of time which has elapsed from the time the user's wallet\n    ///   chose a gas price (at the going rate), to the time of tx submission.\n    ///   This can give clues about the proving time, and hence the nature of\n    ///   the tx.\n    /// - the urgency of the transaction (which is kind of unavoidable, if the\n    ///   tx is indeed urgent).\n    /// - the wealth of the user.\n    /// - the exact user (if the gas price is explicitly chosen by the user to\n    ///   be some unique number like 0.123456789, or their favorite number).\n    /// Wallet devs might wish to consider fuzzing the choice of gas price.\n    ///\n    pub fn base_fee_per_l2_gas(_self: Self) -> u128 {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            base_fee_per_l2_gas()\n        }\n    }\n\n    /// Returns the fee per unit of DA (Data Availability) gas (aka the \"DA gas\n    /// price\").\n    ///\n    /// DA gas covers the cost of making transaction data available on L1.\n    ///\n    /// See the warning in `fee_pre_l2_gas` for how gas prices can be leaky.\n    ///\n    /// # Returns\n    /// * `u128` - Fee per unit of DA gas\n    ///\n    pub fn base_fee_per_da_gas(_self: Self) -> u128 {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            base_fee_per_da_gas()\n        }\n    }\n\n    /// Returns the remaining L2 gas available for this transaction.\n    ///\n    /// Different AVM opcodes consume different amounts of gas.\n    ///\n    /// # Returns\n    /// * `u32` - Remaining L2 gas units\n    ///\n    pub fn l2_gas_left(_self: Self) -> u32 {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            l2_gas_left()\n        }\n    }\n\n    /// Returns the remaining DA (Data Availability) gas available for this\n    /// transaction.\n    ///\n    /// DA gas is consumed when emitting data that needs to be made available\n    /// on L1, such as public logs or state updates.\n    /// All of the side-effects from the private part of the tx also consume\n    /// DA gas before execution of any public functions even begins.\n    ///\n    /// # Returns\n    /// * `u32` - Remaining DA gas units\n    ///\n    pub fn da_gas_left(_self: Self) -> u32 {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            da_gas_left()\n        }\n    }\n\n    /// Checks if the current execution is within a staticcall context, where\n    /// no state changes or logs are allowed to be emitted (by this function\n    /// or any nested function calls).\n    ///\n    /// # Returns\n    /// * `bool` - True if in staticcall context, false otherwise\n    ///\n    pub fn is_static_call(_self: Self) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { is_static_call() } == 1\n    }\n\n    /// Reads raw field values from public storage.\n    /// Reads N consecutive storage slots starting from the given slot.\n    ///\n    /// Very low-level function. Users should typically use the public state\n    /// variable abstractions to perform reads: PublicMutable & PublicImmutable.\n    ///\n    /// # Arguments\n    /// * `storage_slot` - The starting storage slot to read from\n    ///\n    /// # Returns\n    /// * `[Field; N]` - Array of N field values from consecutive storage slots\n    ///\n    /// # Generic Parameters\n    /// * `N` - the number of consecutive slots to return, starting from the\n    ///         `storage_slot`.\n    ///\n    pub fn raw_storage_read<let N: u32>(_self: Self, storage_slot: Field) -> [Field; N] {\n        let mut out = [0; N];\n        for i in 0..N {\n            // Safety: AVM opcodes are constrained by the AVM itself\n            out[i] = unsafe { storage_read(storage_slot + i as Field) };\n        }\n        out\n    }\n\n    /// Reads a typed value from public storage.\n    ///\n    /// Low-level function. Users should typically use the public state\n    /// variable abstractions to perform reads: PublicMutable & PublicImmutable.\n    ///\n    /// # Arguments\n    /// * `storage_slot` - The storage slot to read from\n    ///\n    /// # Returns\n    /// * `T` - The deserialized value from storage\n    ///\n    /// # Generic Parameters\n    /// * `T` - The type that the caller expects to read from the `storage_slot`.\n    ///\n    pub fn storage_read<T>(self, storage_slot: Field) -> T\n    where\n        T: Packable,\n    {\n        T::unpack(self.raw_storage_read(storage_slot))\n    }\n\n    /// Writes raw field values to public storage.\n    /// Writes to N consecutive storage slots starting from the given slot.\n    ///\n    /// Very low-level function. Users should typically use the public state\n    /// variable abstractions to perform writes: PublicMutable & PublicImmutable.\n    ///\n    /// Public storage writes take effect immediately.\n    ///\n    /// # Arguments\n    /// * `storage_slot` - The starting storage slot to write to\n    /// * `values` - Array of N Fields to write to storage\n    ///\n    pub fn raw_storage_write<let N: u32>(_self: Self, storage_slot: Field, values: [Field; N]) {\n        for i in 0..N {\n            // Safety: AVM opcodes are constrained by the AVM itself\n            unsafe { storage_write(storage_slot + i as Field, values[i]) };\n        }\n    }\n\n    /// Writes a typed value to public storage.\n    ///\n    /// Low-level function. Users should typically use the public state\n    /// variable abstractions to perform writes: PublicMutable & PublicImmutable.\n    ///\n    /// # Arguments\n    /// * `storage_slot` - The storage slot to write to\n    /// * `value` - The typed value to write to storage\n    ///\n    /// # Generic Parameters\n    /// * `T` - The type to write to storage.\n    ///\n    pub fn storage_write<T>(self, storage_slot: Field, value: T)\n    where\n        T: Packable,\n    {\n        self.raw_storage_write(storage_slot, value.pack());\n    }\n}\n\n// TODO: consider putting this oracle code in its own file.\n// Unconstrained opcode wrappers (do not use directly).\nunconstrained fn address() -> AztecAddress {\n    address_opcode()\n}\nunconstrained fn sender() -> AztecAddress {\n    sender_opcode()\n}\nunconstrained fn transaction_fee() -> Field {\n    transaction_fee_opcode()\n}\nunconstrained fn chain_id() -> Field {\n    chain_id_opcode()\n}\nunconstrained fn version() -> Field {\n    version_opcode()\n}\nunconstrained fn block_number() -> u32 {\n    block_number_opcode()\n}\nunconstrained fn timestamp() -> u64 {\n    timestamp_opcode()\n}\nunconstrained fn base_fee_per_l2_gas() -> u128 {\n    base_fee_per_l2_gas_opcode()\n}\nunconstrained fn base_fee_per_da_gas() -> u128 {\n    base_fee_per_da_gas_opcode()\n}\nunconstrained fn l2_gas_left() -> u32 {\n    l2_gas_left_opcode()\n}\nunconstrained fn da_gas_left() -> u32 {\n    da_gas_left_opcode()\n}\nunconstrained fn is_static_call() -> u1 {\n    is_static_call_opcode()\n}\nunconstrained fn note_hash_exists(note_hash: Field, leaf_index: u64) -> u1 {\n    note_hash_exists_opcode(note_hash, leaf_index)\n}\nunconstrained fn emit_note_hash(note_hash: Field) {\n    emit_note_hash_opcode(note_hash)\n}\nunconstrained fn nullifier_exists(nullifier: Field, address: Field) -> u1 {\n    nullifier_exists_opcode(nullifier, address)\n}\nunconstrained fn emit_nullifier(nullifier: Field) {\n    emit_nullifier_opcode(nullifier)\n}\nunconstrained fn emit_public_log(message: [Field]) {\n    emit_public_log_opcode(message)\n}\nunconstrained fn l1_to_l2_msg_exists(msg_hash: Field, msg_leaf_index: u64) -> u1 {\n    l1_to_l2_msg_exists_opcode(msg_hash, msg_leaf_index)\n}\nunconstrained fn send_l2_to_l1_msg(recipient: EthAddress, content: Field) {\n    send_l2_to_l1_msg_opcode(recipient, content)\n}\n\nunconstrained fn call<let N: u32>(\n    l2_gas_allocation: u32,\n    da_gas_allocation: u32,\n    address: AztecAddress,\n    args: [Field; N],\n) {\n    call_opcode(l2_gas_allocation, da_gas_allocation, address, N, args)\n}\n\nunconstrained fn call_static<let N: u32>(\n    l2_gas_allocation: u32,\n    da_gas_allocation: u32,\n    address: AztecAddress,\n    args: [Field; N],\n) {\n    call_static_opcode(l2_gas_allocation, da_gas_allocation, address, N, args)\n}\n\npub unconstrained fn calldata_copy<let N: u32>(cdoffset: u32, copy_size: u32) -> [Field; N] {\n    calldata_copy_opcode(cdoffset, copy_size)\n}\n\n// `success_copy` is placed immediately after the CALL opcode to get the success value\nunconstrained fn success_copy() -> bool {\n    success_copy_opcode()\n}\n\nunconstrained fn returndata_size() -> u32 {\n    returndata_size_opcode()\n}\n\nunconstrained fn returndata_copy(rdoffset: u32, copy_size: u32) -> [Field] {\n    returndata_copy_opcode(rdoffset, copy_size)\n}\n\npub unconstrained fn avm_return(returndata: [Field]) {\n    return_opcode(returndata)\n}\n\n// This opcode reverts using the exact data given. In general it should only be used\n// to do rethrows, where the revert data is the same as the original revert data.\n// For normal reverts, use Noir's `assert` which, on top of reverting, will also add\n// an error selector to the revert data.\nunconstrained fn avm_revert(revertdata: [Field]) {\n    revert_opcode(revertdata)\n}\n\nunconstrained fn storage_read(storage_slot: Field) -> Field {\n    storage_read_opcode(storage_slot)\n}\n\nunconstrained fn storage_write(storage_slot: Field, value: Field) {\n    storage_write_opcode(storage_slot, value);\n}\n\nimpl Empty for PublicContext {\n    fn empty() -> Self {\n        PublicContext::new(|| 0)\n    }\n}\n\n// TODO: consider putting this oracle code in its own file.\n// AVM oracles (opcodes) follow, do not use directly.\n#[oracle(avmOpcodeAddress)]\nunconstrained fn address_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeSender)]\nunconstrained fn sender_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeTransactionFee)]\nunconstrained fn transaction_fee_opcode() -> Field {}\n\n#[oracle(avmOpcodeChainId)]\nunconstrained fn chain_id_opcode() -> Field {}\n\n#[oracle(avmOpcodeVersion)]\nunconstrained fn version_opcode() -> Field {}\n\n#[oracle(avmOpcodeBlockNumber)]\nunconstrained fn block_number_opcode() -> u32 {}\n\n#[oracle(avmOpcodeTimestamp)]\nunconstrained fn timestamp_opcode() -> u64 {}\n\n#[oracle(avmOpcodeBaseFeePerL2Gas)]\nunconstrained fn base_fee_per_l2_gas_opcode() -> u128 {}\n\n#[oracle(avmOpcodeBaseFeePerDaGas)]\nunconstrained fn base_fee_per_da_gas_opcode() -> u128 {}\n\n#[oracle(avmOpcodeL2GasLeft)]\nunconstrained fn l2_gas_left_opcode() -> u32 {}\n\n#[oracle(avmOpcodeDaGasLeft)]\nunconstrained fn da_gas_left_opcode() -> u32 {}\n\n#[oracle(avmOpcodeIsStaticCall)]\nunconstrained fn is_static_call_opcode() -> u1 {}\n\n#[oracle(avmOpcodeNoteHashExists)]\nunconstrained fn note_hash_exists_opcode(note_hash: Field, leaf_index: u64) -> u1 {}\n\n#[oracle(avmOpcodeEmitNoteHash)]\nunconstrained fn emit_note_hash_opcode(note_hash: Field) {}\n\n#[oracle(avmOpcodeNullifierExists)]\nunconstrained fn nullifier_exists_opcode(nullifier: Field, address: Field) -> u1 {}\n\n#[oracle(avmOpcodeEmitNullifier)]\nunconstrained fn emit_nullifier_opcode(nullifier: Field) {}\n\n// TODO(#11124): rename unencrypted to public in avm\n#[oracle(avmOpcodeEmitUnencryptedLog)]\nunconstrained fn emit_public_log_opcode(message: [Field]) {}\n\n#[oracle(avmOpcodeL1ToL2MsgExists)]\nunconstrained fn l1_to_l2_msg_exists_opcode(msg_hash: Field, msg_leaf_index: u64) -> u1 {}\n\n#[oracle(avmOpcodeSendL2ToL1Msg)]\nunconstrained fn send_l2_to_l1_msg_opcode(recipient: EthAddress, content: Field) {}\n\n#[oracle(avmOpcodeCalldataCopy)]\nunconstrained fn calldata_copy_opcode<let N: u32>(cdoffset: u32, copy_size: u32) -> [Field; N] {}\n\n#[oracle(avmOpcodeReturndataSize)]\nunconstrained fn returndata_size_opcode() -> u32 {}\n\n#[oracle(avmOpcodeReturndataCopy)]\nunconstrained fn returndata_copy_opcode(rdoffset: u32, copy_size: u32) -> [Field] {}\n\n#[oracle(avmOpcodeReturn)]\nunconstrained fn return_opcode(returndata: [Field]) {}\n\n// This opcode reverts using the exact data given. In general it should only be used\n// to do rethrows, where the revert data is the same as the original revert data.\n// For normal reverts, use Noir's `assert` which, on top of reverting, will also add\n// an error selector to the revert data.\n#[oracle(avmOpcodeRevert)]\nunconstrained fn revert_opcode(revertdata: [Field]) {}\n\n// While the length parameter might seem unnecessary given that we have N we keep it around because at the AVM bytecode\n// level, we want to support non-comptime-known lengths for such opcodes, even if Noir code will not generally take that\n// route.\n#[oracle(avmOpcodeCall)]\nunconstrained fn call_opcode<let N: u32>(\n    l2_gas_allocation: u32,\n    da_gas_allocation: u32,\n    address: AztecAddress,\n    length: u32,\n    args: [Field; N],\n) {}\n\n// While the length parameter might seem unnecessary given that we have N we keep it around because at the AVM bytecode\n// level, we want to support non-comptime-known lengths for such opcodes, even if Noir code will not generally take that\n// route.\n#[oracle(avmOpcodeStaticCall)]\nunconstrained fn call_static_opcode<let N: u32>(\n    l2_gas_allocation: u32,\n    da_gas_allocation: u32,\n    address: AztecAddress,\n    length: u32,\n    args: [Field; N],\n) {}\n\n#[oracle(avmOpcodeSuccessCopy)]\nunconstrained fn success_copy_opcode() -> bool {}\n\n#[oracle(avmOpcodeStorageRead)]\nunconstrained fn storage_read_opcode(storage_slot: Field) -> Field {}\n\n#[oracle(avmOpcodeStorageWrite)]\nunconstrained fn storage_write_opcode(storage_slot: Field, value: Field) {}\n","path":"/home/filip/nargo/github.com/AztecProtocol/aztec-packages/v3.0.1-rc.1/noir-projects/aztec-nr/aztec/src/context/public_context.nr"},"72":{"source":"use crate::oracle::{execution::get_utility_context, storage::storage_read};\nuse protocol_types::{address::AztecAddress, traits::Packable};\n\n// If you'll modify this struct don't forget to update utility_context.ts as well.\npub struct UtilityContext {\n    block_number: u32,\n    timestamp: u64,\n    contract_address: AztecAddress,\n    version: Field,\n    chain_id: Field,\n}\n\nimpl UtilityContext {\n    pub unconstrained fn new() -> Self {\n        get_utility_context()\n    }\n\n    pub unconstrained fn at(contract_address: AztecAddress) -> Self {\n        // We get a context with default contract address, and then we construct the final context with the provided\n        // contract address.\n        let default_context = get_utility_context();\n\n        Self {\n            block_number: default_context.block_number,\n            timestamp: default_context.timestamp,\n            contract_address,\n            version: default_context.version,\n            chain_id: default_context.chain_id,\n        }\n    }\n\n    pub unconstrained fn at_historical(contract_address: AztecAddress, block_number: u32) -> Self {\n        // We get a context with default contract address and block number, and then we construct the final context\n        // with the provided contract address and block number.\n        let default_context = get_utility_context();\n\n        Self {\n            block_number,\n            timestamp: default_context.timestamp,\n            contract_address,\n            version: default_context.version,\n            chain_id: default_context.chain_id,\n        }\n    }\n\n    pub fn block_number(self) -> u32 {\n        self.block_number\n    }\n\n    pub fn timestamp(self) -> u64 {\n        self.timestamp\n    }\n\n    pub fn this_address(self) -> AztecAddress {\n        self.contract_address\n    }\n\n    pub fn version(self) -> Field {\n        self.version\n    }\n\n    pub fn chain_id(self) -> Field {\n        self.chain_id\n    }\n\n    pub unconstrained fn raw_storage_read<let N: u32>(\n        self: Self,\n        storage_slot: Field,\n    ) -> [Field; N] {\n        storage_read(self.this_address(), storage_slot, self.block_number())\n    }\n\n    pub unconstrained fn storage_read<T>(self, storage_slot: Field) -> T\n    where\n        T: Packable,\n    {\n        T::unpack(self.raw_storage_read(storage_slot))\n    }\n}\n","path":"/home/filip/nargo/github.com/AztecProtocol/aztec-packages/v3.0.1-rc.1/noir-projects/aztec-nr/aztec/src/context/utility_context.nr"},"73":{"source":"use crate::{\n    context::{\n        calls::{PrivateCall, PrivateStaticCall, PublicCall, PublicStaticCall},\n        private_context::PrivateContext,\n        public_context::PublicContext,\n        utility_context::UtilityContext,\n    },\n    event::{\n        event_emission::{emit_event_in_private, emit_event_in_public},\n        event_interface::EventInterface,\n        event_message::EventMessage,\n    },\n};\nuse protocol_types::{\n    address::AztecAddress,\n    constants::NULL_MSG_SENDER_CONTRACT_ADDRESS,\n    traits::{Deserialize, Serialize},\n};\n\n/// `ContractSelf` is the core interface for interacting with an Aztec contract's own state and context.\n///\n/// This struct is automatically injected into every #[external(...)] contract function by the Aztec macro system and is\n/// accessible through the `self` variable.\n///\n/// # Usage in Contract Functions\n///\n/// Once injected, you can use `self` to:\n/// - Access storage: `self.storage.balances.at(owner).read()`\n/// - Call contracts: `self.call(Token::at(address).transfer(recipient, amount))`\n/// - Emit events: `self.emit(event).deliver_to(recipient, delivery_mode)` (private) or `self.emit(event)` (public)\n/// - Get the contract address: `self.address`\n/// - Get the caller: `self.msg_sender()`\n/// - Access low-level Aztec.nr APIs through the context: `self.context`\n///\n/// # Example\n///\n/// ```noir\n/// #[external(\"private\")]\n/// fn withdraw(amount: u128, recipient: AztecAddress) {\n///     // Get the caller of this function\n///     let sender = self.msg_sender().unwrap();\n///\n///     // Access storage\n///     let token = self.storage.donation_token.get_note().get_address();\n///\n///     // Call contracts\n///     self.call(Token::at(token).transfer(recipient, amount));\n/// }\n/// ```\n///\n/// # Type Parameters\n///\n/// - `Context`: The execution context type - either `&mut PrivateContext`, `PublicContext`, or `UtilityContext`\n/// - `Storage`: The contract's storage struct (defined with `#[storage]`), or `()` if the contract has no storage\n/// - `CallSelf`: Macro-generated type for calling contract's own non-view functions\n/// - `EnqueueSelf`: Macro-generated type for enqueuing calls to the contract's own non-view functions\n/// - `CallSelfStatic`: Macro-generated type for calling contract's own view functions\n/// - `EnqueueSelfStatic`: Macro-generated type for enqueuing calls to the contract's own view functions\npub struct ContractSelf<Context, Storage, CallSelf, EnqueueSelf, CallSelfStatic, EnqueueSelfStatic, CallInternal> {\n    /// The address of this contract\n    pub address: AztecAddress,\n    /// The contract's storage instance, representing the struct to which the `#[storage]` macro was applied in your\n    /// contract. If the contract has no storage, the type of this will be `()`.\n    ///\n    /// This storage instance is specialized for the current execution context (private, public, or utility) and\n    /// provides access to the contract's state variables. Each state variable accepts the context as a generic\n    /// parameter, which determines its available functionality. For example, a PublicImmutable variable can be read\n    /// from any context (public, private, or utility) but can only be written to from public contexts.\n    ///\n    /// # Developer Note\n    /// If you've arrived here while trying to access your contract's storage while the `Storage` generic type is set to\n    /// unit type `()`, it means you haven't yet defined a Storage struct using the #[storage] macro in your contract.\n    /// For guidance on setting this up, please refer to our docs:\n    /// https://docs.aztec.network/developers/docs/guides/smart_contracts/storage\n    pub storage: Storage,\n    /// The execution context whose type is determined by the #[external(...)] attribute of the contract function based\n    /// on the external function type (private, public, or utility).\n    pub context: Context,\n\n    /// Provides type-safe methods for calling this contract's own non-view functions.\n    ///\n    /// In private and public contexts this will be a struct with appropriate methods;\n    /// in utility context it will be the unit type `()`.\n    ///\n    /// Example API:\n    /// ```noir\n    /// self.call_self.some_private_function(args)\n    /// ```\n    pub call_self: CallSelf,\n    /// Provides type-safe methods for enqueuing calls to this contract's own non-view functions.\n    ///\n    /// In private context this will be a struct with appropriate methods;\n    /// in public and utility contexts it will be the unit type `()`.\n    ///\n    /// Example API:\n    /// ```noir\n    /// self.enqueue_self.some_public_function(args)\n    /// ```\n    pub enqueue_self: EnqueueSelf,\n    /// Provides type-safe methods for calling this contract's own view functions.\n    ///\n    /// In private and public contexts this will be a struct with appropriate methods;\n    /// in utility context it will be the unit type `()`.\n    ///\n    /// Example API:\n    /// ```noir\n    /// self.call_self_static.some_view_function(args)\n    /// ```\n    pub call_self_static: CallSelfStatic,\n    /// Provides type-safe methods for enqueuing calls to this contract's own view functions.\n    ///\n    /// In private context this will be a struct with appropriate methods;\n    /// in public and utility contexts it will be the unit type `()`.\n    ///\n    /// Example API:\n    /// ```noir\n    /// self.enqueue_self_static.some_public_view_function(args)\n    /// ```\n    pub enqueue_self_static: EnqueueSelfStatic,\n    /// Provides type-safe methods for calling internal functions.\n    ///\n    /// In private and public contexts this will be a struct with appropriate methods;\n    /// in utility context it will be the unit type `()`.\n    ///\n    /// Example API:\n    /// ```noir\n    /// self.internal.some_internal_function(args)\n    /// ```\n    pub internal: CallInternal,\n}\n\n/// Implementation for `ContractSelf` in private execution contexts.\n///\n/// This implementation is used when a contract function is marked with `#[external(\"private\")]`.\n/// Private functions execute client-side and generate zero-knowledge proofs of their execution.\nimpl<Storage, CallSelf, EnqueueSelf, CallSelfStatic, EnqueueSelfStatic, CallInternal> ContractSelf<&mut PrivateContext, Storage, CallSelf, EnqueueSelf, CallSelfStatic, EnqueueSelfStatic, CallInternal> {\n    /// Creates a new `ContractSelf` instance for a private function.\n    ///\n    /// This constructor is called automatically by the macro system and should not be called directly.\n    pub fn new_private(\n        context: &mut PrivateContext,\n        storage: Storage,\n        call_self: CallSelf,\n        enqueue_self: EnqueueSelf,\n        call_self_static: CallSelfStatic,\n        enqueue_self_static: EnqueueSelfStatic,\n        internal: CallInternal,\n    ) -> Self {\n        Self {\n            context,\n            storage,\n            address: context.this_address(),\n            call_self,\n            enqueue_self,\n            call_self_static,\n            enqueue_self_static,\n            internal,\n        }\n    }\n\n    /// Returns the contract address that initiated this function call. This is similar to `msg.sender` in Solidity.\n    ///\n    /// Important Note: Since Aztec doesn't have a concept of an EoA ( Externally-owned Account), the msg_sender is\n    /// \"null\" for the first function call of every transaction. The first function call of a tx is likely to be a call\n    /// to the user's account contract, so this quirk will most often be handled by account contract developers.\n    ///\n    /// # Returns\n    /// * `Option<AztecAddress>` - The address of the smart contract that called this function (be it an app contract or\n    ///   a user's account contract). Returns `Option<AztecAddress>::none` for the first function call of the tx. No\n    ///   other _private_ function calls in the tx will have a `none` msg_sender, but _public_ function calls might (see\n    ///   the PublicContext).\n    ///\n    pub fn msg_sender(self) -> Option<AztecAddress> {\n        let maybe_msg_sender = self.context.msg_sender_unsafe();\n        if maybe_msg_sender == NULL_MSG_SENDER_CONTRACT_ADDRESS {\n            Option::none()\n        } else {\n            Option::some(maybe_msg_sender)\n        }\n    }\n\n    /// Emits an event privately.\n    ///\n    /// Unlike public events, private events do not reveal their contents publicly. They instead create an\n    /// [EventMessage] containing the private event information, which **MUST** be delivered to a recipient via\n    /// [EventMessage::deliver_to] in order for them to learn about the event. Multiple recipients can have the same\n    /// message be delivered to them.\n    ///\n    /// # Example\n    /// ```noir\n    /// #[event]\n    /// struct Transfer { from: AztecAddress, to: AztecAddress, amount: u128 }\n    ///\n    /// #[external(\"private\")]\n    /// fn transfer(to: AztecAddress, amount: u128) {\n    ///     let from = self.msg_sender().unwrap();\n    ///\n    ///     let message: EventMessage = self.emit(Transfer { from, to, amount });\n    ///     message.deliver_to(from, MessageDelivery.UNCONSTRAINED_OFFCHAIN);\n    ///     message.deliver_to(to, MessageDelivery.CONSTRAINED_ONCHAIN);\n    /// }\n    /// ```\n    ///\n    /// # Cost\n    ///\n    /// Private event emission always results in the creation of a nullifer, which acts as a commitment to the event and\n    /// is used by third parties to verify its authenticity. See [EventMessage::deliver_to] for the costs associated to\n    /// delivery.\n    ///\n    /// # Privacy\n    ///\n    /// The nullifier created when emitting a private event leaks nothing about the content of the event - it's a\n    /// commitment that includes a random value, so even with full knowledge of the event preimage determining if an\n    /// event was emitted or not requires brute-forcing the entire `Field` space.\n    pub fn emit<Event>(&mut self, event: Event) -> EventMessage<Event>\n    where\n        Event: EventInterface + Serialize,\n    {\n        emit_event_in_private(self.context, event)\n    }\n\n    /// Makes a call to the private function defined by the `call` parameter.\n    ///\n    /// # Arguments\n    /// * `call` - The object representing the private function to invoke.\n    ///\n    /// # Returns\n    /// * `T` - Whatever data the called function has returned.\n    ///\n    /// # Example\n    /// ```noir\n    /// self.call(Token::at(address).transfer_in_private(recipient, amount));\n    /// ```\n    ///\n    /// This enables contracts to interact with each other while maintaining\n    /// privacy. This \"composability\" of private contract functions is a key\n    /// feature of the Aztec network.\n    ///\n    /// If a user's transaction includes multiple private function calls, then\n    /// by the design of Aztec, the following information will remain private[1]:\n    /// - The function selectors and contract addresses of all private function\n    ///   calls will remain private, so an observer of the public mempool will\n    ///   not be able to look at a tx and deduce which private functions have\n    ///   been executed.\n    /// - The arguments and return values of all private function calls will\n    ///   remain private.\n    /// - The person who initiated the tx will remain private.\n    /// - The notes and nullifiers and private logs that are emitted by all\n    ///   private function calls will (if designed well) not leak any user\n    ///   secrets, nor leak which functions have been executed.\n    ///\n    /// [1] Caveats: Some of these privacy guarantees depend on how app\n    /// developers design their smart contracts. Some actions _can_ leak\n    /// information, such as:\n    /// - Calling an internal public function.\n    /// - Calling a public function and not setting msg_sender to Option::none\n    ///   (see https://github.com/AztecProtocol/aztec-packages/pull/16433)\n    /// - Calling any public function will always leak details about the nature\n    ///   of the transaction, so devs should be careful in their contract\n    ///   designs. If it can be done in a private function, then that will give\n    ///   the best privacy.\n    /// - Not padding the side-effects of a tx to some standardized, uniform\n    ///   size. The kernel circuits can take hints to pad side-effects, so a\n    ///   wallet should be able to request for a particular amount of padding.\n    ///   Wallets should ideally agree on some standard.\n    ///   - Padding should include:\n    ///     - Padding the lengths of note & nullifier arrays\n    ///     - Padding private logs with random fields, up to some standardized\n    ///       size.\n    /// See also: https://docs.aztec.network/developers/resources/considerations/privacy_considerations\n    ///\n    /// # Advanced\n    /// * The call is added to the private call stack and executed by kernel\n    ///   circuits after this function completes\n    /// * The called function can modify its own contract's private state\n    /// * Side effects from the called function are included in this transaction\n    /// * The call inherits the current transaction's context and gas limits\n    ///\n    pub fn call<let M: u32, let N: u32, T>(&mut self, call: PrivateCall<M, N, T>) -> T\n    where\n        T: Deserialize,\n    {\n        call.call(self.context)\n    }\n\n    /// Makes a read-only call to the private function defined by the `call` parameter.\n    ///\n    /// This is similar to Solidity's `staticcall`. The called function\n    /// cannot modify state, emit L2->L1 messages, nor emit events. Any nested\n    /// calls are constrained to also be static calls.\n    ///\n    /// # Arguments\n    /// * `call` - The object representing the read-only private function to invoke.\n    ///\n    /// # Returns\n    /// * `T` - Whatever data the called function has returned.\n    ///\n    /// # Example\n    /// ```noir\n    /// self.view(Token::at(address).balance_of_private(recipient));\n    /// ```\n    pub fn view<let M: u32, let N: u32, T>(&mut self, call: PrivateStaticCall<M, N, T>) -> T\n    where\n        T: Deserialize,\n    {\n        call.view(self.context)\n    }\n\n    /// Enqueues a call to the public function defined by the `call` parameter,\n    /// to be executed later.\n    ///\n    /// Unlike private functions which execute immediately on the user's device,\n    /// public function calls are \"enqueued\" and executed some time later by a\n    /// block proposer.\n    ///\n    /// This means a public function cannot return any values back to a private\n    /// function, because by the time the public function is being executed,\n    /// the private function which called it has already completed execution.\n    /// (In fact, the private function has been executed and proven, along with\n    /// all other private function calls of the user's tx. A single proof of the\n    /// tx has been submitted to the Aztec network, and some time later a\n    /// proposer has picked the tx up from the mempool and begun executing all\n    /// of the enqueued public functions).\n    ///\n    /// # Privacy warning\n    /// Enqueueing a public function call is an inherently leaky action.\n    /// Many interesting applications will require some interaction with public\n    /// state, but smart contract developers should try to use public function\n    /// calls sparingly, and carefully.\n    /// _Internal_ public function calls are especially leaky, because they\n    /// completely leak which private contract made the call.\n    /// See also: https://docs.aztec.network/developers/resources/considerations/privacy_considerations\n    ///\n    /// # Arguments\n    /// * `call` - The interface representing the public function to enqueue.\n    ///\n    /// TODO(F-131): We should drop T from here because it is strange as there\n    /// is no return value. The PublicCall type seems to be defined\n    /// incorrectly.\n    pub fn enqueue<let M: u32, let N: u32, T>(&mut self, call: PublicCall<M, N, T>)\n    where\n        T: Deserialize,\n    {\n        call.enqueue(self.context)\n    }\n\n    /// Enqueues a read-only call to the public function defined by the `call` parameter.\n    ///\n    /// This is similar to Solidity's `staticcall`. The called function\n    /// cannot modify state, emit L2->L1 messages, nor emit events. Any nested\n    /// calls are constrained to also be static calls.\n    ///\n    /// # Arguments\n    /// * `call` - The object representing the read-only public function to enqueue.\n    ///\n    /// # Example\n    /// ```noir\n    /// self.enqueue_view(MyContract::at(address).assert_timestamp_less_than(timestamp));\n    /// ```\n    ///\n    /// TODO(F-131): We should drop T from here because it is strange as there\n    /// is no return value. The PublicCall type seems to be defined\n    /// incorrectly.\n    pub fn enqueue_view<let M: u32, let N: u32, T>(&mut self, call: PublicStaticCall<M, N, T>)\n    where\n        T: Deserialize,\n    {\n        call.enqueue_view(self.context)\n    }\n\n    /// Enqueues a call to the public function defined by the `call` parameter,\n    /// to be executed later.\n    ///\n    /// As per `enqueue`, but hides this calling contract's address from the\n    /// target public function.\n    /// This means the origin of the call (msg_sender) will not be publicly\n    /// visible to any blockchain observers, nor to the target public function.\n    /// When the target public function reads `context.msg_sender()` it will\n    /// receive an `Option<AztecAddress>::none`.\n    ///\n    /// NOTES:\n    /// - Not all public functions will accept a msg_sender of \"none\". Many\n    ///   public functions will require that msg_sender is \"some\" and will\n    ///   revert otherwise. Therefore, if using `enqueue_incognito`, you must\n    ///   understand whether the function you're calling will accept a\n    ///   msg_sender of \"none\".\n    ///   Lots of public bookkeeping patterns rely on knowing which address made\n    ///   the call, so as to ascribe state against the caller's address.\n    ///   (There are patterns whereby bookkeeping could instead be done in\n    ///   private-land).\n    /// - If you are enqueueing a call to an _internal_ public function (i.e.\n    ///   a public function that will only accept calls from other functions\n    ///   of its own contract), then by definition a call to it cannot possibly\n    ///   be \"incognito\": the msg_sender must be its own address, and indeed the\n    ///   called public function will assert this. Tl;dr this is not usable for\n    ///   enqueued internal public calls.\n    ///\n    /// # Arguments\n    /// * `call` - The object representing the public function to enqueue.\n    ///\n    /// # Example\n    /// ```noir\n    /// self.enqueue_incognito(Token::at(address).increase_total_supply_by(amount));\n    /// ```\n    ///\n    /// Advanced:\n    /// - The kernel circuits will permit _any_ private function to set the\n    ///   msg_sender field of any enqueued public function call to\n    ///   NULL_MSG_SENDER_CONTRACT_ADDRESS.\n    /// - When the called public function calls `PublicContext::msg_sender()`,\n    ///   aztec-nr will translate NULL_MSG_SENDER_CONTRACT_ADDRESS into\n    ///   `Option<AztecAddress>::none` for familiarity to devs.\n    ///\n    /// TODO(F-131): We should drop T from here because it is strange as there\n    /// is no return value. The PublicCall type seems to be defined\n    /// incorrectly.\n    pub fn enqueue_incognito<let M: u32, let N: u32, T>(&mut self, call: PublicCall<M, N, T>)\n    where\n        T: Deserialize,\n    {\n        call.enqueue_incognito(self.context)\n    }\n\n    /// Enqueues a read-only call to the public function defined by the `call` parameter.\n    ///\n    /// As per `enqueue_view`, but hides this calling contract's address from\n    /// the target public function.\n    ///\n    /// See `enqueue_incognito` for more details relating to hiding msg_sender.\n    ///\n    /// # Arguments\n    /// * `call` - The object representing the read-only public function to enqueue.\n    ///\n    /// # Example\n    /// ```noir\n    /// self.enqueue_view_incognito(MyContract::at(address).assert_timestamp_less_than(timestamp));\n    /// ```\n    ///\n    /// TODO(F-131): We should drop T from here because it is strange as there\n    /// is no return value. The PublicCall type seems to be defined\n    /// incorrectly.\n    pub fn enqueue_view_incognito<let M: u32, let N: u32, T>(\n        &mut self,\n        call: PublicStaticCall<M, N, T>,\n    )\n    where\n        T: Deserialize,\n    {\n        call.enqueue_view_incognito(self.context)\n    }\n\n    /// Enqueues a call to the public function defined by the `call` parameter,\n    /// and designates it to be the teardown function for this tx. Only one teardown\n    /// function call can be made by a tx.\n    ///\n    /// Niche function: Only wallet developers and paymaster contract developers\n    /// (aka Fee-payment contracts) will need to make use of this function.\n    ///\n    /// Aztec supports a three-phase execution model: setup, app logic, teardown.\n    /// The phases exist to enable a fee payer to take on the risk of paying\n    /// a transaction fee, safe in the knowledge that their payment (in whatever\n    /// token or method the user chooses) will succeed, regardless of whether\n    /// the app logic will succeed. The \"setup\" phase ensures the fee payer\n    /// has sufficient balance to pay the proposer their fees.\n    /// The teardown phase is primarily intended to: calculate exactly\n    /// how much the user owes, based on gas consumption, and refund the user\n    /// any change.\n    ///\n    /// Note: in some cases, the cost of refunding the user (i.e. DA costs of\n    /// tx side-effects) might exceed the refund amount. For app logic with\n    /// fairly stable and predictable gas consumption, a material refund amount\n    /// is unlikely. For app logic with unpredictable gas consumption, a\n    /// refund might be important to the user (e.g. if a hefty function reverts\n    /// very early). Wallet/FPC/Paymaster developers should be mindful of this.\n    ///\n    /// See `enqueue` for more information about enqueuing public function calls.\n    ///\n    /// # Arguments\n    /// * `call` - The object representing the public function to designate as teardown.\n    ///\n    /// TODO(F-131): We should drop T from here because it is strange as there\n    /// is no return value. The PublicCall type seems to be defined\n    /// incorrectly.\n    pub fn set_as_teardown<let M: u32, let N: u32, T>(&mut self, call: PublicCall<M, N, T>)\n    where\n        T: Deserialize,\n    {\n        call.set_as_teardown(self.context)\n    }\n\n    /// Enqueues a call to the public function defined by the `call` parameter,\n    /// and designates it to be the teardown function for this tx. Only one teardown\n    /// function call can be made by a tx.\n    ///\n    /// As per `set_as_teardown`, but hides this calling contract's address from\n    /// the target public function.\n    ///\n    /// See `enqueue_incognito` for more details relating to hiding msg_sender.\n    ///\n    /// TODO(F-131): We should drop T from here because it is strange as there\n    /// is no return value. The PublicCall type seems to be defined\n    /// incorrectly.\n    pub fn set_as_teardown_incognito<let M: u32, let N: u32, T>(\n        &mut self,\n        call: PublicCall<M, N, T>,\n    )\n    where\n        T: Deserialize,\n    {\n        call.set_as_teardown_incognito(self.context)\n    }\n}\n\n/// Implementation for `ContractSelf` in public execution contexts.\n///\n/// This implementation is used when a contract function is marked with `#[external(\"public\")]`.\n/// Public functions are executed by the sequencer in the Aztec Virtual Machine (AVM) and can work only with public\n/// state.\nimpl<Storage, CallSelf, CallSelfStatic, CallInternal> ContractSelf<PublicContext, Storage, CallSelf, (), CallSelfStatic, (), CallInternal> {\n    /// Creates a new `ContractSelf` instance for a public function.\n    ///\n    /// This constructor is called automatically by the macro system and should not be called directly.\n    pub fn new_public(\n        context: PublicContext,\n        storage: Storage,\n        call_self: CallSelf,\n        call_self_static: CallSelfStatic,\n        internal: CallInternal,\n    ) -> Self {\n        Self {\n            context,\n            storage,\n            address: context.this_address(),\n            call_self,\n            enqueue_self: (),\n            call_self_static,\n            enqueue_self_static: (),\n            internal,\n        }\n    }\n\n    /// Returns the contract address that initiated this function call.\n    ///\n    /// This is similar to `msg.sender` in Solidity (hence the name).\n    ///\n    /// Important Note: If the calling function is a _private_ function, then it had the option of hiding its address\n    /// when enqueuing this public function call. In such cases, this `context.msg_sender()` method will return\n    /// `Option<AztecAddress>::none`. If the calling function is a _public_ function, it will always return an\n    /// `Option<AztecAddress>::some` (i.e. a non-null value).\n    ///\n    /// # Returns\n    /// * `Option<AztecAddress>` - The address of the smart contract that called this function (be it an app contract or\n    ///   a user's account contract).\n    ///\n    /// # Advanced\n    /// * Value is provided by the AVM sender opcode\n    /// * In nested calls, this is the immediate caller, not the original transaction sender\n    ///\n    pub fn msg_sender(self: Self) -> Option<AztecAddress> {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        let maybe_msg_sender = self.context.msg_sender_unsafe();\n        if maybe_msg_sender == NULL_MSG_SENDER_CONTRACT_ADDRESS {\n            Option::none()\n        } else {\n            Option::some(maybe_msg_sender)\n        }\n    }\n\n    /// Emits an event publicly.\n    ///\n    /// Public events are emitted as plaintext and are therefore visible to everyone. This is is the same as Solidity\n    /// events on EVM chains.\n    ///\n    /// Unlike private events, they don't require delivery of an event message.\n    ///\n    /// # Example\n    /// ```noir\n    /// #[event]\n    /// struct Update { value: Field }\n    ///\n    /// #[external(\"public\")]\n    /// fn publish_update(value: Field) {\n    ///     self.emit(Update { value });\n    /// }\n    /// ```\n    ///\n    /// # Cost\n    ///\n    /// Public event emission is achieved by emitting public transaction logs. A total of `N+1` fields are emitted,\n    /// where `N` is the serialization length of the event.\n    pub fn emit<Event>(&mut self, event: Event)\n    where\n        Event: EventInterface + Serialize,\n    {\n        emit_event_in_public(self.context, event);\n    }\n\n    /// Makes the call to the public function defined by the `call` parameter.\n    ///\n    /// Will revert if the called function reverts or runs out of gas.\n    ///\n    /// # Arguments\n    /// * `call` - The object representing the public function to invoke.\n    ///\n    /// # Returns\n    /// * `T` - Whatever data the called function has returned.\n    ///\n    /// # Example\n    /// ```noir\n    /// self.call(Token::at(address).transfer_in_public(recipient, amount));\n    /// ```\n    ///\n    pub unconstrained fn call<let M: u32, let N: u32, T>(self, call: PublicCall<M, N, T>) -> T\n    where\n        T: Deserialize,\n    {\n        call.call(self.context)\n    }\n\n    /// Makes the read-only call to the public function defined by the `call` parameter.\n    ///\n    /// This is similar to Solidity's `staticcall`. The called function\n    /// cannot modify state or emit events. Any nested calls are constrained to\n    /// also be static calls.\n    ///\n    /// Will revert if the called function reverts or runs out of gas.\n    ///\n    /// # Arguments\n    /// * `call` - The object representing the read-only public function to invoke.\n    ///\n    /// # Returns\n    /// * `T` - Whatever data the called function has returned.\n    ///\n    /// # Example\n    /// ```noir\n    /// self.view(Token::at(address).balance_of_public(recipient));\n    /// ```\n    ///\n    pub unconstrained fn view<let M: u32, let N: u32, T>(self, call: PublicStaticCall<M, N, T>) -> T\n    where\n        T: Deserialize,\n    {\n        call.view(self.context)\n    }\n}\n\n/// Implementation for `ContractSelf` in utility execution contexts.\n///\n/// This implementation is used when a contract function is marked with `#[external(\"utility\")]`.\n/// Utility functions are unconstrained functions that can read private state for offchain queries.\n/// They are typically used for view functions that need to access private notes (e.g. a Token's balance_of function).\nimpl<Storage> ContractSelf<UtilityContext, Storage, (), (), (), (), ()> {\n    /// Creates a new `ContractSelf` instance for a utility function.\n    ///\n    /// This constructor is called automatically by the macro system and should not be called directly.\n    pub fn new_utility(context: UtilityContext, storage: Storage) -> Self {\n        Self {\n            context,\n            storage,\n            address: context.this_address(),\n            call_self: (),\n            enqueue_self: (),\n            call_self_static: (),\n            enqueue_self_static: (),\n            internal: (),\n        }\n    }\n}\n","path":"/home/filip/nargo/github.com/AztecProtocol/aztec-packages/v3.0.1-rc.1/noir-projects/aztec-nr/aztec/src/contract_self.nr"},"77":{"source":"use dep::protocol_types::{\n    hash::poseidon2_hash_bytes,\n    traits::{Deserialize, Empty, FromField, Serialize, ToField},\n};\n\n#[derive(Deserialize, Eq, Serialize)]\npub struct EventSelector {\n    // 1st 4-bytes (big-endian leftmost) of abi-encoding of an event.\n    inner: u32,\n}\n\nimpl FromField for EventSelector {\n    fn from_field(field: Field) -> Self {\n        Self { inner: field as u32 }\n    }\n}\n\nimpl ToField for EventSelector {\n    fn to_field(self) -> Field {\n        self.inner as Field\n    }\n}\n\nimpl Empty for EventSelector {\n    fn empty() -> Self {\n        Self { inner: 0 as u32 }\n    }\n}\n\nimpl EventSelector {\n    pub fn from_u32(value: u32) -> Self {\n        Self { inner: value }\n    }\n\n    pub fn from_signature<let N: u32>(signature: str<N>) -> Self {\n        let bytes = signature.as_bytes();\n        let hash = poseidon2_hash_bytes(bytes);\n\n        // `hash` is automatically truncated to fit within 32 bits.\n        EventSelector::from_field(hash)\n    }\n\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n}\n","path":"/home/filip/nargo/github.com/AztecProtocol/aztec-packages/v3.0.1-rc.1/noir-projects/aztec-nr/aztec/src/event/event_selector.nr"},"79":{"source":"use dep::protocol_types::{\n    address::{AztecAddress, EthAddress},\n    constants::{\n        GENERATOR_INDEX__FUNCTION_ARGS, GENERATOR_INDEX__MESSAGE_NULLIFIER,\n        GENERATOR_INDEX__PUBLIC_BYTECODE, GENERATOR_INDEX__PUBLIC_CALLDATA,\n        GENERATOR_INDEX__SECRET_HASH, MAX_PACKED_PUBLIC_BYTECODE_SIZE_IN_FIELDS,\n    },\n    hash::{poseidon2_hash_subarray, poseidon2_hash_with_separator, sha256_to_field},\n    point::Point,\n    traits::ToField,\n};\n\npub use dep::protocol_types::hash::{compute_siloed_nullifier, pedersen_hash};\n\npub fn pedersen_commitment<let N: u32>(inputs: [Field; N], hash_index: u32) -> Point {\n    std::hash::pedersen_commitment_with_separator(inputs, hash_index)\n}\n\npub fn compute_secret_hash(secret: Field) -> Field {\n    poseidon2_hash_with_separator([secret], GENERATOR_INDEX__SECRET_HASH)\n}\n\npub fn compute_l1_to_l2_message_hash(\n    sender: EthAddress,\n    chain_id: Field,\n    recipient: AztecAddress,\n    version: Field,\n    content: Field,\n    secret_hash: Field,\n    leaf_index: Field,\n) -> Field {\n    let mut hash_bytes = [0 as u8; 224];\n    let sender_bytes: [u8; 32] = sender.to_field().to_be_bytes();\n    let chain_id_bytes: [u8; 32] = chain_id.to_be_bytes();\n    let recipient_bytes: [u8; 32] = recipient.to_field().to_be_bytes();\n    let version_bytes: [u8; 32] = version.to_be_bytes();\n    let content_bytes: [u8; 32] = content.to_be_bytes();\n    let secret_hash_bytes: [u8; 32] = secret_hash.to_be_bytes();\n    let leaf_index_bytes: [u8; 32] = leaf_index.to_be_bytes();\n\n    for i in 0..32 {\n        hash_bytes[i] = sender_bytes[i];\n        hash_bytes[i + 32] = chain_id_bytes[i];\n        hash_bytes[i + 64] = recipient_bytes[i];\n        hash_bytes[i + 96] = version_bytes[i];\n        hash_bytes[i + 128] = content_bytes[i];\n        hash_bytes[i + 160] = secret_hash_bytes[i];\n        hash_bytes[i + 192] = leaf_index_bytes[i];\n    }\n\n    sha256_to_field(hash_bytes)\n}\n\n// The nullifier of a l1 to l2 message is the hash of the message salted with the secret\npub fn compute_l1_to_l2_message_nullifier(message_hash: Field, secret: Field) -> Field {\n    poseidon2_hash_with_separator([message_hash, secret], GENERATOR_INDEX__MESSAGE_NULLIFIER)\n}\n\n// Computes the hash of input arguments or return values for private functions, or for authwit creation.\npub fn hash_args<let N: u32>(args: [Field; N]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator(args, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\n// Computes the hash of calldata for public functions.\npub fn hash_calldata_array<let N: u32>(calldata: [Field; N]) -> Field {\n    poseidon2_hash_with_separator(calldata, GENERATOR_INDEX__PUBLIC_CALLDATA)\n}\n\n/**\n * Computes the public bytecode commitment for a contract class.\n * The commitment is `hash([separator, ...bytecode])` where bytecode omits the length prefix present\n * in `packed_bytecode`.\n *\n * @param packed_bytecode - The packed bytecode of the contract class. 0th word is the length in bytes.\n *    packed_bytecode is mutable so that we can avoid copying the array to construct one starting with\n *    separator instead of length.\n * @returns The public bytecode commitment.\n */\npub fn compute_public_bytecode_commitment(\n    mut packed_public_bytecode: [Field; MAX_PACKED_PUBLIC_BYTECODE_SIZE_IN_FIELDS],\n) -> Field {\n    // First field element contains the length of the bytecode\n    let bytecode_length_in_bytes: u32 = packed_public_bytecode[0] as u32;\n    let bytecode_length_in_fields: u32 =\n        (bytecode_length_in_bytes / 31) + (bytecode_length_in_bytes % 31 != 0) as u32;\n    // Don't allow empty public bytecode.\n    // AVM doesn't handle execution of contracts that exist with empty bytecode.\n    assert(bytecode_length_in_fields != 0);\n    assert(bytecode_length_in_fields < MAX_PACKED_PUBLIC_BYTECODE_SIZE_IN_FIELDS);\n\n    // Packed_bytecode's 0th entry is the length. Replace it with separator before hashing.\n    let separator = GENERATOR_INDEX__PUBLIC_BYTECODE.to_field();\n    packed_public_bytecode[0] = separator;\n\n    // `fields_to_hash` is the number of fields from the start of `packed_public_bytecode` that should be included in\n    // the hash. Fields after this length are ignored.\n    // +1 to account for the separator.\n    let num_fields_to_hash = bytecode_length_in_fields + 1;\n\n    poseidon2_hash_subarray(packed_public_bytecode, num_fields_to_hash)\n}\n\n#[test]\nunconstrained fn compute_var_args_hash() {\n    let mut input = [0; 100];\n    for i in 0..100 {\n        input[i] = i as Field;\n    }\n    let hash = hash_args(input);\n    dep::std::println(hash);\n    // Used in yarn-project/stdlib test snapshots:\n    assert(hash == 0x19b0d74feb06ebde19edd85a28986c97063e84b3b351a8b666c7cac963ce655f);\n}\n\n#[test]\nunconstrained fn compute_calldata_hash() {\n    let mut input = [0; 100];\n    for i in 0..input.len() {\n        input[i] = i as Field;\n    }\n    let hash = hash_calldata_array(input);\n    // Used in cpp vm2 tests:\n    assert(hash == 0x191383c9f8964afd3ea8879a03b7dda65d6724773966d18dcf80e452736fc1f3);\n}\n\n#[test]\nunconstrained fn public_bytecode_commitment() {\n    let mut input = [0; MAX_PACKED_PUBLIC_BYTECODE_SIZE_IN_FIELDS];\n    let len = 99;\n    for i in 1..len + 1 {\n        input[i] = i as Field;\n    }\n    input[0] = (len as Field) * 31;\n    let hash = compute_public_bytecode_commitment(input);\n    dep::std::println(hash);\n    // Used in cpp vm2 tests:\n    assert(hash == 0x16d621c3387156ef53754679e7b2c9be8f0bceeb44aa59a74991df3b0b42a0bf);\n}\n","path":"/home/filip/nargo/github.com/AztecProtocol/aztec-packages/v3.0.1-rc.1/noir-projects/aztec-nr/aztec/src/hash.nr"},"100":{"source":"use crate::macros::{\n    calls_generation::{\n        external_functions::{\n            generate_external_function_calls, generate_external_function_self_calls_structs,\n        },\n        internal_functions::generate_call_internal_struct,\n    },\n    dispatch::generate_public_dispatch,\n    internals_functions_generation::{create_fn_abi_exports, process_functions},\n    notes::NOTES,\n    storage::STORAGE_LAYOUT_NAME,\n    utils::{\n        get_trait_impl_method, is_fn_contract_library_method, is_fn_external, is_fn_internal,\n        is_fn_test, module_has_storage,\n    },\n};\n\n/// Marks a contract as an Aztec contract, generating the interfaces for its functions and notes, as well as injecting\n/// the `sync_private_state` utility function.\n/// Note: This is a module annotation, so the returned quote gets injected inside the module (contract) itself.\npub comptime fn aztec(m: Module) -> Quoted {\n    // Functions that don't have #[external(...)], #[contract_library_method], or #[test] are not allowed in contracts.\n    check_each_fn_macroified(m);\n\n    // We generate new functions prefixed with `__aztec_nr_internals__` and we replace the original functions' bodies\n    // with `static_assert(false, ...)` to prevent them from being called directly from within the contract.\n    let functions = process_functions(m);\n\n    // We generate structs and their implementations necessary for convenient functions calls.\n    let interface = generate_contract_interface(m);\n    let self_call_structs = generate_external_function_self_calls_structs(m);\n    let call_internal_struct = generate_call_internal_struct(m);\n\n    // We generate ABI exports for all the external functions in the contract.\n    let fn_abi_exports = create_fn_abi_exports(m);\n\n    // We generate `_compute_note_hash_and_nullifier`, `sync_private_state` and `process_message`\n    // functions only if they are not already implemented. If they are implemented we just insert empty\n    // quotes.\n    let contract_library_method_compute_note_hash_and_nullifier = if !m.functions().any(|f| {\n        f.name() == quote { _compute_note_hash_and_nullifier }\n    }) {\n        generate_contract_library_method_compute_note_hash_and_nullifier()\n    } else {\n        quote {}\n    };\n    let sync_private_state_fn_and_abi_export = if !m.functions().any(|f| {\n        f.name() == quote { sync_private_state }\n    }) {\n        generate_sync_private_state()\n    } else {\n        quote {}\n    };\n\n    let process_message_fn_and_abi_export = if !m.functions().any(|f| {\n        f.name() == quote { process_message }\n    }) {\n        generate_process_message()\n    } else {\n        quote {}\n    };\n    let public_dispatch = generate_public_dispatch(m);\n\n    quote {\n        $interface\n        $self_call_structs\n        $call_internal_struct\n        $functions\n        $fn_abi_exports\n        $contract_library_method_compute_note_hash_and_nullifier\n        $public_dispatch\n        $sync_private_state_fn_and_abi_export\n        $process_message_fn_and_abi_export\n    }\n}\n\ncomptime fn generate_contract_interface(m: Module) -> Quoted {\n    let calls = generate_external_function_calls(m);\n\n    let module_name = m.name();\n\n    let has_storage_layout = module_has_storage(m) & STORAGE_LAYOUT_NAME.get(m).is_some();\n    let storage_layout_getter = if has_storage_layout {\n        let storage_layout_name = STORAGE_LAYOUT_NAME.get(m).unwrap();\n        quote {\n            pub fn storage_layout() -> StorageLayoutFields {\n                $storage_layout_name.fields\n            }\n        }\n    } else {\n        quote {}\n    };\n\n    let library_storage_layout_getter = if has_storage_layout {\n        quote {\n            #[contract_library_method]\n            $storage_layout_getter\n        }\n    } else {\n        quote {}\n    };\n\n    quote {\n        pub struct $module_name {\n            pub target_contract: dep::aztec::protocol_types::address::AztecAddress\n        }\n\n        impl $module_name {\n            $calls\n\n            pub fn at(\n                addr: aztec::protocol_types::address::AztecAddress\n            ) -> Self {\n                Self { target_contract: addr }\n            }\n\n            pub fn interface() -> Self {\n                Self { target_contract: aztec::protocol_types::address::AztecAddress::zero() }\n            }\n\n            $storage_layout_getter\n        }\n\n        #[contract_library_method]\n        pub fn at(\n            addr: aztec::protocol_types::address::AztecAddress\n        ) -> $module_name {\n            $module_name { target_contract: addr }\n        }\n\n        #[contract_library_method]\n        pub fn interface() -> $module_name {\n            $module_name { target_contract: aztec::protocol_types::address::AztecAddress::zero() }\n        }\n\n        $library_storage_layout_getter\n\n    }\n}\n\n/// Generates a contract library method called `_compute_note_hash_and_nullifier` which is used for note\n/// discovery (to create the `aztec::messages::discovery::ComputeNoteHashAndNullifier` function) and to implement the\n/// `compute_note_hash_and_nullifier` unconstrained contract function.\ncomptime fn generate_contract_library_method_compute_note_hash_and_nullifier() -> Quoted {\n    if NOTES.len() > 0 {\n        // Contracts that do define notes produce an if-else chain where `note_type_id` is matched against the\n        // `get_note_type_id()` function of each note type that we know of, in order to identify the note type. Once we\n        // know it we call we correct `unpack` method from the `Packable` trait to obtain the underlying note type, and\n        // compute the note hash (non-siloed) and inner nullifier (also non-siloed).\n\n        let mut if_note_type_id_match_statements_list = &[];\n        for i in 0..NOTES.len() {\n            let typ = NOTES.get(i);\n\n            let get_note_type_id = get_trait_impl_method(\n                typ,\n                quote { crate::note::note_interface::NoteType },\n                quote { get_id },\n            );\n            let unpack = get_trait_impl_method(\n                typ,\n                quote { crate::protocol_types::traits::Packable },\n                quote { unpack },\n            );\n\n            let compute_note_hash = get_trait_impl_method(\n                typ,\n                quote { crate::note::note_interface::NoteHash },\n                quote { compute_note_hash },\n            );\n\n            let compute_nullifier_unconstrained = get_trait_impl_method(\n                typ,\n                quote { crate::note::note_interface::NoteHash },\n                quote { compute_nullifier_unconstrained },\n            );\n\n            let if_or_else_if = if i == 0 {\n                quote { if }\n            } else {\n                quote { else if }\n            };\n\n            if_note_type_id_match_statements_list = if_note_type_id_match_statements_list.push_back(\n                quote {\n                    $if_or_else_if note_type_id == $get_note_type_id() {\n                        // As an extra safety check we make sure that the packed_note BoundedVec has the expected\n                        // length, since we're about to interpret its raw storage as a fixed-size array by calling the\n                        // unpack function on it.\n                        let expected_len = <$typ as $crate::protocol_types::traits::Packable>::N;\n                        let actual_len = packed_note.len();\n                        assert(\n                            actual_len == expected_len,\n                            f\"Expected packed note of length {expected_len} but got {actual_len} for note type id {note_type_id}\"\n                        );\n\n                        let note = $unpack(aztec::utils::array::subarray(packed_note.storage(), 0));\n\n                        let note_hash = $compute_note_hash(note, owner, storage_slot, randomness);\n    \n                        // The message discovery process finds settled notes, that is, notes that were created in prior\n                        // transactions and are therefore already part of the note hash tree. We therefore compute the\n                        // nullification note hash by treating the note as a settled note with the provided note nonce.\n                        let note_hash_for_nullification = aztec::note::utils::compute_note_hash_for_nullification(\n                            aztec::note::retrieved_note::RetrievedNote{ \n                                note,\n                                contract_address,\n                                owner,\n                                randomness,\n                                storage_slot,\n                                metadata: aztec::note::note_metadata::SettledNoteMetadata::new(note_nonce).into()\n                            }\n                        );\n\n                        let inner_nullifier = $compute_nullifier_unconstrained(note, owner, note_hash_for_nullification);\n\n                        Option::some(\n                            aztec::messages::discovery::NoteHashAndNullifier {\n                                note_hash, inner_nullifier\n                            }\n                        )\n                    }\n                },\n            );\n        }\n\n        let if_note_type_id_match_statements = if_note_type_id_match_statements_list.join(quote {});\n\n        quote {\n            /// Unpacks an array into a note corresponding to `note_type_id` and then computes its note hash\n            /// (non-siloed) and inner nullifier (non-siloed) assuming the note has been inserted into the note hash\n            /// tree with `note_nonce`.\n            ///\n            /// The signature of this function notably matches the `aztec::messages::discovery::ComputeNoteHashAndNullifier` type,\n            /// and so it can be used to call functions from that module such as `discover_new_messages`, \n            /// `do_process_message` and `attempt_note_discovery`.\n            ///\n            /// This function is automatically injected by the `#[aztec]` macro.\n            #[contract_library_method]\n            unconstrained fn _compute_note_hash_and_nullifier(\n                packed_note: BoundedVec<Field, aztec::messages::discovery::private_notes::MAX_NOTE_PACKED_LEN>,\n                owner: aztec::protocol_types::address::AztecAddress,\n                storage_slot: Field,\n                note_type_id: Field,\n                contract_address: aztec::protocol_types::address::AztecAddress,\n                randomness: Field,\n                note_nonce: Field,\n            ) -> Option<aztec::messages::discovery::NoteHashAndNullifier> {\n                $if_note_type_id_match_statements\n                else {\n                    Option::none()\n                }\n            }\n        }\n    } else {\n        // Contracts with no notes still implement this function to avoid having special-casing, the implementation\n        // simply throws immediately.\n        quote {\n            /// This contract does not use private notes, so this function should never be called as it will\n            /// unconditionally fail.\n            ///\n            /// This function is automatically injected by the `#[aztec]` macro.\n            #[contract_library_method]\n            unconstrained fn _compute_note_hash_and_nullifier(\n                _packed_note: BoundedVec<Field, aztec::messages::discovery::private_notes::MAX_NOTE_PACKED_LEN>,\n                _owner: aztec::protocol_types::address::AztecAddress,\n                _storage_slot: Field,\n                _note_type_id: Field,\n                _contract_address: aztec::protocol_types::address::AztecAddress,\n                _randomness: Field,\n                _nonce: Field,\n            ) -> Option<aztec::messages::discovery::NoteHashAndNullifier> {\n                panic(f\"This contract does not use private notes\")\n            }\n        }\n    }\n}\n\ncomptime fn generate_sync_private_state() -> Quoted {\n    quote {\n        pub struct sync_private_state_parameters {}\n\n        #[abi(functions)]\n        pub struct sync_private_state_abi {\n            parameters: sync_private_state_parameters,\n        }\n\n        #[aztec::macros::internals_functions_generation::abi_attributes::abi_utility]\n        unconstrained fn sync_private_state() {\n            let address = aztec::context::utility_context::UtilityContext::new().this_address();\n            \n            aztec::messages::discovery::discover_new_messages(address, _compute_note_hash_and_nullifier);\n        }\n    }\n}\n\ncomptime fn generate_process_message() -> Quoted {\n    quote {\n        pub struct process_message_parameters {\n            pub message_ciphertext: BoundedVec<Field, aztec::messages::encoding::MESSAGE_CIPHERTEXT_LEN>,\n            pub message_context: aztec::messages::processing::message_context::MessageContext,\n        }\n\n        #[abi(functions)]\n        pub struct process_message_abi {\n            parameters: process_message_parameters,\n        }\n\n        #[aztec::macros::internals_functions_generation::abi_attributes::abi_utility]\n        unconstrained fn process_message(\n            message_ciphertext: BoundedVec<Field, aztec::messages::encoding::MESSAGE_CIPHERTEXT_LEN>,\n            message_context: aztec::messages::processing::message_context::MessageContext,\n        ) {\n            let address = aztec::context::utility_context::UtilityContext::new().this_address();\n\n            aztec::messages::discovery::discover_new_messages(address, _compute_note_hash_and_nullifier);     \n            aztec::messages::discovery::process_message::process_message_ciphertext(\n                address,\n                _compute_note_hash_and_nullifier,\n                message_ciphertext,\n                message_context,\n            );\n        }\n    }\n}\n\n/// Checks if each function in the module is marked with either #[external(...)], #[contract_library_method], or #[test].\n/// Non-macroified functions are not allowed in contracts.\ncomptime fn check_each_fn_macroified(m: Module) {\n    for f in m.functions() {\n        let name = f.name();\n        if !is_fn_external(f)\n            & !is_fn_contract_library_method(f)\n            & !is_fn_internal(f)\n            & !is_fn_test(f) {\n            // We  don't suggest that #[contract_library_method] is allowed because we don't want to introduce another\n            // concept\n            panic(\n                f\"Function {name} must be marked as either #[external(...)], #[internal(...)], or #[test]\",\n            );\n        }\n    }\n}\n","path":"/home/filip/nargo/github.com/AztecProtocol/aztec-packages/v3.0.1-rc.1/noir-projects/aztec-nr/aztec/src/macros/aztec.nr"},"105":{"source":"use crate::macros::internals_functions_generation::external_functions_registry::get_public_functions;\nuse super::utils::compute_fn_selector;\nuse poseidon::poseidon2::Poseidon2Hasher;\nuse protocol_types::meta::utils::get_params_len_quote;\nuse std::{collections::umap::UHashMap, hash::BuildHasherDefault, panic};\n\n/// Returns an `fn public_dispatch(...)` function for the given module that's assumed to be an Aztec contract.\npub comptime fn generate_public_dispatch(m: Module) -> Quoted {\n    let functions = get_public_functions(m);\n\n    let unit = get_type::<()>();\n\n    let seen_selectors =\n        &mut UHashMap::<Field, Quoted, BuildHasherDefault<Poseidon2Hasher>>::default();\n\n    let ifs = functions.map(|function: FunctionDefinition| {\n        let parameters = function.parameters();\n        let return_type = function.return_type();\n\n        let selector: Field = compute_fn_selector(function);\n        let fn_name = function.name();\n\n        // Since function selectors are computed as the first 4 bytes of the hash of the function signature,\n        // it's possible to have collisions. With the following check, we ensure it doesn't happen within\n        // the same contract.\n        if seen_selectors.contains_key(selector) {\n            let existing_fn = seen_selectors.get(selector).unwrap();\n            panic(\n                f\"Public function selector collision detected between functions '{fn_name}' and '{existing_fn}'\",\n            );\n        }\n        seen_selectors.insert(selector, fn_name);\n\n        let params_len_quote = get_params_len_quote(parameters);\n\n        let initial_read = if parameters.len() == 0 {\n            quote {}\n        } else {\n            // The initial calldata_copy offset is 1 to skip the Field selector\n            // The expected calldata is the serialization of\n            // - FunctionSelector: the selector of the function intended to dispatch\n            // - Parameters: the parameters of the function intended to dispatch\n            // That is, exactly what is expected for a call to the target function,\n            // but with a selector added at the beginning.\n            quote {\n                let input_calldata: [Field; $params_len_quote] = dep::aztec::context::public_context::calldata_copy(1, $params_len_quote);\n                let mut reader = dep::aztec::protocol_types::utils::reader::Reader::new(input_calldata);\n            }\n        };\n\n        let parameter_index: &mut u32 = &mut 0;\n        let reads = parameters.map(|param: (Quoted, Type)| {\n            let parameter_index_value = *parameter_index;\n            let param_name = f\"arg{parameter_index_value}\".quoted_contents();\n            let param_type = param.1;\n            let read = quote {\n                let $param_name: $param_type = reader.read_struct(dep::aztec::protocol_types::traits::Deserialize::deserialize);\n            };\n            *parameter_index += 1;\n            quote { $read }\n        });\n        let read = reads.join(quote { });\n\n        let mut args = &[];\n        for parameter_index in 0..parameters.len() {\n            let param_name = f\"arg{parameter_index}\".quoted_contents();\n            args = args.push_back(quote { $param_name });\n        }\n\n        // We call a function whose name is prefixed with `__aztec_nr_internals__`. This is necessary because the\n        // original function is intentionally made uncallable, preventing direct invocation within the contract.\n        // Instead, a new function with the same name, but prefixed by `__aztec_nr_internals__`, has been generated to\n        // be called here. For more details see the `process_functions` function.\n        let name = f\"__aztec_nr_internals__{fn_name}\".quoted_contents();\n        let args = args.join(quote { , });\n        let call = quote { $name($args) };\n\n        let return_code = if return_type == unit {\n            quote {\n                $call;\n                // Force early return.\n                dep::aztec::context::public_context::avm_return([]);\n            }\n        } else {\n            quote {\n                let return_value = dep::aztec::protocol_types::traits::Serialize::serialize($call);\n                dep::aztec::context::public_context::avm_return(return_value.as_slice());\n            }\n        };\n\n        let if_ = quote {\n            if selector == $selector {\n                $initial_read\n                $read\n                $return_code\n            }\n        };\n        if_\n    });\n\n    if ifs.len() == 0 {\n        // No dispatch function if there are no public functions\n        quote {}\n    } else {\n        let ifs = ifs.push_back(quote { panic(f\"Unknown selector {selector}\") });\n        let dispatch = ifs.join(quote {  });\n\n        let body = quote {\n            // We mark this as public because our whole system depends on public functions having this attribute.\n            #[aztec::macros::internals_functions_generation::abi_attributes::abi_public]\n            pub unconstrained fn public_dispatch(selector: Field) {\n                $dispatch\n            }\n        };\n\n        body\n    }\n}\n\ncomptime fn get_type<T>() -> Type {\n    let t: T = std::mem::zeroed();\n    std::meta::type_of(t)\n}\n","path":"/home/filip/nargo/github.com/AztecProtocol/aztec-packages/v3.0.1-rc.1/noir-projects/aztec-nr/aztec/src/macros/dispatch.nr"},"108":{"source":"use dep::protocol_types::{\n    abis::function_selector::FunctionSelector, address::AztecAddress,\n    constants::GENERATOR_INDEX__CONSTRUCTOR, hash::poseidon2_hash_with_separator, traits::ToField,\n};\n\nuse crate::{\n    context::{PrivateContext, PublicContext},\n    oracle::get_contract_instance::{\n        get_contract_instance, get_contract_instance_deployer_avm,\n        get_contract_instance_initialization_hash_avm,\n    },\n};\n\n// Used by `create_mark_as_initialized` (you won't find it through searching)\npub fn mark_as_initialized_public(context: PublicContext) {\n    let init_nullifier =\n        compute_unsiloed_contract_initialization_nullifier((context).this_address());\n    context.push_nullifier(init_nullifier);\n}\n\n// Used by `create_mark_as_initialized` (you won't find it through searching)\npub fn mark_as_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier =\n        compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_nullifier(init_nullifier);\n}\n\n// Used by `create_init_check` (you won't find it through searching)\npub fn assert_is_initialized_public(context: PublicContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());\n    assert(context.nullifier_exists(init_nullifier, context.this_address()), \"Not initialized\");\n}\n\n// Used by `create_init_check` (you won't find it through searching)\npub fn assert_is_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());\n    context.push_nullifier_read_request(init_nullifier, context.this_address());\n}\n\nfn compute_unsiloed_contract_initialization_nullifier(address: AztecAddress) -> Field {\n    address.to_field()\n}\n\n// Used by `create_assert_correct_initializer_args` (you won't find it through searching)\npub fn assert_initialization_matches_address_preimage_public(context: PublicContext) {\n    let address = context.this_address();\n    let deployer = get_contract_instance_deployer_avm(address).unwrap();\n    let initialization_hash = get_contract_instance_initialization_hash_avm(address).unwrap();\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (deployer.is_zero()) | (deployer == context.msg_sender().unwrap()),\n        \"Initializer address is not the contract deployer\",\n    );\n}\n\n// Used by `create_assert_correct_initializer_args` (you won't find it through searching)\npub fn assert_initialization_matches_address_preimage_private(context: PrivateContext) {\n    let address = context.this_address();\n    let instance = get_contract_instance(address);\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(instance.initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (instance.deployer.is_zero()) | (instance.deployer == context.msg_sender().unwrap()),\n        \"Initializer address is not the contract deployer\",\n    );\n}\n\n/// This function is not only used in macros but it's also used by external people to check that an instance has been\n/// initialized with the correct constructor arguments. Don't hide this unless you implement factory functionality.\npub fn compute_initialization_hash(\n    init_selector: FunctionSelector,\n    init_args_hash: Field,\n) -> Field {\n    poseidon2_hash_with_separator(\n        [init_selector.to_field(), init_args_hash],\n        GENERATOR_INDEX__CONSTRUCTOR,\n    )\n}\n","path":"/home/filip/nargo/github.com/AztecProtocol/aztec-packages/v3.0.1-rc.1/noir-projects/aztec-nr/aztec/src/macros/functions/initialization_utils.nr"},"112":{"source":"use crate::macros::{\n    functions::auth_registry::AUTHORIZE_ONCE_REGISTRY,\n    utils::{is_fn_initializer, is_fn_only_self, is_fn_view},\n};\nuse std::meta::ctstring::AsCtString;\n\n/// Gathers all attributes relevant to the function's ABI and returns a quote that can be applied to the newly generated\n/// function. We apply the abi marker attributes instead of the original ones (e.g. abi_view instead of view) to avoid\n/// the relevant attribute's functionality from getting triggered.\npub(crate) comptime fn get_abi_relevant_attributes(f: FunctionDefinition) -> Quoted {\n    let mut attributes = quote {};\n\n    if is_fn_view(f) {\n        attributes = quote { $attributes #[aztec::macros::internals_functions_generation::abi_attributes::abi_view] };\n    }\n\n    if is_fn_only_self(f) {\n        attributes = quote { $attributes #[aztec::macros::internals_functions_generation::abi_attributes::abi_only_self] };\n    }\n\n    if is_fn_initializer(f) {\n        attributes = quote { $attributes #[aztec::macros::internals_functions_generation::abi_attributes::abi_initializer] };\n    }\n\n    attributes\n}\n\n/// Injects a call to `aztec::messages::discovery::discover_new_messages`, causing for new notes to be added to PXE and made\n/// available for the current execution.\npub(crate) comptime fn create_message_discovery_call() -> Quoted {\n    quote {\n        /// Safety: message discovery returns nothing and is performed solely for its side-effects. It is therefore\n        /// always safe to call.\n        unsafe {\n            dep::aztec::messages::discovery::discover_new_messages(\n                self.address,\n                _compute_note_hash_and_nullifier,\n            );\n        };\n    }\n}\n\n/// Injects an authwit verification check of the form:\n/// ```\n///   if (!from.eq(context.msg_sender().unwrap())) {\n///         assert_current_call_valid_authwit::<N>(&mut context, from);\n///     } else {\n///         assert(authwit_nonce, \"Invalid authwit nonce. When 'from' and 'msg_sender' are the same, authwit_nonce must be zero\");\n///     }\n/// ```\n/// where `from` and `authwit_nonce` are the names of the parameters that are expected to be present in the function definition.\n/// This check is injected by the `#[authorize_once(\"from_arg_name\", \"nonce_arg_name\")]`, which allows the user to define\n/// which parameters to use.\n///\n/// # Arguments\n/// * `f` - The function definition to inject the authwit verification check into. The function must have parameters\n///         matching the names specified in the `#[authorize_once]` attribute.\n/// * `is_private` - Whether the function is a private function (`true`) or a public function (`false`). This determines\n///                  which authwit verification method to use: `assert_current_call_valid_authwit` for private functions\n///                  or `assert_current_call_valid_authwit_public` for public functions.\npub(crate) comptime fn create_authorize_once_check(\n    f: FunctionDefinition,\n    is_private: bool,\n) -> Quoted {\n    let maybe_authorize_once_args = AUTHORIZE_ONCE_REGISTRY.get(f);\n    let authorize_once_args = if maybe_authorize_once_args.is_some() {\n        maybe_authorize_once_args.unwrap()\n    } else {\n        // We need to for authorize_once to have already executed so that we can retrieve its params - this depends on\n        // the order in which the attributes are applied.\n        panic(\n            f\"Functions marked with #[authorize_once] must have the #[external(\\\"private\\\")] or #[external(\\\"public\\\")] attribute placed last\",\n        )\n    };\n\n    let (from_arg_name, nonce_arg_name) = authorize_once_args;\n    let name: Quoted = f.name();\n\n    let from_arg_candidates =\n        f.parameters().filter(|(name, _)| name == f\"{from_arg_name}\".quoted_contents());\n    let (from_arg_name_quoted, from_arg_type) = if from_arg_candidates.len() == 1 {\n        from_arg_candidates[0]\n    } else {\n        panic(\n            f\"Function {name} does not have a {from_arg_name} parameter. Please specify which one to use in #[authorize_once(\\\"...\\\", \\\"authwit_nonce\\\")]\",\n        )\n    };\n    if from_arg_type\n        != quote { dep::protocol_types::address::aztec_address::AztecAddress }.as_type() {\n        panic(\n            f\"Argument {from_arg_name_quoted} in function {name} must be of type AztecAddress, but is of type {from_arg_type}\",\n        )\n    }\n\n    let nonce_arg_candidates =\n        f.parameters().filter(|(name, _)| name == f\"{nonce_arg_name}\".quoted_contents());\n    let (nonce_arg_name_quoted, nonce_arg_type) = if nonce_arg_candidates.len() == 1 {\n        nonce_arg_candidates[0]\n    } else {\n        panic(\n            f\"Function {name} does not have a {nonce_arg_name}. Please specify which one to use in #[authorize_once(\\\"from\\\", \\\"...\\\")]\",\n        )\n    };\n    if nonce_arg_type != quote { Field }.as_type() {\n        panic(\n            f\"Argument {nonce_arg_name_quoted} in function {name} must be of type Field, but is of type {nonce_arg_type}\",\n        );\n    }\n\n    let nonce_check_quote = f\"{nonce_arg_name_quoted} == 0\".quoted_contents();\n\n    let fn_call = if is_private {\n        let args_len = f.parameters().len();\n        quote { dep::aztec::authwit::auth::assert_current_call_valid_authwit::<$args_len> }\n    } else {\n        quote { dep::aztec::authwit::auth::assert_current_call_valid_authwit_public }\n    };\n    let invalid_nonce_message = f\"Invalid authwit nonce. When '{from_arg_name}' and 'msg_sender' are the same, '{nonce_arg_name}' must be zero\"\n        .as_ctstring()\n        .as_quoted_str();\n    quote {         \n        if (!$from_arg_name_quoted.eq(self.msg_sender().unwrap())) {\n            $fn_call(self.context, $from_arg_name_quoted);\n        } else {\n            assert($nonce_check_quote, $invalid_nonce_message);\n        }\n    }\n}\n","path":"/home/filip/nargo/github.com/AztecProtocol/aztec-packages/v3.0.1-rc.1/noir-projects/aztec-nr/aztec/src/macros/internals_functions_generation/external/helpers.nr"},"115":{"source":"use crate::macros::{\n    internals_functions_generation::external::helpers::{\n        create_authorize_once_check, get_abi_relevant_attributes,\n    },\n    utils::{\n        fn_has_authorize_once, fn_has_noinitcheck, is_fn_initializer, is_fn_only_self, is_fn_view,\n        module_has_initializer, module_has_storage,\n    },\n};\nuse std::meta::ctstring::AsCtString;\n\npub(crate) comptime fn generate_public_external(f: FunctionDefinition) -> Quoted {\n    let module_has_initializer = module_has_initializer(f.module());\n    let module_has_storage = module_has_storage(f.module());\n\n    // Public functions undergo a lot of transformations from their Aztec.nr form.\n    let original_params = f.parameters();\n\n    let args_len_quote = if original_params.len() == 0 {\n        // If the function has no parameters, we set the args_len to 0.\n        quote { 0 }\n    } else {\n        // The following will give us <type_of_struct_member_1 as Serialize>::N + <type_of_struct_member_2 as Serialize>::N + ...\n        original_params\n            .map(|(_, param_type): (Quoted, Type)| {\n                quote {\n            <$param_type as $crate::protocol_types::traits::Serialize>::N\n        }\n            })\n            .join(quote {+})\n    };\n\n    let storage_init = if module_has_storage {\n        quote {\n            let storage = Storage::init(context);\n        }\n    } else {\n        // Contract does not have Storage defined, so we set storage to the unit type `()`. ContractSelf requires a\n        // storage struct in its constructor. Using an Option type would lead to worse developer experience and higher\n        // constraint counts so we use the unit type `()` instead.\n        quote {\n            let storage = ();\n        }\n    };\n\n    // Unlike in the private case, in public the `context` does not need to receive the hash of the original params.\n    let contract_self_creation = quote {\n        #[allow(unused_variables)]\n        let mut self = {\n            let context = dep::aztec::context::public_context::PublicContext::new(|| {\n            // We start from 1 because we skip the selector for the dispatch function.\n            let serialized_args : [Field; $args_len_quote] = dep::aztec::context::public_context::calldata_copy(1, $args_len_quote);\n            dep::aztec::hash::hash_args(serialized_args)\n            });\n            $storage_init\n            let self_address = context.this_address();\n            let call_self: CallSelf<aztec::context::public_context::PublicContext> = CallSelf { address: self_address, context };\n            let call_self_static: CallSelfStatic<aztec::context::public_context::PublicContext> = CallSelfStatic { address: self_address, context };\n            let internal: CallInternal<aztec::context::public_context::PublicContext> = CallInternal { context };\n            aztec::contract_self::ContractSelf::new_public(context, storage, call_self, call_self_static, internal)\n        };\n    };\n\n    let original_function_name = f.name();\n\n    // Modifications introduced by the different marker attributes.\n    let internal_check = if is_fn_only_self(f) {\n        let assertion_message =\n            f\"Function {original_function_name} can only be called by the same contract\";\n        quote { assert(self.msg_sender().unwrap() == self.address, $assertion_message); }\n    } else {\n        quote {}\n    };\n\n    let view_check = if is_fn_view(f) {\n        let assertion_message = f\"Function {original_function_name} can only be called statically\"\n            .as_ctstring()\n            .as_quoted_str();\n        quote { assert(self.context.is_static_call(), $assertion_message); }\n    } else {\n        quote {}\n    };\n\n    let (assert_initializer, mark_as_initialized) = if is_fn_initializer(f) {\n        (\n            quote { aztec::macros::functions::initialization_utils::assert_initialization_matches_address_preimage_public(self.context); },\n            quote { aztec::macros::functions::initialization_utils::mark_as_initialized_public(self.context); },\n        )\n    } else {\n        (quote {}, quote {})\n    };\n\n    // Initialization checks are not included in contracts that don't have initializers.\n    let init_check = if module_has_initializer & !fn_has_noinitcheck(f) & !is_fn_initializer(f) {\n        quote { aztec::macros::functions::initialization_utils::assert_is_initialized_public(self.context); }\n    } else {\n        quote {}\n    };\n\n    // Inject the authwit check if the function is marked with #[authorize_once].\n    let authorize_once_check = if fn_has_authorize_once(f) {\n        create_authorize_once_check(f, false)\n    } else {\n        quote {}\n    };\n\n    let to_prepend = quote {\n        $contract_self_creation\n        $assert_initializer\n        $init_check\n        $internal_check\n        $view_check\n        $authorize_once_check\n    };\n\n    let to_append = quote {\n        $mark_as_initialized\n    };\n\n    let fn_name = f\"__aztec_nr_internals__{original_function_name}\".quoted_contents();\n    let body = f.body();\n    let return_type = f.return_type();\n\n    // New function parameters are the same as the original function's ones.\n    let params = original_params\n        .map(|(param_name, param_type)| quote { $param_name: $param_type })\n        .join(quote {, });\n\n    // Preserve all attributes that are relevant to the function's ABI.\n    let abi_relevant_attributes = get_abi_relevant_attributes(f);\n\n    // All public functions are automatically made unconstrained, even if they were not marked as such. This is because\n    // instead of compiling into a circuit, they will compile to bytecode that will be later transpiled into AVM\n    // bytecode.\n    quote {\n        #[aztec::macros::internals_functions_generation::abi_attributes::abi_public]\n        $abi_relevant_attributes\n        unconstrained fn $fn_name($params) -> pub $return_type {\n            $to_prepend\n            $body\n            $to_append\n        }\n    }\n}\n","path":"/home/filip/nargo/github.com/AztecProtocol/aztec-packages/v3.0.1-rc.1/noir-projects/aztec-nr/aztec/src/macros/internals_functions_generation/external/public.nr"},"116":{"source":"use crate::macros::{\n    internals_functions_generation::external::helpers::create_message_discovery_call,\n    utils::module_has_storage,\n};\n\npub(crate) comptime fn generate_utility_external(f: FunctionDefinition) -> Quoted {\n    // Initialize Storage if module has storage\n    let storage_init = if module_has_storage(f.module()) {\n        quote {\n            let storage = Storage::init(context);\n        }\n    } else {\n        // Contract does not have Storage defined, so we set storage to the unit type `()`. ContractSelf requires a\n        // storage struct in its constructor. Using an Option type would lead to worse developer experience and higher\n        // constraint counts so we use the unit type `()` instead.\n        quote {\n            let storage = ();\n        }\n    };\n\n    // Create utility context\n    let contract_self_creation = quote {\n        #[allow(unused_variables)]\n        let mut self = {\n            let context = dep::aztec::context::utility_context::UtilityContext::new();\n            $storage_init\n            aztec::contract_self::ContractSelf::new_utility(context, storage)\n        };\n    };\n\n    // All utility functions perform message discovery, since they may need to access private notes that would be\n    // found during this process or they may be used to sync private events from TypeScript\n    // (`sync_private_state` function gets invoked by PXE::getPrivateEvents function).\n    let message_discovery_call = create_message_discovery_call();\n\n    // A quote to be injected at the beginning of the function body.\n    let to_prepend = quote {\n        dep::aztec::oracle::version::assert_compatible_oracle_version();\n        $contract_self_creation\n        $message_discovery_call\n    };\n\n    let original_function_name = f.name();\n    let fn_name = f\"__aztec_nr_internals__{original_function_name}\".quoted_contents();\n    let body = f.body();\n    let params = f\n        .parameters()\n        .map(|(param_name, param_type)| quote { $param_name: $param_type })\n        .join(quote {, });\n    let return_type = f.return_type();\n\n    quote {\n        #[aztec::macros::internals_functions_generation::abi_attributes::abi_utility]\n        unconstrained fn $fn_name($params) -> pub $return_type {\n            $to_prepend\n            $body\n        }\n    }\n}\n","path":"/home/filip/nargo/github.com/AztecProtocol/aztec-packages/v3.0.1-rc.1/noir-projects/aztec-nr/aztec/src/macros/internals_functions_generation/external/utility.nr"},"125":{"source":"use protocol_types::{address::AztecAddress, debug_log::{debug_log, debug_log_format}};\n\npub mod nonce_discovery;\npub mod partial_notes;\npub mod private_events;\npub mod private_notes;\npub mod process_message;\n\nuse crate::{\n    messages::{\n        discovery::{\n            private_notes::MAX_NOTE_PACKED_LEN, process_message::process_message_ciphertext,\n        },\n        processing::{\n            get_private_logs, pending_tagged_log::PendingTaggedLog,\n            validate_enqueued_notes_and_events,\n        },\n    },\n    utils::array,\n};\n\npub struct NoteHashAndNullifier {\n    /// The result of NoteHash::compute_note_hash\n    pub note_hash: Field,\n    /// The result of NoteHash::compute_nullifier_unconstrained (since all of message discovery is unconstrained)\n    pub inner_nullifier: Field,\n}\n\n/// A function which takes a note's packed content, address of the emitting contract, note nonce, storage slot and note\n/// type ID and attempts to compute its note hash (not hashed by note nonce nor siloed by address) and inner nullifier\n/// (not siloed by address).\n///\n/// This function must be user-provided as its implementation requires knowledge of how note type IDs are allocated in a\n/// contract. The `#[aztec]` macro automatically creates such a contract library method called\n/// `_compute_note_hash_and_nullifier`, which looks something like this:\n///\n/// ```\n/// |packed_note, owner, storage_slot, note_type_id, contract_address, randomness, note_nonce| {\n///     if note_type_id == MyNoteType::get_id() {\n///         assert(packed_note.len() == MY_NOTE_TYPE_SERIALIZATION_LENGTH);\n///\n///         let note = MyNoteType::unpack(aztec::utils::array::subarray(packed_note.storage(), 0));\n///\n///         let note_hash = note.compute_note_hash(owner, storage_slot, randomness);\n///         let note_hash_for_nullification = aztec::note::utils::compute_note_hash_for_nullification(\n///             RetrievedNote{ note, contract_address, metadata: SettledNoteMetadata::new(note_nonce).into() },\n///             storage_slot\n///         );\n///\n///         let inner_nullifier = note.compute_nullifier_unconstrained(owner, note_hash_for_nullification);\n///\n///         Option::some(\n///             aztec::messages::discovery::NoteHashAndNullifier {\n///                 note_hash, inner_nullifier\n///             }\n///         )\n///     } else if note_type_id == MyOtherNoteType::get_id() {\n///           ... // Similar to above but calling MyOtherNoteType::unpack_content\n///     } else {\n///         Option::none() // Unknown note type ID\n///     };\n/// }\n/// ```\npub type ComputeNoteHashAndNullifier<Env> = unconstrained fn[Env](/* packed_note */BoundedVec<Field, MAX_NOTE_PACKED_LEN>, /* owner */ AztecAddress, /* storage_slot */ Field, /* note_type_id */ Field, /* contract_address */ AztecAddress, /* randomness */ Field, /* note nonce */ Field) -> Option<NoteHashAndNullifier>;\n\n/// Performs the message discovery process, in which private logs are downloaded and inspected to find new private\n/// notes, partial notes and events, etc., and pending partial notes are processed to search for their completion logs.\n/// This is the mechanism via which a contract updates its knowledge of its private state.\n///\n/// Note that the state is synchronized up to the latest block synchronized by PXE. That should be close to the chain\n/// tip as block synchronization is performed before contract function simulation is done.\n///\n/// Receives the address of the contract on which discovery is performed along with its\n/// `compute_note_hash_and_nullifier` function.\npub unconstrained fn discover_new_messages<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n) {\n    debug_log(\"Performing message discovery\");\n\n    // First we process all private logs, which can contain different kinds of messages e.g. private notes, partial\n    // notes, private events, etc.\n    let mut logs = get_private_logs(contract_address);\n    logs.for_each(|i, pending_tagged_log: PendingTaggedLog| {\n        debug_log_format(\n            \"Processing log with tag {0}\",\n            [pending_tagged_log.log.get(0)],\n        );\n\n        // We remove the tag from the pending tagged log and process the message ciphertext contained in it.\n        let message_ciphertext = array::subbvec(pending_tagged_log.log, 1);\n\n        process_message_ciphertext(\n            contract_address,\n            compute_note_hash_and_nullifier,\n            message_ciphertext,\n            pending_tagged_log.context,\n        );\n        logs.remove(i);\n    });\n\n    // Then we process all pending partial notes, regardless of whether they were found in the current or previous\n    // executions.\n    partial_notes::fetch_and_process_partial_note_completion_logs(\n        contract_address,\n        compute_note_hash_and_nullifier,\n    );\n\n    // Finally we validate all notes and events that were found as part of the previous processes, resulting in them\n    // being added to PXE's database and retrievable via oracles (get_notes) and our TS API (PXE::getPrivateEvents).\n    validate_enqueued_notes_and_events(contract_address);\n}\n","path":"/home/filip/nargo/github.com/AztecProtocol/aztec-packages/v3.0.1-rc.1/noir-projects/aztec-nr/aztec/src/messages/discovery/mod.nr"},"126":{"source":"use crate::messages::discovery::{ComputeNoteHashAndNullifier, private_notes::MAX_NOTE_PACKED_LEN};\n\nuse dep::protocol_types::{\n    address::AztecAddress,\n    constants::MAX_NOTE_HASHES_PER_TX,\n    debug_log::debug_log_format,\n    hash::{compute_note_hash_nonce, compute_siloed_note_hash, compute_unique_note_hash},\n    traits::ToField,\n};\n\n/// A struct with the discovered information of a complete note, required for delivery to PXE. Note that this is *not*\n/// the complete note information, since it does not include content, storage slot, etc.\npub struct DiscoveredNoteInfo {\n    pub note_nonce: Field,\n    pub note_hash: Field,\n    pub inner_nullifier: Field,\n}\n\n/// Searches for note nonces that will result in a note that was emitted in a transaction. While rare, it is possible\n/// for multiple notes to have the exact same packed content and storage slot but different nonces, resulting in\n/// different unique note hashes. Because of this this function returns a *vector* of discovered notes, though in most\n/// cases it will contain a single element.\n///\n/// Due to how nonces are computed, this function requires knowledge of the transaction in which the note was created,\n/// more specifically the list of all unique note hashes in it plus the value of its first nullifier.\npub unconstrained fn attempt_note_nonce_discovery<Env>(\n    unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    first_nullifier_in_tx: Field,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    contract_address: AztecAddress,\n    owner: AztecAddress,\n    storage_slot: Field,\n    randomness: Field,\n    note_type_id: Field,\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n) -> BoundedVec<DiscoveredNoteInfo, MAX_NOTE_HASHES_PER_TX> {\n    let discovered_notes = &mut BoundedVec::new();\n\n    debug_log_format(\n        \"Attempting nonce discovery on {0} potential notes on contract {1} for storage slot {2}\",\n        [unique_note_hashes_in_tx.len() as Field, contract_address.to_field(), storage_slot],\n    );\n\n    // We need to find nonces (typically just one) that result in a note hash that, once siloed into a unique note hash,\n    // is one of the note hashes created by the transaction.\n    unique_note_hashes_in_tx.for_eachi(|i, expected_unique_note_hash| {\n        // Nonces are computed by hashing the first nullifier in the transaction with the index of the note in the\n        // new note hashes array. We therefore know for each note in every transaction what its nonce is.\n        let candidate_nonce = compute_note_hash_nonce(first_nullifier_in_tx, i);\n\n        // Given note nonce, note content and metadata, we can compute the note hash and silo it to check if it matches\n        // the note hash at the array index we're currently processing.\n        // TODO(#11157): handle failed note_hash_and_nullifier computation\n        let hashes = compute_note_hash_and_nullifier(\n            packed_note,\n            owner,\n            storage_slot,\n            note_type_id,\n            contract_address,\n            randomness,\n            candidate_nonce,\n        )\n            .expect(f\"Failed to compute a note hash for note type {note_type_id}\");\n\n        let siloed_note_hash = compute_siloed_note_hash(contract_address, hashes.note_hash);\n        let unique_note_hash = compute_unique_note_hash(candidate_nonce, siloed_note_hash);\n\n        if unique_note_hash == expected_unique_note_hash {\n            // Note that while we did check that the note hash is the preimage of the expected unique note hash, we\n            // perform no validations on the nullifier - we fundamentally cannot, since only the application knows\n            // how to compute nullifiers. We simply trust it to have provided the correct one: if it hasn't, then\n            // PXE may fail to realize that a given note has been nullified already, and calls to the application\n            // could result in invalid transactions (with duplicate nullifiers). This is not a concern because an\n            // application already has more direct means of making a call to it fail the transaction.\n            discovered_notes.push(\n                DiscoveredNoteInfo {\n                    note_nonce: candidate_nonce,\n                    note_hash: hashes.note_hash,\n                    inner_nullifier: hashes.inner_nullifier,\n                },\n            );\n\n            // We don't exit the loop - it is possible (though rare) for the exact same note content to be present\n            // multiple times in the same transaction with different nonces. This typically doesn't happen due to\n            // notes containing random values in order to hide their contents.\n        }\n    });\n\n    debug_log_format(\n        \"Found valid nonces for a total of {0} notes\",\n        [discovered_notes.len() as Field],\n    );\n\n    *discovered_notes\n}\n\nmod test {\n    use crate::{\n        messages::discovery::{NoteHashAndNullifier, private_notes::MAX_NOTE_PACKED_LEN},\n        note::{\n            note_interface::{NoteHash, NoteType},\n            note_metadata::SettledNoteMetadata,\n            retrieved_note::RetrievedNote,\n            utils::compute_note_hash_for_nullification,\n        },\n        oracle::random::random,\n        test::mocks::mock_note::MockNote,\n        utils::array,\n    };\n\n    use dep::protocol_types::{\n        address::AztecAddress,\n        hash::{compute_note_hash_nonce, compute_siloed_note_hash, compute_unique_note_hash},\n        traits::{FromField, Packable},\n    };\n\n    use super::attempt_note_nonce_discovery;\n\n    // This implementation could be simpler, but this serves as a nice example of the expected flow in a real\n    // implementation, and as a sanity check that the interface is sufficient.\n    unconstrained fn compute_note_hash_and_nullifier(\n        packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n        owner: AztecAddress,\n        storage_slot: Field,\n        note_type_id: Field,\n        contract_address: AztecAddress,\n        randomness: Field,\n        note_nonce: Field,\n    ) -> Option<NoteHashAndNullifier> {\n        if note_type_id == MockNote::get_id() {\n            let note = MockNote::unpack(array::subarray(packed_note.storage(), 0));\n            let note_hash = note.compute_note_hash(owner, storage_slot, randomness);\n\n            let note_hash_for_nullification = compute_note_hash_for_nullification(\n                RetrievedNote {\n                    note,\n                    contract_address,\n                    owner,\n                    randomness,\n                    storage_slot,\n                    metadata: SettledNoteMetadata::new(note_nonce).into(),\n                },\n            );\n\n            let inner_nullifier =\n                note.compute_nullifier_unconstrained(owner, note_hash_for_nullification);\n\n            Option::some(NoteHashAndNullifier { note_hash, inner_nullifier })\n        } else {\n            Option::none()\n        }\n    }\n\n    global VALUE: Field = 7;\n    global FIRST_NULLIFIER_IN_TX: Field = 47;\n    global CONTRACT_ADDRESS: AztecAddress = AztecAddress::from_field(13);\n    global OWNER: AztecAddress = AztecAddress::from_field(14);\n    global STORAGE_SLOT: Field = 99;\n    global RANDOMNESS: Field = 99;\n\n    #[test]\n    unconstrained fn no_note_hashes() {\n        let unique_note_hashes_in_tx = BoundedVec::new();\n        let packed_note = BoundedVec::new();\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            OWNER,\n            STORAGE_SLOT,\n            RANDOMNESS,\n            MockNote::get_id(),\n            packed_note,\n        );\n\n        assert_eq(discovered_notes.len(), 0);\n    }\n\n    #[test(should_fail_with = \"Failed to compute a note hash\")]\n    unconstrained fn failed_hash_computation() {\n        let unique_note_hashes_in_tx = BoundedVec::from_array([random()]);\n        let packed_note = BoundedVec::new();\n        let note_type_id = 0; // This note type id is unknown to compute_note_hash_and_nullifier\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            OWNER,\n            STORAGE_SLOT,\n            RANDOMNESS,\n            note_type_id,\n            packed_note,\n        );\n\n        assert_eq(discovered_notes.len(), 0);\n    }\n\n    struct NoteAndData {\n        note: MockNote,\n        note_nonce: Field,\n        note_hash: Field,\n        unique_note_hash: Field,\n        inner_nullifier: Field,\n    }\n\n    unconstrained fn construct_note(value: Field, note_index_in_tx: u32) -> NoteAndData {\n        let note_nonce = compute_note_hash_nonce(FIRST_NULLIFIER_IN_TX, note_index_in_tx);\n\n        let retrieved_note = MockNote::new(value)\n            .contract_address(CONTRACT_ADDRESS)\n            .owner(OWNER)\n            .randomness(RANDOMNESS)\n            .storage_slot(STORAGE_SLOT)\n            .note_metadata(SettledNoteMetadata::new(note_nonce).into())\n            .build_retrieved_note();\n        let note = retrieved_note.note;\n\n        let note_hash = note.compute_note_hash(OWNER, STORAGE_SLOT, RANDOMNESS);\n        let unique_note_hash = compute_unique_note_hash(\n            note_nonce,\n            compute_siloed_note_hash(CONTRACT_ADDRESS, note_hash),\n        );\n        let inner_nullifier = note.compute_nullifier_unconstrained(\n            OWNER,\n            compute_note_hash_for_nullification(retrieved_note),\n        );\n\n        NoteAndData { note, note_nonce, note_hash, unique_note_hash, inner_nullifier }\n    }\n\n    #[test]\n    unconstrained fn single_note() {\n        let note_index_in_tx = 2;\n        let note_and_data = construct_note(VALUE, note_index_in_tx);\n\n        let mut unique_note_hashes_in_tx = BoundedVec::from_array([\n            random(), random(), random(), random(), random(), random(), random(),\n        ]);\n        unique_note_hashes_in_tx.set(note_index_in_tx, note_and_data.unique_note_hash);\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            OWNER,\n            STORAGE_SLOT,\n            RANDOMNESS,\n            MockNote::get_id(),\n            BoundedVec::from_array(note_and_data.note.pack()),\n        );\n\n        assert_eq(discovered_notes.len(), 1);\n        let discovered_note = discovered_notes.get(0);\n\n        assert_eq(discovered_note.note_nonce, note_and_data.note_nonce);\n        assert_eq(discovered_note.note_hash, note_and_data.note_hash);\n        assert_eq(discovered_note.inner_nullifier, note_and_data.inner_nullifier);\n    }\n\n    #[test]\n    unconstrained fn multiple_notes_same_preimage() {\n        let first_note_index_in_tx = 3;\n        let first_note_and_data = construct_note(VALUE, first_note_index_in_tx);\n\n        let second_note_index_in_tx = 5;\n        let second_note_and_data = construct_note(VALUE, second_note_index_in_tx);\n\n        // Both notes have the same preimage (and therefore packed representation), so both should be found in the same\n        // call.\n        assert_eq(first_note_and_data.note, second_note_and_data.note);\n        let packed_note = first_note_and_data.note.pack();\n\n        let mut unique_note_hashes_in_tx = BoundedVec::from_array([\n            random(), random(), random(), random(), random(), random(), random(),\n        ]);\n        unique_note_hashes_in_tx.set(first_note_index_in_tx, first_note_and_data.unique_note_hash);\n        unique_note_hashes_in_tx.set(second_note_index_in_tx, second_note_and_data.unique_note_hash);\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            OWNER,\n            STORAGE_SLOT,\n            RANDOMNESS,\n            MockNote::get_id(),\n            BoundedVec::from_array(packed_note),\n        );\n\n        assert_eq(discovered_notes.len(), 2);\n\n        assert(discovered_notes.any(|discovered_note| {\n            (discovered_note.note_nonce == first_note_and_data.note_nonce)\n                & (discovered_note.note_hash == first_note_and_data.note_hash)\n                & (discovered_note.inner_nullifier == first_note_and_data.inner_nullifier)\n        }));\n\n        assert(discovered_notes.any(|discovered_note| {\n            (discovered_note.note_nonce == second_note_and_data.note_nonce)\n                & (discovered_note.note_hash == second_note_and_data.note_hash)\n                & (discovered_note.inner_nullifier == second_note_and_data.inner_nullifier)\n        }));\n    }\n}\n","path":"/home/filip/nargo/github.com/AztecProtocol/aztec-packages/v3.0.1-rc.1/noir-projects/aztec-nr/aztec/src/messages/discovery/nonce_discovery.nr"},"127":{"source":"use crate::{\n    capsules::CapsuleArray,\n    messages::{\n        discovery::{ComputeNoteHashAndNullifier, nonce_discovery::attempt_note_nonce_discovery},\n        encoding::MAX_MESSAGE_CONTENT_LEN,\n        processing::{\n            enqueue_note_for_validation, get_pending_partial_notes_completion_logs,\n            log_retrieval_response::LogRetrievalResponse,\n        },\n    },\n    utils::array,\n};\n\nuse protocol_types::{\n    address::AztecAddress,\n    debug_log::debug_log_format,\n    hash::sha256_to_field,\n    traits::{Deserialize, FromField, Serialize},\n};\n\n/// [ owner, storage slot, randomness, note_completion_log_tag ]\nglobal PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN: u32 = 4;\nglobal PARTIAL_NOTE_PRIVATE_MSG_CONTENT_OWNER_INDEX: u32 = 0;\nglobal PARTIAL_NOTE_PRIVATE_MSG_CONTENT_STORAGE_SLOT_INDEX: u32 = 1;\nglobal PARTIAL_NOTE_PRIVATE_MSG_CONTENT_RANDOMNESS_INDEX: u32 = 2;\nglobal PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NOTE_COMPLETION_LOG_TAG_INDEX: u32 = 3;\n\n/// Partial notes have a maximum packed length of their private fields bound by extra content in their private message\n/// (e.g. the storage slot, note completion log tag, etc.).\npub global MAX_PARTIAL_NOTE_PRIVATE_PACKED_LEN: u32 =\n    MAX_MESSAGE_CONTENT_LEN - PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN;\n\n/// The slot in the PXE capsules where we store a `CapsuleArray` of `DeliveredPendingPartialNote`.\npub global DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT: Field = sha256_to_field(\n    \"AZTEC_NR::DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT\".as_bytes(),\n);\n\n/// A partial note that was delivered but is still pending completion. Contains the information necessary to find the\n/// log that will complete it and lead to a note being discovered and delivered.\n#[derive(Serialize, Deserialize)]\npub(crate) struct DeliveredPendingPartialNote {\n    pub(crate) note_completion_log_tag: Field,\n    pub(crate) owner: AztecAddress,\n    pub(crate) storage_slot: Field,\n    pub(crate) randomness: Field,\n    pub(crate) note_type_id: Field,\n    pub(crate) packed_private_note_content: BoundedVec<Field, MAX_PARTIAL_NOTE_PRIVATE_PACKED_LEN>,\n    pub(crate) recipient: AztecAddress,\n}\n\npub unconstrained fn process_partial_note_private_msg(\n    contract_address: AztecAddress,\n    recipient: AztecAddress,\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n) {\n    // We store the information of the partial note we found in a persistent capsule in PXE, so that we can later search\n    // for the public log that will complete it.\n    let pending = decode_partial_note_private_msg(msg_metadata, msg_content, recipient);\n\n    CapsuleArray::at(\n        contract_address,\n        DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT,\n    )\n        .push(pending);\n}\n\n/// Searches for logs that would result in the completion of pending partial notes, ultimately resulting in the notes\n/// being delivered to PXE if completed.\npub unconstrained fn fetch_and_process_partial_note_completion_logs<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n) {\n    let pending_partial_notes = CapsuleArray::at(\n        contract_address,\n        DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT,\n    );\n\n    debug_log_format(\n        \"{} pending partial notes\",\n        [pending_partial_notes.len() as Field],\n    );\n\n    // Each of the pending partial notes might get completed by a log containing its public values. For performance\n    // reasons, we fetch all of these logs concurrently and then process them one by one, minimizing the amount of time\n    // waiting for the node roundtrip.\n    let maybe_completion_logs =\n        get_pending_partial_notes_completion_logs(contract_address, pending_partial_notes);\n\n    // Each entry in the maybe completion logs array corresponds to the entry in the pending partial notes array at the\n    // same index. This means we can use the same index as we iterate through the responses to get both the partial note\n    // and the log that might complete it.\n    assert_eq(maybe_completion_logs.len(), pending_partial_notes.len());\n\n    maybe_completion_logs.for_each(|i, maybe_log: Option<LogRetrievalResponse>| {\n        // We clear the completion logs as we read them so that the array is empty by the time we next query it.\n        // TODO(#14943): use volatile arrays to avoid having to manually clear this.\n        maybe_completion_logs.remove(i);\n\n        let pending_partial_note = pending_partial_notes.get(i);\n\n        if maybe_log.is_none() {\n            debug_log_format(\n                \"Found no completion logs for partial note with tag {}\",\n                [pending_partial_note.note_completion_log_tag],\n            );\n\n            // Note that we're not removing the pending partial note from the capsule array, so we will continue\n            // searching for this tagged log when performing message discovery in the future until we either find it or\n            // the entry is somehow removed from the array.\n        } else {\n            debug_log_format(\n                \"Completion log found for partial note with tag {}\",\n                [pending_partial_note.note_completion_log_tag],\n            );\n            let log = maybe_log.unwrap();\n\n            // Public fields are assumed to all be placed at the end of the packed representation, so we combine the\n            // private and public packed fields (i.e. the contents of the private message and public log plaintext to get\n            // the complete packed content.\n            let complete_packed_note = array::append(\n                pending_partial_note.packed_private_note_content,\n                log.log_payload,\n            );\n\n            let discovered_notes = attempt_note_nonce_discovery(\n                log.unique_note_hashes_in_tx,\n                log.first_nullifier_in_tx,\n                compute_note_hash_and_nullifier,\n                contract_address,\n                pending_partial_note.owner,\n                pending_partial_note.storage_slot,\n                pending_partial_note.randomness,\n                pending_partial_note.note_type_id,\n                complete_packed_note,\n            );\n\n            // TODO(#11627): is there anything reasonable we can do if we get a log but it doesn't result in a note\n            // being found?\n            if discovered_notes.len() == 0 {\n                panic(\n                    f\"A partial note's completion log did not result in any notes being found - this should never happen\",\n                );\n            }\n\n            debug_log_format(\n                \"Discovered {0} notes for partial note with tag {1}\",\n                [discovered_notes.len() as Field, pending_partial_note.note_completion_log_tag],\n            );\n\n            discovered_notes.for_each(|discovered_note| {\n                enqueue_note_for_validation(\n                    contract_address,\n                    pending_partial_note.owner,\n                    pending_partial_note.storage_slot,\n                    pending_partial_note.randomness,\n                    discovered_note.note_nonce,\n                    complete_packed_note,\n                    discovered_note.note_hash,\n                    discovered_note.inner_nullifier,\n                    log.tx_hash,\n                    pending_partial_note.recipient,\n                );\n            });\n\n            // Because there is only a single log for a given tag, once we've processed the tagged log then we\n            // simply delete the pending work entry, regardless of whether it was actually completed or not.\n            pending_partial_notes.remove(i);\n        }\n    });\n}\n\nfn decode_partial_note_private_msg(\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n    recipient: AztecAddress,\n) -> DeliveredPendingPartialNote {\n    let note_type_id = msg_metadata as Field; // TODO: make note type id not be a full field\n\n    // The following ensures that the message content contains at least the minimum number of fields required for a\n    // valid partial note private message. (Refer to the description of\n    // PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN for more information about these fields.)\n    assert(\n        msg_content.len() >= PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN,\n        f\"Invalid private note message: all partial note private messages must have at least {PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN} fields\",\n    );\n\n    // If PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN is changed, causing the assertion below to fail, then the\n    // destructuring of the partial note private message encoding below must be updated as well.\n    std::static_assert(\n        PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN == 4,\n        \"unexpected value for PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN\",\n    );\n\n    // We currently have four fields that are not the partial note's packed representation,\n    // which are the owner, the storage slot, the randomness, and the note completion log tag.\n    let owner = AztecAddress::from_field(msg_content.get(\n        PARTIAL_NOTE_PRIVATE_MSG_CONTENT_OWNER_INDEX,\n    ));\n    let storage_slot = msg_content.get(PARTIAL_NOTE_PRIVATE_MSG_CONTENT_STORAGE_SLOT_INDEX);\n    let randomness = msg_content.get(PARTIAL_NOTE_PRIVATE_MSG_CONTENT_RANDOMNESS_INDEX);\n    let note_completion_log_tag =\n        msg_content.get(PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NOTE_COMPLETION_LOG_TAG_INDEX);\n\n    let packed_private_note_content: BoundedVec<Field, MAX_PARTIAL_NOTE_PRIVATE_PACKED_LEN> = array::subbvec(\n        msg_content,\n        PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN,\n    );\n\n    DeliveredPendingPartialNote {\n        note_completion_log_tag,\n        owner,\n        storage_slot,\n        randomness,\n        note_type_id,\n        packed_private_note_content,\n        recipient,\n    }\n}\n","path":"/home/filip/nargo/github.com/AztecProtocol/aztec-packages/v3.0.1-rc.1/noir-projects/aztec-nr/aztec/src/messages/discovery/partial_notes.nr"},"128":{"source":"use crate::{\n    event::event_selector::EventSelector,\n    messages::{encoding::MAX_MESSAGE_CONTENT_LEN, processing::enqueue_event_for_validation},\n    utils::array,\n};\nuse protocol_types::{\n    address::AztecAddress, constants::GENERATOR_INDEX__EVENT_COMMITMENT,\n    hash::poseidon2_hash_with_separator_bounded_vec, traits::FromField,\n};\n\n/// The number of fields in a private event message content that are not the event's serialized representation\n/// (1 field for randomness).\nglobal PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN: u32 = 1;\n\n/// The maximum length of the packed representation of an event's contents. This is limited by private log size,\n/// encryption overhead and extra fields in the message (e.g. message type id, randomness, etc.).\npub global MAX_EVENT_SERIALIZED_LEN: u32 =\n    MAX_MESSAGE_CONTENT_LEN - PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN;\n\npub unconstrained fn process_private_event_msg(\n    contract_address: AztecAddress,\n    recipient: AztecAddress,\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n    tx_hash: Field,\n) {\n    // In the case of events, the msg metadata is the event selector.\n    let event_type_id = EventSelector::from_field(msg_metadata as Field);\n\n    assert(\n        msg_content.len() > PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN,\n        f\"Invalid private event message: all private event messages must have at least {PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN} fields\",\n    );\n\n    // If PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN is changed, causing the assertion below to fail, then the\n    // destructuring of the private event message encoding below must be updated as well.\n    std::static_assert(\n        PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN == 1,\n        \"unexpected value for PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN\",\n    );\n\n    let serialized_event_with_randomness = msg_content;\n\n    let event_commitment = poseidon2_hash_with_separator_bounded_vec(\n        serialized_event_with_randomness,\n        GENERATOR_INDEX__EVENT_COMMITMENT,\n    );\n\n    // Randomness was injected into the event payload in `emit_event_in_private` but we have already used it\n    // to compute the event commitment, so we can safely discard it now.\n    let serialized_event = array::subbvec(\n        serialized_event_with_randomness,\n        PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN,\n    );\n\n    enqueue_event_for_validation(\n        contract_address,\n        event_type_id,\n        serialized_event,\n        event_commitment,\n        tx_hash,\n        recipient,\n    );\n}\n","path":"/home/filip/nargo/github.com/AztecProtocol/aztec-packages/v3.0.1-rc.1/noir-projects/aztec-nr/aztec/src/messages/discovery/private_events.nr"},"129":{"source":"use crate::{\n    messages::{\n        discovery::{ComputeNoteHashAndNullifier, nonce_discovery::attempt_note_nonce_discovery},\n        encoding::MAX_MESSAGE_CONTENT_LEN,\n        processing::enqueue_note_for_validation,\n    },\n    utils::array,\n};\nuse protocol_types::{\n    address::AztecAddress, constants::MAX_NOTE_HASHES_PER_TX, debug_log::debug_log_format,\n    traits::FromField,\n};\n\n/// The number of fields in a private note message content that are not the note's packed representation.\n// See the call to `std::static_assert` below to see what's in these fields.\nglobal PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN: u32 = 3;\nglobal PRIVATE_NOTE_MSG_CONTENT_OWNER_INDEX: u32 = 0;\nglobal PRIVATE_NOTE_MSG_CONTENT_STORAGE_SLOT_INDEX: u32 = 1;\nglobal PRIVATE_NOTE_MSG_CONTENT_RANDOMNESS_INDEX: u32 = 2;\n\n/// The maximum length of the packed representation of a note's contents. This is limited by private log size,\n/// encryption overhead and extra fields in the message (e.g. message type id, storage slot, randomness, etc.).\npub global MAX_NOTE_PACKED_LEN: u32 =\n    MAX_MESSAGE_CONTENT_LEN - PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN;\n\npub unconstrained fn process_private_note_msg<Env>(\n    contract_address: AztecAddress,\n    tx_hash: Field,\n    unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    first_nullifier_in_tx: Field,\n    recipient: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n) {\n    let (note_type_id, owner, storage_slot, randomness, packed_note) =\n        decode_private_note_msg(msg_metadata, msg_content);\n\n    attempt_note_discovery(\n        contract_address,\n        tx_hash,\n        unique_note_hashes_in_tx,\n        first_nullifier_in_tx,\n        recipient,\n        compute_note_hash_and_nullifier,\n        owner,\n        storage_slot,\n        randomness,\n        note_type_id,\n        packed_note,\n    );\n}\n\n/// Attempts discovery of a note given information about its contents and the transaction in which it is\n/// suspected the note was created.\npub unconstrained fn attempt_note_discovery<Env>(\n    contract_address: AztecAddress,\n    tx_hash: Field,\n    unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    first_nullifier_in_tx: Field,\n    recipient: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    owner: AztecAddress,\n    storage_slot: Field,\n    randomness: Field,\n    note_type_id: Field,\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n) {\n    let discovered_notes = attempt_note_nonce_discovery(\n        unique_note_hashes_in_tx,\n        first_nullifier_in_tx,\n        compute_note_hash_and_nullifier,\n        contract_address,\n        owner,\n        storage_slot,\n        randomness,\n        note_type_id,\n        packed_note,\n    );\n\n    debug_log_format(\n        \"Discovered {0} notes from a private message\",\n        [discovered_notes.len() as Field],\n    );\n\n    discovered_notes.for_each(|discovered_note| {\n        enqueue_note_for_validation(\n            contract_address,\n            owner,\n            storage_slot,\n            randomness,\n            discovered_note.note_nonce,\n            packed_note,\n            discovered_note.note_hash,\n            discovered_note.inner_nullifier,\n            tx_hash,\n            recipient,\n        );\n    });\n}\n\nfn decode_private_note_msg(\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n) -> (Field, AztecAddress, Field, Field, BoundedVec<Field, MAX_NOTE_PACKED_LEN>) {\n    let note_type_id = msg_metadata as Field; // TODO: make note type id not be a full field\n\n    assert(\n        msg_content.len() > PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN,\n        f\"Invalid private note message: all private note messages must have at least {PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN} fields\",\n    );\n\n    // If PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN is changed, causing the assertion below to fail, then the\n    // destructuring of the private note message encoding below must be updated as well.\n    std::static_assert(\n        PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN == 3,\n        \"unexpected value for PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN\",\n    );\n\n    // We currently have two fields that are not the note's packed representation, which are the owner and the storage slot.\n    let owner = AztecAddress::from_field(msg_content.get(PRIVATE_NOTE_MSG_CONTENT_OWNER_INDEX));\n    let storage_slot = msg_content.get(PRIVATE_NOTE_MSG_CONTENT_STORAGE_SLOT_INDEX);\n    let randomness = msg_content.get(PRIVATE_NOTE_MSG_CONTENT_RANDOMNESS_INDEX);\n    let packed_note = array::subbvec(msg_content, PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN);\n\n    (note_type_id, owner, storage_slot, randomness, packed_note)\n}\n","path":"/home/filip/nargo/github.com/AztecProtocol/aztec-packages/v3.0.1-rc.1/noir-projects/aztec-nr/aztec/src/messages/discovery/private_notes.nr"},"130":{"source":"use crate::messages::{\n    discovery::{\n        ComputeNoteHashAndNullifier, partial_notes::process_partial_note_private_msg,\n        private_events::process_private_event_msg, private_notes::process_private_note_msg,\n    },\n    encoding::{decode_message, MESSAGE_CIPHERTEXT_LEN, MESSAGE_PLAINTEXT_LEN},\n    encryption::{aes128::AES128, message_encryption::MessageEncryption},\n    msg_type::{\n        PARTIAL_NOTE_PRIVATE_MSG_TYPE_ID, PRIVATE_EVENT_MSG_TYPE_ID, PRIVATE_NOTE_MSG_TYPE_ID,\n    },\n    processing::message_context::MessageContext,\n};\n\nuse protocol_types::{address::AztecAddress, debug_log::{debug_log, debug_log_format}};\n\n/// Processes a message that can contain notes, partial notes, or events.\n///\n/// Notes result in nonce discovery being performed prior to delivery, which requires knowledge of the transaction hash\n/// in which the notes would've been created (typically the same transaction in which the log was emitted), along with\n/// the list of unique note hashes in said transaction and the `compute_note_hash_and_nullifier` function. Once\n/// discovered, the notes are enqueued for validation.\n///\n/// Partial notes result in a pending partial note entry being stored in a PXE capsule, which will later be retrieved to\n/// search for the note's completion public log.\n///\n/// Events are processed by computing an event commitment from the serialized event data and its randomness field, then\n/// enqueueing the event data and commitment for validation.\npub unconstrained fn process_message_ciphertext<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    message_ciphertext: BoundedVec<Field, MESSAGE_CIPHERTEXT_LEN>,\n    message_context: MessageContext,\n) {\n    let message_plaintext_option = AES128::decrypt(message_ciphertext, message_context.recipient);\n\n    if message_plaintext_option.is_some() {\n        process_message_plaintext(\n            contract_address,\n            compute_note_hash_and_nullifier,\n            message_plaintext_option.unwrap(),\n            message_context,\n        );\n    } else {\n        debug_log_format(\n            \"Found invalid message from tx {0}, ignoring\",\n            [message_context.tx_hash],\n        );\n    }\n}\n\npub unconstrained fn process_message_plaintext<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    message_plaintext: BoundedVec<Field, MESSAGE_PLAINTEXT_LEN>,\n    message_context: MessageContext,\n) {\n    // The first thing to do after decrypting the message is to determine what type of message we're processing. We\n    // have 3 message types: private notes, partial notes and events.\n\n    // We decode the message to obtain the message type id, metadata and content.\n    let (msg_type_id, msg_metadata, msg_content) = decode_message(message_plaintext);\n\n    if msg_type_id == PRIVATE_NOTE_MSG_TYPE_ID {\n        debug_log(\"Processing private note msg\");\n\n        process_private_note_msg(\n            contract_address,\n            message_context.tx_hash,\n            message_context.unique_note_hashes_in_tx,\n            message_context.first_nullifier_in_tx,\n            message_context.recipient,\n            compute_note_hash_and_nullifier,\n            msg_metadata,\n            msg_content,\n        );\n    } else if msg_type_id == PARTIAL_NOTE_PRIVATE_MSG_TYPE_ID {\n        debug_log(\"Processing partial note private msg\");\n\n        process_partial_note_private_msg(\n            contract_address,\n            message_context.recipient,\n            msg_metadata,\n            msg_content,\n        );\n    } else if msg_type_id == PRIVATE_EVENT_MSG_TYPE_ID {\n        debug_log(\"Processing private event msg\");\n\n        process_private_event_msg(\n            contract_address,\n            message_context.recipient,\n            msg_metadata,\n            msg_content,\n            message_context.tx_hash,\n        );\n    } else {\n        debug_log_format(\"Unknown msg type id {0}\", [msg_type_id as Field]);\n    }\n}\n","path":"/home/filip/nargo/github.com/AztecProtocol/aztec-packages/v3.0.1-rc.1/noir-projects/aztec-nr/aztec/src/messages/discovery/process_message.nr"},"131":{"source":"// TODO(#12750): don't make these values assume we're using AES.\nuse crate::utils::array;\nuse protocol_types::constants::PRIVATE_LOG_CIPHERTEXT_LEN;\n\n// We reassign to the constant here to communicate the distinction between a log and a message. In Aztec.nr, unlike in\n// protocol circuits, we have a concept of a message that can be emitted either as a private log or as an offchain\n// message. Message is a piece of data that is to be eventually delivered to a contract via the `process_message(...)`\n// utility function function that is injected by the #[aztec] macro.\n// Note: PRIVATE_LOG_CIPHERTEXT_LEN is an amount of fields,\n// so MESSAGE_CIPHERTEXT_LEN is the size of the message in fields.\npub global MESSAGE_CIPHERTEXT_LEN: u32 = PRIVATE_LOG_CIPHERTEXT_LEN;\n\n// TODO(#12750): The global variables below should not be here as they are AES128 specific.\n// ciphertext_length (2) + 14 bytes pkcs#7 AES padding.\npub(crate) global HEADER_CIPHERTEXT_SIZE_IN_BYTES: u32 = 16;\n\npub global EPH_PK_X_SIZE_IN_FIELDS: u32 = 1;\npub global EPH_PK_SIGN_BYTE_SIZE_IN_BYTES: u32 = 1;\n\n// (17 - 1) * 31 - 16 - 1 = 479\n// Note: We multiply by 31 because ciphertext bytes are stored in fields using bytes_to_fields, which packs 31 bytes per\n// field (since a Field is ~254 bits and can safely store 31 whole bytes).\nglobal MESSAGE_PLAINTEXT_SIZE_IN_BYTES: u32 = (MESSAGE_CIPHERTEXT_LEN - EPH_PK_X_SIZE_IN_FIELDS)\n    * 31\n    - HEADER_CIPHERTEXT_SIZE_IN_BYTES\n    - EPH_PK_SIGN_BYTE_SIZE_IN_BYTES;\n// The plaintext bytes represent Field values that were originally serialized using fields_to_bytes, which converts each\n// Field to 32 bytes. To convert the plaintext bytes back to fields, we divide by 32.\n// 479 / 32 = 14\npub global MESSAGE_PLAINTEXT_LEN: u32 = MESSAGE_PLAINTEXT_SIZE_IN_BYTES / 32;\n\npub global MESSAGE_EXPANDED_METADATA_LEN: u32 = 1;\n\n// The standard message layout is composed of:\n//  - an initial field called the 'expanded metadata'\n//  - an arbitrary number of fields following that called the 'message content'\n//\n// ```\n// message: [ msg_expanded_metadata, ...msg_content ]\n// ```\n//\n// The expanded metadata itself is interpreted as a u128, of which:\n//  - the upper 64 bits are the message type id\n//  - the lower 64 bits are called the 'message metadata'\n//\n// ```\n// msg_expanded_metadata: [  msg_type_id    |  msg_metadata  ]\n//                        <---  64 bits --->|<--- 64 bits --->\n// ```\n//\n// The meaning of the message metadata and message content depend on the value of the message type id. Note that there\n// is nothing special about the message metadata, it _can_ be considered part of the content. It just has a different\n// name to make it distinct from the message content given that it is not a full field.\n\n/// The maximum length of a message's content, i.e. not including the expanded message metadata.\npub global MAX_MESSAGE_CONTENT_LEN: u32 = MESSAGE_PLAINTEXT_LEN - MESSAGE_EXPANDED_METADATA_LEN;\n\n/// Encodes a message following aztec-nr's standard message encoding. This message can later be decoded with\n/// `decode_message` to retrieve the original values.\n///\n/// - The `msg_type` is an identifier that groups types of messages that are all processed the same way, e.g. private\n/// notes or events. Possible values are defined in `aztec::messages::msg_type`.\n/// - The `msg_metadata` and `msg_content` are the values stored in the message, whose meaning depends on the\n///  `msg_type`. The only special thing about `msg_metadata` that separates it from `msg_content` is that it is a u64\n/// instead of a full Field (due to details of how messages are encoded), allowing applications that can fit values into\n/// this smaller variable to achieve higher data efficiency.\npub fn encode_message<let N: u32>(\n    msg_type: u64,\n    msg_metadata: u64,\n    msg_content: [Field; N],\n) -> [Field; (N + MESSAGE_EXPANDED_METADATA_LEN)] {\n    std::static_assert(\n        msg_content.len() <= MAX_MESSAGE_CONTENT_LEN,\n        \"Invalid message content: it must have a length of at most MAX_MESSAGE_CONTENT_LEN\",\n    );\n\n    // If MESSAGE_EXPANDED_METADATA_LEN is changed, causing the assertion below to fail, then the destructuring of\n    // the message encoding below must be updated as well.\n    std::static_assert(\n        MESSAGE_EXPANDED_METADATA_LEN == 1,\n        \"unexpected value for MESSAGE_EXPANDED_METADATA_LEN\",\n    );\n    let mut message: [Field; (N + MESSAGE_EXPANDED_METADATA_LEN)] = std::mem::zeroed();\n\n    message[0] = to_expanded_metadata(msg_type, msg_metadata);\n    for i in 0..msg_content.len() {\n        message[MESSAGE_EXPANDED_METADATA_LEN + i] = msg_content[i];\n    }\n\n    message\n}\n\n/// Decodes a standard aztec-nr message, i.e. one created via `encode_message`, returning the original encoded values.\n///\n/// Note that `encode_message` returns a fixed size array while this function takes a `BoundedVec`: this is because\n/// prior to decoding the message type is unknown, and consequentially not known at compile time. If working with\n/// fixed-size messages, consider using `BoundedVec::from_array` to convert them.\npub unconstrained fn decode_message(\n    message: BoundedVec<Field, MESSAGE_PLAINTEXT_LEN>,\n) -> (u64, u64, BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>) {\n    assert(\n        message.len() >= MESSAGE_EXPANDED_METADATA_LEN,\n        f\"Invalid message: it must have at least {MESSAGE_EXPANDED_METADATA_LEN} fields\",\n    );\n\n    // If MESSAGE_EXPANDED_METADATA_LEN is changed, causing the assertion below to fail, then the destructuring of\n    // the message encoding below must be updated as well.\n    std::static_assert(\n        MESSAGE_EXPANDED_METADATA_LEN == 1,\n        \"unexpected value for MESSAGE_EXPANDED_METADATA_LEN\",\n    );\n\n    let msg_expanded_metadata = message.get(0);\n    let (msg_type_id, msg_metadata) = from_expanded_metadata(msg_expanded_metadata);\n    let msg_content = array::subbvec(message, MESSAGE_EXPANDED_METADATA_LEN);\n\n    (msg_type_id, msg_metadata, msg_content)\n}\n\nglobal U64_SHIFT_MULTIPLIER: Field = 2.pow_32(64);\n\nfn to_expanded_metadata(msg_type: u64, msg_metadata: u64) -> Field {\n    // We use multiplication instead of bit shifting operations to shift the type bits as bit shift operations are\n    // expensive in circuits.\n    let type_field: Field = (msg_type as Field) * U64_SHIFT_MULTIPLIER;\n    let msg_metadata_field = msg_metadata as Field;\n\n    type_field + msg_metadata_field\n}\n\nfn from_expanded_metadata(input: Field) -> (u64, u64) {\n    input.assert_max_bit_size::<128>();\n    let msg_metadata = (input as u64);\n    let msg_type = ((input - (msg_metadata as Field)) / U64_SHIFT_MULTIPLIER) as u64;\n    // Use division instead of bit shift since bit shifts are expensive in circuits\n    (msg_type, msg_metadata)\n}\n\nmod tests {\n    use crate::utils::array::subarray::subarray;\n    use super::{\n        decode_message, encode_message, from_expanded_metadata, MAX_MESSAGE_CONTENT_LEN,\n        to_expanded_metadata,\n    };\n\n    global U64_MAX: u64 = (2.pow_32(64) - 1) as u64;\n    global U128_MAX: Field = (2.pow_32(128) - 1);\n\n    #[test]\n    unconstrained fn encode_decode_empty_message(msg_type: u64, msg_metadata: u64) {\n        let encoded = encode_message(msg_type, msg_metadata, []);\n        let (decoded_msg_type, decoded_msg_metadata, decoded_msg_content) =\n            decode_message(BoundedVec::from_array(encoded));\n\n        assert_eq(decoded_msg_type, msg_type);\n        assert_eq(decoded_msg_metadata, msg_metadata);\n        assert_eq(decoded_msg_content.len(), 0);\n    }\n\n    #[test]\n    unconstrained fn encode_decode_short_message(\n        msg_type: u64,\n        msg_metadata: u64,\n        msg_content: [Field; MAX_MESSAGE_CONTENT_LEN / 2],\n    ) {\n        let encoded = encode_message(msg_type, msg_metadata, msg_content);\n        let (decoded_msg_type, decoded_msg_metadata, decoded_msg_content) =\n            decode_message(BoundedVec::from_array(encoded));\n\n        assert_eq(decoded_msg_type, msg_type);\n        assert_eq(decoded_msg_metadata, msg_metadata);\n        assert_eq(decoded_msg_content.len(), msg_content.len());\n        assert_eq(subarray(decoded_msg_content.storage(), 0), msg_content);\n    }\n\n    #[test]\n    unconstrained fn encode_decode_full_message(\n        msg_type: u64,\n        msg_metadata: u64,\n        msg_content: [Field; MAX_MESSAGE_CONTENT_LEN],\n    ) {\n        let encoded = encode_message(msg_type, msg_metadata, msg_content);\n        let (decoded_msg_type, decoded_msg_metadata, decoded_msg_content) =\n            decode_message(BoundedVec::from_array(encoded));\n\n        assert_eq(decoded_msg_type, msg_type);\n        assert_eq(decoded_msg_metadata, msg_metadata);\n        assert_eq(decoded_msg_content.len(), msg_content.len());\n        assert_eq(subarray(decoded_msg_content.storage(), 0), msg_content);\n    }\n\n    #[test]\n    unconstrained fn to_expanded_metadata_packing() {\n        // Test case 1: All bits set\n        let packed = to_expanded_metadata(U64_MAX, U64_MAX);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 2: Only log type bits set\n        let packed = to_expanded_metadata(U64_MAX, 0);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, 0);\n\n        // Test case 3: Only msg_metadata bits set\n        let packed = to_expanded_metadata(0, U64_MAX);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 4: No bits set\n        let packed = to_expanded_metadata(0, 0);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, 0);\n    }\n\n    #[test]\n    unconstrained fn from_expanded_metadata_packing() {\n        // Test case 1: All bits set\n        let input = U128_MAX as Field;\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 2: Only log type bits set\n        let input = (U128_MAX - U64_MAX as Field);\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, 0);\n\n        // Test case 3: Only msg_metadata bits set\n        let input = U64_MAX as Field;\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 4: No bits set\n        let input = 0;\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, 0);\n    }\n\n    #[test]\n    unconstrained fn to_from_expanded_metadata(original_msg_type: u64, original_msg_metadata: u64) {\n        let packed = to_expanded_metadata(original_msg_type, original_msg_metadata);\n        let (unpacked_msg_type, unpacked_msg_metadata) = from_expanded_metadata(packed);\n\n        assert_eq(original_msg_type, unpacked_msg_type);\n        assert_eq(original_msg_metadata, unpacked_msg_metadata);\n    }\n}\n","path":"/home/filip/nargo/github.com/AztecProtocol/aztec-packages/v3.0.1-rc.1/noir-projects/aztec-nr/aztec/src/messages/encoding.nr"},"132":{"source":"use dep::protocol_types::{\n    address::AztecAddress,\n    constants::{GENERATOR_INDEX__SYMMETRIC_KEY, GENERATOR_INDEX__SYMMETRIC_KEY_2},\n    hash::poseidon2_hash_with_separator,\n    point::Point,\n    public_keys::AddressPoint,\n};\n\nuse crate::{\n    keys::{ecdh_shared_secret::derive_ecdh_shared_secret, ephemeral::generate_ephemeral_key_pair},\n    messages::{\n        encoding::{\n            EPH_PK_SIGN_BYTE_SIZE_IN_BYTES, EPH_PK_X_SIZE_IN_FIELDS,\n            HEADER_CIPHERTEXT_SIZE_IN_BYTES, MESSAGE_CIPHERTEXT_LEN, MESSAGE_PLAINTEXT_LEN,\n        },\n        encryption::message_encryption::MessageEncryption,\n        logs::arithmetic_generics_utils::{\n            get_arr_of_size__message_bytes__from_PT,\n            get_arr_of_size__message_bytes_padding__from_PT,\n        },\n    },\n    oracle::{\n        aes128_decrypt::aes128_decrypt_oracle, random::random, shared_secret::get_shared_secret,\n    },\n    utils::{\n        array,\n        conversion::{\n            bytes_to_fields::{bytes_from_fields, bytes_to_fields},\n            fields_to_bytes::{fields_from_bytes, fields_to_bytes},\n        },\n        point::{get_sign_of_point, point_from_x_coord_and_sign},\n        random::get_random_bytes,\n    },\n};\n\nuse std::aes128::aes128_encrypt;\n\n/**\n * Computes N close-to-uniformly-random 256 bits from a given ECDH shared_secret.\n *\n * NEVER re-use the same iv and sym_key.\n * DO NOT call this function more than once with the same shared_secret.\n *\n * This function is only known to be safe if shared_secret is computed by combining a \n * random ephemeral key with an address point. See big comment within the body of the function.\n * See big comment within the body of the function.\n */\nfn extract_many_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_poseidon2_unsafe<let N: u32>(\n    shared_secret: Point,\n) -> [[u8; 32]; N] {\n    /*\n     * Unsafe because of https://eprint.iacr.org/2010/264.pdf Page 13, Lemma 2 (and the * two paragraphs below it).\n     *\n     * If you call this function, you need to be careful and aware of how the arg\n     * `shared_secret` has been derived.\n     *\n     * The paper says that the way you derive aes keys and IVs should be fine with poseidon2\n     * (modelled as a RO), as long as you _don't_ use Poseidon2 as a PRG to generate the * two exponents x & y which multiply to the shared secret S:\n     *\n     * S = [x*y]*G.\n     *\n     * (Otherwise, you would have to \"key\" poseidon2, i.e. generate a uniformly string K\n     * which can be public and compute Hash(x) as poseidon(K,x)).\n     * In that lemma, k would be 2*254=508, and m would be the number of points on the * grumpkin curve (which is close to r according to the Hasse bound).\n     *\n     * Our shared secret S is [esk * address_sk] * G, and the question is: * Can we compute hash(S) using poseidon2 instead of sha256?\n     *\n     * Well, esk is random and not generated with poseidon2, so that's good.\n     * What about address_sk?\n     * Well, address_sk = poseidon2(stuff) + ivsk, so there was some\n     * discussion about whether address_sk is independent of poseidon2.\n     * Given that ivsk is random and independent of poseidon2, the address_sk is also\n     * independent of poseidon2.\n     *\n     * Tl;dr: we believe it's safe to hash S = [esk * address_sk] * G using poseidon2,\n     * in order to derive a symmetric key.\n     *\n     * If you're calling this function for a differently-derived `shared_secret`, be\n     * careful.\n     *\n     */\n\n    /* The output of this function needs to be 32 random bytes.\n     * A single field won't give us 32 bytes of entropy.\n     * So we compute two \"random\" fields, by poseidon-hashing with two different\n     * generators.\n     * We then extract the last 16 (big endian) bytes of each \"random\" field.\n     * Note: we use to_be_bytes because it's slightly more efficient. But we have to\n     * be careful not to take bytes from the \"big end\", because the \"big\" byte is\n     * not uniformly random over the byte: it only has < 6 bits of randomness, because\n     * it's the big end of a 254-bit field element.\n     */\n\n    let mut all_bytes: [[u8; 32]; N] = std::mem::zeroed();\n    // We restrict N to be < 2^8, because of how we compute the domain separator\n    // from k below (where k <= N must be 8 bits). In practice, it's extremely\n    // unlikely that an app will want to compute >= 256 ciphertexts.\n    std::static_assert(N < 256, \"N too large\");\n    for k in 0..N {\n        // We augment the domain separator with the loop index, so that we can\n        // generate N lots of randomness.\n        let k_shift = (k as u16 << 8);\n        let separator_1 = k_shift + GENERATOR_INDEX__SYMMETRIC_KEY as u16;\n        let separator_2 = k_shift + GENERATOR_INDEX__SYMMETRIC_KEY_2 as u16;\n\n        let rand1: Field =\n            poseidon2_hash_with_separator([shared_secret.x, shared_secret.y], separator_1);\n        let rand2: Field =\n            poseidon2_hash_with_separator([shared_secret.x, shared_secret.y], separator_2);\n\n        let rand1_bytes: [u8; 32] = rand1.to_be_bytes();\n        let rand2_bytes: [u8; 32] = rand2.to_be_bytes();\n\n        let mut bytes: [u8; 32] = [0; 32];\n        for i in 0..16 {\n            // We take bytes from the \"little end\" of the be-bytes arrays:\n            let j = 32 - i - 1;\n            bytes[i] = rand1_bytes[j];\n            bytes[16 + i] = rand2_bytes[j];\n        }\n\n        all_bytes[k] = bytes;\n    }\n\n    all_bytes\n}\n\nfn derive_aes_symmetric_key_and_iv_from_uniformly_random_256_bits<let N: u32>(\n    many_random_256_bits: [[u8; 32]; N],\n) -> [([u8; 16], [u8; 16]); N] {\n    // Many (sym_key, iv) pairs:\n    let mut many_pairs: [([u8; 16], [u8; 16]); N] = std::mem::zeroed();\n    for k in 0..N {\n        let random_256_bits = many_random_256_bits[k];\n        let mut sym_key = [0; 16];\n        let mut iv = [0; 16];\n        for i in 0..16 {\n            sym_key[i] = random_256_bits[i];\n            iv[i] = random_256_bits[i + 16];\n        }\n        many_pairs[k] = (sym_key, iv);\n    }\n\n    many_pairs\n}\n\npub fn derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_poseidon2_unsafe<let N: u32>(\n    shared_secret: Point,\n) -> [([u8; 16], [u8; 16]); N] {\n    let many_random_256_bits: [[u8; 32]; N] = extract_many_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_poseidon2_unsafe(\n        shared_secret,\n    );\n\n    derive_aes_symmetric_key_and_iv_from_uniformly_random_256_bits(many_random_256_bits)\n}\n\npub struct AES128 {}\n\nimpl MessageEncryption for AES128 {\n    fn encrypt<let PlaintextLen: u32>(\n        plaintext: [Field; PlaintextLen],\n        recipient: AztecAddress,\n    ) -> [Field; MESSAGE_CIPHERTEXT_LEN] {\n        // AES 128 operates on bytes, not fields, so we need to convert the fields to bytes.\n        // (This process is then reversed when processing the message in `do_process_message`)\n        let plaintext_bytes = fields_to_bytes(plaintext);\n\n        // *****************************************************************************\n        // Compute the shared secret\n        // *****************************************************************************\n\n        let (eph_sk, eph_pk) = generate_ephemeral_key_pair();\n\n        let eph_pk_sign_byte: u8 = get_sign_of_point(eph_pk) as u8;\n\n        // (not to be confused with the tagging shared secret)\n        // TODO (#17158): Currently we unwrap the Option returned by derive_ecdh_shared_secret.\n        // We need to handle the case where the ephemeral public key is invalid to prevent potential DoS vectors.\n        let ciphertext_shared_secret = derive_ecdh_shared_secret(\n            eph_sk,\n            recipient\n                .to_address_point()\n                .unwrap_or(\n                    // Safety: if the recipient is an invalid address, then it is not possible to encrypt a message for\n                    // them because we cannot establish a shared secret. This is never expected to occur during normal\n                    // operation. However, it is technically possible for us to receive an invalid address, and we must\n                    // therefore handle it.\n                    // We could simply fail, but that'd introduce a potential security issue in which an attacker forces\n                    // a contract to encrypt a message for an invalid address, resulting in an impossible transaction -\n                    // this is sometimes called a 'king of the hill' attack.\n                    // We choose instead to not fail and encrypt the plaintext regardless using the shared secret that\n                    // results from a random valid address. The sender is free to choose this address and hence shared\n                    // secret, but this has no security implications as they already know not only the full plaintext\n                    // but also the ephemeral private key anyway.\n                    unsafe { random_address_point() },\n                )\n                .inner,\n        );\n        // TODO: also use this shared secret for deriving note randomness.\n\n        // *****************************************************************************\n        // Convert the plaintext into whatever format the encryption function expects\n        // *****************************************************************************\n\n        // Already done for this strategy: AES expects bytes.\n\n        // *****************************************************************************\n        // Encrypt the plaintext\n        // *****************************************************************************\n\n        // It is safe to call the `unsafe` function here, because we know the `shared_secret`\n        // was derived using an AztecAddress (the recipient). See the block comment\n        // at the start of this unsafe target function for more info.\n        let pairs = derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_poseidon2_unsafe::<2>(\n            ciphertext_shared_secret,\n        );\n        let (body_sym_key, body_iv) = pairs[0];\n        let (header_sym_key, header_iv) = pairs[1];\n\n        let ciphertext_bytes = aes128_encrypt(plaintext_bytes, body_iv, body_sym_key);\n\n        // |full_pt| = |pt_length| + |pt|\n        // |pt_aes_padding| = 16 - (|full_pt| % 16)\n        // or... since a % b is the same as a - b * (a // b) (integer division), so:\n        // |pt_aes_padding| = 16 - (|full_pt| - 16 * (|full_pt| // 16))\n        // |ct| = |full_pt| + |pt_aes_padding|\n        //      = |full_pt| + 16 - (|full_pt| - 16 * (|full_pt| // 16))\n        //      = 16 + 16 * (|full_pt| // 16)\n        //      = 16 * (1 + |full_pt| // 16)\n        std::static_assert(\n            ciphertext_bytes.len() == 16 * (1 + (PlaintextLen * 32) / 16),\n            \"unexpected ciphertext length\",\n        );\n\n        // *****************************************************************************\n        // Compute the header ciphertext\n        // *****************************************************************************\n\n        // Header contains only the length of the ciphertext stored in 2 bytes.\n        let mut header_plaintext: [u8; 2] = [0 as u8; 2];\n        let ciphertext_bytes_length = ciphertext_bytes.len();\n        header_plaintext[0] = (ciphertext_bytes_length >> 8) as u8;\n        header_plaintext[1] = ciphertext_bytes_length as u8;\n\n        // Note: the aes128_encrypt builtin fn automatically appends bytes to the\n        // input, according to pkcs#7; hence why the output `header_ciphertext_bytes` is 16\n        // bytes larger than the input in this case.\n        let header_ciphertext_bytes = aes128_encrypt(header_plaintext, header_iv, header_sym_key);\n        // I recall that converting a slice to an array incurs constraints, so I'll check the length this way instead:\n        std::static_assert(\n            header_ciphertext_bytes.len() == HEADER_CIPHERTEXT_SIZE_IN_BYTES,\n            \"unexpected ciphertext header length\",\n        );\n\n        // *****************************************************************************\n        // Prepend / append more bytes of data to the ciphertext, before converting back\n        // to fields.\n        // *****************************************************************************\n\n        let mut message_bytes_padding_to_mult_31 =\n            get_arr_of_size__message_bytes_padding__from_PT::<PlaintextLen * 32>();\n        // Safety: this randomness won't be constrained to be random. It's in the\n        // interest of the executor of this fn to encrypt with random bytes.\n        message_bytes_padding_to_mult_31 = unsafe { get_random_bytes() };\n\n        let mut message_bytes = get_arr_of_size__message_bytes__from_PT::<PlaintextLen * 32>();\n\n        std::static_assert(\n            message_bytes.len() % 31 == 0,\n            \"Unexpected error: message_bytes.len() should be divisible by 31, by construction.\",\n        );\n\n        message_bytes[0] = eph_pk_sign_byte;\n        let mut offset = 1;\n        for i in 0..header_ciphertext_bytes.len() {\n            message_bytes[offset + i] = header_ciphertext_bytes[i];\n        }\n        offset += header_ciphertext_bytes.len();\n\n        for i in 0..ciphertext_bytes.len() {\n            message_bytes[offset + i] = ciphertext_bytes[i];\n        }\n        offset += ciphertext_bytes.len();\n\n        for i in 0..message_bytes_padding_to_mult_31.len() {\n            message_bytes[offset + i] = message_bytes_padding_to_mult_31[i];\n        }\n        offset += message_bytes_padding_to_mult_31.len();\n\n        // Ideally we would be able to have a static assert where we check that the offset would be such that we've\n        // written to the entire log_bytes array, but we cannot since Noir does not treat the offset as a comptime\n        // value (despite the values that it goes through being known at each stage). We instead check that the\n        // computation used to obtain the offset computes the expected value (which we _can_ do in a static check), and\n        // then add a cheap runtime check to also validate that the offset matches this.\n        std::static_assert(\n            1\n                + header_ciphertext_bytes.len()\n                + ciphertext_bytes.len()\n                + message_bytes_padding_to_mult_31.len()\n                == message_bytes.len(),\n            \"unexpected message length\",\n        );\n        assert(offset == message_bytes.len(), \"unexpected encrypted message length\");\n\n        // *****************************************************************************\n        // Convert bytes back to fields\n        // *****************************************************************************\n\n        // TODO(#12749): As Mike pointed out, we need to make messages produced by different encryption schemes\n        // indistinguishable from each other and for this reason the output here and in the last for-loop of this function\n        // should cover a full field.\n        let message_bytes_as_fields = bytes_to_fields(message_bytes);\n\n        // *****************************************************************************\n        // Prepend / append fields, to create the final message\n        // *****************************************************************************\n\n        let mut ciphertext: [Field; MESSAGE_CIPHERTEXT_LEN] = [0; MESSAGE_CIPHERTEXT_LEN];\n\n        ciphertext[0] = eph_pk.x;\n\n        let mut offset = 1;\n        for i in 0..message_bytes_as_fields.len() {\n            ciphertext[offset + i] = message_bytes_as_fields[i];\n        }\n        offset += message_bytes_as_fields.len();\n\n        for i in offset..MESSAGE_CIPHERTEXT_LEN {\n            // We need to get a random value that fits in 31 bytes to not leak information about the size of the message\n            // (all the \"real\" message fields contain at most 31 bytes because of the way we convert the bytes to fields).\n            // TODO(#12749): Long term, this is not a good solution.\n\n            // Safety: we assume that the sender wants for the message to be private - a malicious one could simply reveal its\n            // contents publicly. It is therefore fine to trust the sender to provide random padding.\n            let field_bytes = unsafe { get_random_bytes::<31>() };\n            ciphertext[i] = Field::from_be_bytes::<31>(field_bytes);\n        }\n\n        ciphertext\n    }\n\n    unconstrained fn decrypt(\n        ciphertext: BoundedVec<Field, MESSAGE_CIPHERTEXT_LEN>,\n        recipient: AztecAddress,\n    ) -> Option<BoundedVec<Field, MESSAGE_PLAINTEXT_LEN>> {\n        let eph_pk_x = ciphertext.get(0);\n\n        let ciphertext_without_eph_pk_x_fields = array::subbvec::<Field, MESSAGE_CIPHERTEXT_LEN, MESSAGE_CIPHERTEXT_LEN - EPH_PK_X_SIZE_IN_FIELDS>(\n            ciphertext,\n            EPH_PK_X_SIZE_IN_FIELDS,\n        );\n\n        // Convert the ciphertext represented as fields to a byte representation (its original format)\n        let ciphertext_without_eph_pk_x = bytes_from_fields(ciphertext_without_eph_pk_x_fields);\n\n        // First byte of the ciphertext represents the ephemeral public key sign\n        let eph_pk_sign_bool = ciphertext_without_eph_pk_x.get(0) != 0;\n\n        // With the sign and the x-coordinate of the ephemeral public key, we can reconstruct the point. This may fail\n        // however, as not all x-coordinates are on the curve. In that case, we simply return `Option::none`.\n        point_from_x_coord_and_sign(eph_pk_x, eph_pk_sign_bool).map(|eph_pk| {\n            // Derive shared secret\n            let ciphertext_shared_secret = get_shared_secret(recipient, eph_pk);\n\n            // Derive symmetric keys:\n            let pairs = derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_poseidon2_unsafe::<2>(\n                ciphertext_shared_secret,\n            );\n            let (body_sym_key, body_iv) = pairs[0];\n            let (header_sym_key, header_iv) = pairs[1];\n\n            // Extract the header ciphertext\n            let header_start = EPH_PK_SIGN_BYTE_SIZE_IN_BYTES; // Skip eph_pk_sign byte\n            let header_ciphertext: [u8; HEADER_CIPHERTEXT_SIZE_IN_BYTES] =\n                array::subarray(ciphertext_without_eph_pk_x.storage(), header_start);\n            // We need to convert the array to a BoundedVec because the oracle expects a BoundedVec as it's designed to work\n            // with messages with unknown length at compile time. This would not be necessary here as the header ciphertext length\n            // is fixed. But we do it anyway to not have to have duplicate oracles.\n            let header_ciphertext_bvec =\n                BoundedVec::<u8, HEADER_CIPHERTEXT_SIZE_IN_BYTES>::from_array(header_ciphertext);\n\n            // Decrypt header\n            let header_plaintext =\n                aes128_decrypt_oracle(header_ciphertext_bvec, header_iv, header_sym_key);\n\n            // Extract ciphertext length from header (2 bytes, big-endian)\n            let ciphertext_length =\n                ((header_plaintext.get(0) as u32) << 8) | (header_plaintext.get(1) as u32);\n\n            // Extract and decrypt main ciphertext\n            let ciphertext_start = header_start + HEADER_CIPHERTEXT_SIZE_IN_BYTES;\n            let ciphertext_with_padding: [u8; (MESSAGE_CIPHERTEXT_LEN - EPH_PK_X_SIZE_IN_FIELDS) * 31 - HEADER_CIPHERTEXT_SIZE_IN_BYTES - EPH_PK_SIGN_BYTE_SIZE_IN_BYTES] =\n                array::subarray(ciphertext_without_eph_pk_x.storage(), ciphertext_start);\n            let ciphertext: BoundedVec<u8, (MESSAGE_CIPHERTEXT_LEN - EPH_PK_X_SIZE_IN_FIELDS) * 31 - HEADER_CIPHERTEXT_SIZE_IN_BYTES - EPH_PK_SIGN_BYTE_SIZE_IN_BYTES> =\n                BoundedVec::from_parts(ciphertext_with_padding, ciphertext_length);\n\n            // Decrypt main ciphertext and return it\n            let plaintext_bytes = aes128_decrypt_oracle(ciphertext, body_iv, body_sym_key);\n\n            // Each field of the original note message was serialized to 32 bytes so we convert the bytes back to fields.\n            fields_from_bytes(plaintext_bytes)\n        })\n    }\n}\n\n/// Produces a random valid address point, i.e. one that is on the curve. This is equivalent to calling\n/// [AztecAddress::to_address_point] on a random valid address.\nunconstrained fn random_address_point() -> AddressPoint {\n    let mut result = std::mem::zeroed();\n\n    loop {\n        // We simply produce random x coordinates until we find one that is on the curve. About half of the x\n        // coordinates fulfill this condition, so this should only take a few iterations at most.\n        let x_coord = random();\n        let point = point_from_x_coord_and_sign(x_coord, true);\n        if point.is_some() {\n            result = AddressPoint { inner: point.unwrap() };\n            break;\n        }\n    }\n\n    result\n}\n\nmod test {\n    use crate::{\n        keys::ecdh_shared_secret::derive_ecdh_shared_secret,\n        messages::{\n            encoding::MESSAGE_PLAINTEXT_LEN, encryption::message_encryption::MessageEncryption,\n        },\n        test::helpers::test_environment::TestEnvironment,\n    };\n    use super::{AES128, random_address_point};\n    use protocol_types::{address::AztecAddress, traits::FromField};\n    use std::{embedded_curve_ops::EmbeddedCurveScalar, test::OracleMock};\n\n    #[test]\n    unconstrained fn encrypt_decrypt_deterministic() {\n        let env = TestEnvironment::new();\n\n        // Message decryption requires oracles that are only available during private execution\n        env.private_context(|_| {\n            let plaintext = [1, 2, 3];\n\n            let recipient = AztecAddress::from_field(\n                0x25afb798ea6d0b8c1618e50fdeafa463059415013d3b7c75d46abf5e242be70c,\n            );\n\n            // Mock random values for deterministic test\n            let eph_sk = 0x1358d15019d4639393d62b97e1588c095957ce74a1c32d6ec7d62fe6705d9538;\n            let _ = OracleMock::mock(\"utilityGetRandomField\").returns(eph_sk).times(1);\n\n            let randomness = 0x0101010101010101010101010101010101010101010101010101010101010101;\n            let _ = OracleMock::mock(\"utilityGetRandomField\").returns(randomness).times(1000000);\n\n            let _ = OracleMock::mock(\"privateGetNextAppTagAsSender\").returns(42);\n\n            // Encrypt the message\n            let encrypted_message = BoundedVec::from_array(AES128::encrypt(plaintext, recipient));\n\n            // Mock shared secret for deterministic test\n            let shared_secret = derive_ecdh_shared_secret(\n                EmbeddedCurveScalar::from_field(eph_sk),\n                recipient.to_address_point().unwrap().inner,\n            );\n\n            let _ = OracleMock::mock(\"utilityGetSharedSecret\").returns(shared_secret);\n\n            // Decrypt the message\n            let decrypted = AES128::decrypt(encrypted_message, recipient).unwrap();\n\n            // The decryption function spits out a BoundedVec because it's designed to work with messages with unknown length\n            // at compile time. For this reason we need to convert the original input to a BoundedVec.\n            let plaintext_bvec = BoundedVec::<Field, MESSAGE_PLAINTEXT_LEN>::from_array(plaintext);\n\n            // Verify decryption matches original plaintext\n            assert_eq(\n                decrypted,\n                plaintext_bvec,\n                \"Decrypted bytes should match original plaintext\",\n            );\n\n            // The following is a workaround of \"struct is never constructed\" Noir compilation error (we only ever use\n            // static methods of the struct).\n            let _ = AES128 {};\n        });\n    }\n\n    #[test]\n    unconstrained fn encrypt_decrypt_random() {\n        // Same as `encrypt_decrypt_deterministic`, except we don't mock any of the oracles and rely on\n        // `TestEnvironment` instead.\n        let mut env = TestEnvironment::new();\n\n        let recipient = env.create_light_account();\n\n        env.private_context(|_| {\n            let plaintext = [1, 2, 3];\n            let ciphertext = AES128::encrypt(plaintext, recipient);\n\n            assert_eq(\n                AES128::decrypt(BoundedVec::from_array(ciphertext), recipient).unwrap(),\n                BoundedVec::from_array(plaintext),\n            );\n        });\n    }\n\n    #[test]\n    unconstrained fn encrypt_to_invalid_address() {\n        // x = 3 is a non-residue for this curve, resulting in an invalid address\n        let invalid_address = AztecAddress { inner: 3 };\n\n        // We just test that we produced some output and did not crash - the result is gibberish as it is encrypted\n        // using a public key for which we do not know the private key.\n        let _ = AES128::encrypt([1, 2, 3, 4], invalid_address);\n    }\n\n    #[test]\n    unconstrained fn random_address_point_produces_valid_points() {\n        // About half of random addresses are invalid, so testing just a couple gives us high confidence that\n        // `random_address_point` is indeed producing valid addresses.\n        for _ in 0..10 {\n            let random_address = AztecAddress { inner: random_address_point().inner.x };\n            assert(random_address.to_address_point().is_some());\n        }\n    }\n\n    #[test]\n    unconstrained fn decrypt_invalid_ephemeral_public_key() {\n        let mut env = TestEnvironment::new();\n\n        let recipient = env.create_light_account();\n\n        env.private_context(|_| {\n            let plaintext = [1, 2, 3, 4];\n            let ciphertext = AES128::encrypt(plaintext, recipient);\n\n            // The first field of the ciphertext is the x-coordinate of the ephemeral public key. We set it to a known\n            // non-residue (3), causing `decrypt` to fail to produce a decryption shared secret.\n            let mut bad_ciphertext = BoundedVec::from_array(ciphertext);\n            bad_ciphertext.set(0, 3);\n\n            assert(AES128::decrypt(bad_ciphertext, recipient).is_none());\n        });\n    }\n}\n","path":"/home/filip/nargo/github.com/AztecProtocol/aztec-packages/v3.0.1-rc.1/noir-projects/aztec-nr/aztec/src/messages/encryption/aes128.nr"},"149":{"source":"pub(crate) mod event_validation_request;\npub mod message_context;\npub(crate) mod note_validation_request;\npub(crate) mod log_retrieval_request;\npub(crate) mod log_retrieval_response;\npub(crate) mod pending_tagged_log;\n\nuse crate::{\n    capsules::CapsuleArray,\n    event::event_selector::EventSelector,\n    messages::{\n        discovery::{\n            partial_notes::DeliveredPendingPartialNote, private_events::MAX_EVENT_SERIALIZED_LEN,\n            private_notes::MAX_NOTE_PACKED_LEN,\n        },\n        processing::{\n            log_retrieval_request::LogRetrievalRequest,\n            log_retrieval_response::LogRetrievalResponse,\n            note_validation_request::NoteValidationRequest, pending_tagged_log::PendingTaggedLog,\n        },\n    },\n    oracle,\n};\nuse event_validation_request::EventValidationRequest;\nuse protocol_types::{address::AztecAddress, hash::sha256_to_field};\n\n// Base slot for the pending tagged log array to which the fetch_tagged_logs oracle inserts found private logs.\nglobal PENDING_TAGGED_LOG_ARRAY_BASE_SLOT: Field =\n    sha256_to_field(\"AZTEC_NR::PENDING_TAGGED_LOG_ARRAY_BASE_SLOT\".as_bytes());\n\nglobal NOTE_VALIDATION_REQUESTS_ARRAY_BASE_SLOT: Field = sha256_to_field(\n    \"AZTEC_NR::NOTE_VALIDATION_REQUESTS_ARRAY_BASE_SLOT\".as_bytes(),\n);\n\nglobal EVENT_VALIDATION_REQUESTS_ARRAY_BASE_SLOT: Field = sha256_to_field(\n    \"AZTEC_NR::EVENT_VALIDATION_REQUESTS_ARRAY_BASE_SLOT\".as_bytes(),\n);\n\nglobal LOG_RETRIEVAL_REQUESTS_ARRAY_BASE_SLOT: Field = sha256_to_field(\n    \"AZTEC_NR::LOG_RETRIEVAL_REQUESTS_ARRAY_BASE_SLOT\".as_bytes(),\n);\n\nglobal LOG_RETRIEVAL_RESPONSES_ARRAY_BASE_SLOT: Field = sha256_to_field(\n    \"AZTEC_NR::LOG_RETRIEVAL_RESPONSES_ARRAY_BASE_SLOT\".as_bytes(),\n);\n\n/// Searches for private logs emitted by `contract_address` that might contain messages for one of the local accounts,\n/// and stores them in a `CapsuleArray` which is then returned.\npub(crate) unconstrained fn get_private_logs(\n    contract_address: AztecAddress,\n) -> CapsuleArray<PendingTaggedLog> {\n    // We will eventually perform log discovery via tagging here, but for now we simply call the `fetchTaggedLogs`\n    // oracle. This makes PXE synchronize tags, download logs and store the pending tagged logs in a capsule array.\n    oracle::message_processing::fetch_tagged_logs(PENDING_TAGGED_LOG_ARRAY_BASE_SLOT);\n\n    CapsuleArray::at(contract_address, PENDING_TAGGED_LOG_ARRAY_BASE_SLOT)\n}\n\n/// Enqueues a note for validation by PXE, so that it becomes aware of a note's existence allowing for later retrieval\n/// via `get_notes` oracle. The note will be scoped to `contract_address`, meaning other contracts will not be able to\n/// access it unless authorized.\n///\n/// In order for the note validation and insertion to occur, `validate_enqueued_notes_and_events` must be later called.\n/// For optimal performance, accumulate as many note validation requests as possible and then validate them all at the\n/// end (which results in PXE minimizing the number of network round-trips).\n///\n/// The `packed_note` is what `getNotes` will later return. PXE indexes notes by `storage_slot`, so this value\n/// is typically used to filter notes that correspond to different state variables. `note_hash` and `nullifier` are\n/// the inner hashes, i.e. the raw hashes returned by `NoteHash::compute_note_hash` and\n/// `NoteHash::compute_nullifier`. PXE will verify that the siloed unique note hash was inserted into the tree\n/// at `tx_hash`, and will store the nullifier to later check for nullification.\n///\n/// `owner` is the address used in note hash and nullifier computation, often requiring knowledge of their\n/// nullifier secret key.\n///\n/// `recipient` is the account to which the note message was delivered (i.e. the address the message was encrypted to).\n/// This determines which PXE account can see the note - other accounts will not be able to access it (e.g. other\n/// accounts will not be able to see one another's token balance notes, even in the same PXE) unless authorized. In most\n/// cases `recipient` equals `owner`, but they can differ in scenarios like delegated discovery.\npub(crate) unconstrained fn enqueue_note_for_validation(\n    contract_address: AztecAddress,\n    owner: AztecAddress,\n    storage_slot: Field,\n    randomness: Field,\n    note_nonce: Field,\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n    note_hash: Field,\n    nullifier: Field,\n    tx_hash: Field,\n    recipient: AztecAddress,\n) {\n    // We store requests in a `CapsuleArray`, which PXE will later read from and deserialize into its version of the\n    // Noir `NoteValidationRequest`\n    CapsuleArray::at(contract_address, NOTE_VALIDATION_REQUESTS_ARRAY_BASE_SLOT).push(\n        NoteValidationRequest {\n            contract_address,\n            owner,\n            storage_slot,\n            randomness,\n            note_nonce,\n            packed_note,\n            note_hash,\n            nullifier,\n            tx_hash,\n            recipient,\n        },\n    )\n}\n\n/// Enqueues an event for validation by PXE, so that it can be efficiently validated and then inserted into the event\n/// store.\n///\n/// In order for the event validation and insertion to occur, `validate_enqueued_notes_and_events` must be later\n/// called. For optimal performance, accumulate as many event validation requests as possible and then validate them\n/// all at the end (which results in PXE minimizing the number of network round-trips).\npub(crate) unconstrained fn enqueue_event_for_validation(\n    contract_address: AztecAddress,\n    event_type_id: EventSelector,\n    serialized_event: BoundedVec<Field, MAX_EVENT_SERIALIZED_LEN>,\n    event_commitment: Field,\n    tx_hash: Field,\n    recipient: AztecAddress,\n) {\n    // We store requests in a `CapsuleArray`, which PXE will later read from and deserialize into its version of the\n    // Noir `EventValidationRequest`\n    CapsuleArray::at(contract_address, EVENT_VALIDATION_REQUESTS_ARRAY_BASE_SLOT).push(\n        EventValidationRequest {\n            contract_address,\n            event_type_id,\n            serialized_event,\n            event_commitment,\n            tx_hash,\n            recipient,\n        },\n    )\n}\n\n/// Validates all note and event validation requests enqueued via `enqueue_note_for_validation` and\n/// `enqueue_event_for_validation`, inserting them into the note database and event store respectively, making them\n/// queryable via `get_notes` oracle and our TS API (PXE::getPrivateEvents).\n///\n/// This automatically clears both validation request queues, so no further work needs to be done by the caller.\npub(crate) unconstrained fn validate_enqueued_notes_and_events(contract_address: AztecAddress) {\n    oracle::message_processing::validate_enqueued_notes_and_events(\n        contract_address,\n        NOTE_VALIDATION_REQUESTS_ARRAY_BASE_SLOT,\n        EVENT_VALIDATION_REQUESTS_ARRAY_BASE_SLOT,\n    );\n}\n\n/// Efficiently queries the node for logs that result in the completion of all `DeliveredPendingPartialNote`s stored in\n/// a `CapsuleArray` by performing all node communication concurrently. Returns a second `CapsuleArray` with Options for\n/// the responses that correspond to the pending partial notes at the same index.\n///\n/// For example, given an array with pending partial notes `[ p1, p2, p3 ]`, where `p1` and `p3` have corresponding\n/// completion logs but `p2` does not, the returned `CapsuleArray` will have contents\n/// `[some(p1_log), none(), some(p3_log)]`.\npub(crate) unconstrained fn get_pending_partial_notes_completion_logs(\n    contract_address: AztecAddress,\n    pending_partial_notes: CapsuleArray<DeliveredPendingPartialNote>,\n) -> CapsuleArray<Option<LogRetrievalResponse>> {\n    let log_retrieval_requests =\n        CapsuleArray::at(contract_address, LOG_RETRIEVAL_REQUESTS_ARRAY_BASE_SLOT);\n\n    // We create a LogRetrievalRequest for each PendingPartialNote in the CapsuleArray. Because we need the indices in\n    // the request array to match the indices in the partial note array, we can't use CapsuleArray::for_each, as that\n    // function has arbitrary iteration order. Instead, we manually iterate the array from the beginning and push into\n    // the requests array, which we expect to be empty.\n    let mut i = 0;\n    let pending_partial_notes_count = pending_partial_notes.len();\n    while i < pending_partial_notes_count {\n        let pending_partial_note = pending_partial_notes.get(i);\n        log_retrieval_requests.push(\n            LogRetrievalRequest {\n                contract_address,\n                unsiloed_tag: pending_partial_note.note_completion_log_tag,\n            },\n        );\n        i += 1;\n    }\n\n    oracle::message_processing::bulk_retrieve_logs(\n        contract_address,\n        LOG_RETRIEVAL_REQUESTS_ARRAY_BASE_SLOT,\n        LOG_RETRIEVAL_RESPONSES_ARRAY_BASE_SLOT,\n    );\n\n    CapsuleArray::at(contract_address, LOG_RETRIEVAL_RESPONSES_ARRAY_BASE_SLOT)\n}\n","path":"/home/filip/nargo/github.com/AztecProtocol/aztec-packages/v3.0.1-rc.1/noir-projects/aztec-nr/aztec/src/messages/processing/mod.nr"},"169":{"source":"use protocol_types::{address::AztecAddress, traits::{Deserialize, Serialize}};\n\n/// Stores arbitrary information in a per-contract non-volatile database, which can later be retrieved with `load`. If\n/// data was already stored at this slot, it is overwritten.\npub unconstrained fn store<T>(contract_address: AztecAddress, slot: Field, value: T)\nwhere\n    T: Serialize,\n{\n    let serialized = value.serialize();\n    store_oracle(contract_address, slot, serialized);\n}\n\n/// Returns data previously stored via `storeCapsule` in the per-contract non-volatile database. Returns Option::none() if\n/// nothing was stored at the given slot.\npub unconstrained fn load<T>(contract_address: AztecAddress, slot: Field) -> Option<T>\nwhere\n    T: Deserialize,\n{\n    let serialized_option = load_oracle(contract_address, slot, <T as Deserialize>::N);\n    serialized_option.map(|arr| Deserialize::deserialize(arr))\n}\n\n/// Deletes data in the per-contract non-volatile database. Does nothing if no data was present.\npub unconstrained fn delete(contract_address: AztecAddress, slot: Field) {\n    delete_oracle(contract_address, slot);\n}\n\n/// Copies a number of contiguous entries in the per-contract non-volatile database. This allows for efficient data\n/// structures by avoiding repeated calls to `loadCapsule` and `storeCapsule`.\n/// Supports overlapping source and destination regions (which will result in the overlapped source values being\n/// overwritten). All copied slots must exist in the database (i.e. have been stored and not deleted)\npub unconstrained fn copy(\n    contract_address: AztecAddress,\n    src_slot: Field,\n    dst_slot: Field,\n    num_entries: u32,\n) {\n    copy_oracle(contract_address, src_slot, dst_slot, num_entries);\n}\n\n#[oracle(utilityStoreCapsule)]\nunconstrained fn store_oracle<let N: u32>(\n    contract_address: AztecAddress,\n    slot: Field,\n    values: [Field; N],\n) {}\n\n/// We need to pass in `array_len` (the value of N) as a parameter to tell the oracle how many fields the response must\n/// have.\n///\n/// Note that the oracle returns an Option<[Field; N]> because we cannot return an Option<T> directly. That would\n/// require for the oracle resolver to know the shape of T (e.g. if T were a struct of 3 u32 values then the expected\n/// response shape would be 3 single items, whereas it were a struct containing `u32, [Field;10], u32` then the expected\n/// shape would be single, array, single.). Instead, we return the serialization and deserialize in Noir.\n#[oracle(utilityLoadCapsule)]\nunconstrained fn load_oracle<let N: u32>(\n    contract_address: AztecAddress,\n    slot: Field,\n    array_len: u32,\n) -> Option<[Field; N]> {}\n\n#[oracle(utilityDeleteCapsule)]\nunconstrained fn delete_oracle(contract_address: AztecAddress, slot: Field) {}\n\n#[oracle(utilityCopyCapsule)]\nunconstrained fn copy_oracle(\n    contract_address: AztecAddress,\n    src_slot: Field,\n    dst_slot: Field,\n    num_entries: u32,\n) {}\n\nmod test {\n    // These tests are sort of redundant since we already test the oracle implementation directly in TypeScript, but\n    // they are cheap regardless and help ensure both that the TXE implementation works accordingly and that the Noir\n    // oracles are hooked up correctly.\n\n    use crate::{\n        oracle::capsules::{copy, delete, load, store},\n        test::{helpers::test_environment::TestEnvironment, mocks::mock_struct::MockStruct},\n    };\n    use protocol_types::{address::AztecAddress, traits::{FromField, ToField}};\n\n    global SLOT: Field = 1;\n\n    #[test]\n    unconstrained fn stores_and_loads() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let value = MockStruct::new(5, 6);\n            store(contract_address, SLOT, value);\n\n            assert_eq(load(contract_address, SLOT).unwrap(), value);\n        });\n    }\n\n    #[test]\n    unconstrained fn store_overwrites() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let value = MockStruct::new(5, 6);\n            store(contract_address, SLOT, value);\n\n            let new_value = MockStruct::new(7, 8);\n            store(contract_address, SLOT, new_value);\n\n            assert_eq(load(contract_address, SLOT).unwrap(), new_value);\n        });\n    }\n\n    #[test]\n    unconstrained fn loads_empty_slot() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let loaded_value: Option<MockStruct> = load(contract_address, SLOT);\n            assert_eq(loaded_value, Option::none());\n        });\n    }\n\n    #[test]\n    unconstrained fn deletes_stored_value() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let value = MockStruct::new(5, 6);\n            store(contract_address, SLOT, value);\n            delete(contract_address, SLOT);\n\n            let loaded_value: Option<MockStruct> = load(contract_address, SLOT);\n            assert_eq(loaded_value, Option::none());\n        });\n    }\n\n    #[test]\n    unconstrained fn deletes_empty_slot() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            delete(contract_address, SLOT);\n            let loaded_value: Option<MockStruct> = load(contract_address, SLOT);\n            assert_eq(loaded_value, Option::none());\n        });\n    }\n\n    #[test]\n    unconstrained fn copies_non_overlapping_values() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let src = 5;\n\n            let values = [MockStruct::new(5, 6), MockStruct::new(7, 8), MockStruct::new(9, 10)];\n            store(contract_address, src, values[0]);\n            store(contract_address, src + 1, values[1]);\n            store(contract_address, src + 2, values[2]);\n\n            let dst = 10;\n            copy(contract_address, src, dst, 3);\n\n            assert_eq(load(contract_address, dst).unwrap(), values[0]);\n            assert_eq(load(contract_address, dst + 1).unwrap(), values[1]);\n            assert_eq(load(contract_address, dst + 2).unwrap(), values[2]);\n        });\n    }\n\n    #[test]\n    unconstrained fn copies_overlapping_values_with_src_ahead() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let src = 1;\n\n            let values = [MockStruct::new(5, 6), MockStruct::new(7, 8), MockStruct::new(9, 10)];\n            store(contract_address, src, values[0]);\n            store(contract_address, src + 1, values[1]);\n            store(contract_address, src + 2, values[2]);\n\n            let dst = 2;\n            copy(contract_address, src, dst, 3);\n\n            assert_eq(load(contract_address, dst).unwrap(), values[0]);\n            assert_eq(load(contract_address, dst + 1).unwrap(), values[1]);\n            assert_eq(load(contract_address, dst + 2).unwrap(), values[2]);\n\n            // src[1] and src[2] should have been overwritten since they are also dst[0] and dst[1]\n            assert_eq(load(contract_address, src).unwrap(), values[0]); // src[0] (unchanged)\n            assert_eq(load(contract_address, src + 1).unwrap(), values[0]); // dst[0]\n            assert_eq(load(contract_address, src + 2).unwrap(), values[1]); // dst[1]\n        });\n    }\n\n    #[test]\n    unconstrained fn copies_overlapping_values_with_dst_ahead() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let src = 2;\n\n            let values = [MockStruct::new(5, 6), MockStruct::new(7, 8), MockStruct::new(9, 10)];\n            store(contract_address, src, values[0]);\n            store(contract_address, src + 1, values[1]);\n            store(contract_address, src + 2, values[2]);\n\n            let dst = 1;\n            copy(contract_address, src, dst, 3);\n\n            assert_eq(load(contract_address, dst).unwrap(), values[0]);\n            assert_eq(load(contract_address, dst + 1).unwrap(), values[1]);\n            assert_eq(load(contract_address, dst + 2).unwrap(), values[2]);\n\n            // src[0] and src[1] should have been overwritten since they are also dst[1] and dst[2]\n            assert_eq(load(contract_address, src).unwrap(), values[1]); // dst[1]\n            assert_eq(load(contract_address, src + 1).unwrap(), values[2]); // dst[2]\n            assert_eq(load(contract_address, src + 2).unwrap(), values[2]); // src[2] (unchanged)\n        });\n    }\n\n    #[test(should_fail_with = \"copy empty slot\")]\n    unconstrained fn cannot_copy_empty_values() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            copy(contract_address, SLOT, SLOT, 1);\n        });\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_store_other_contract() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n            let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n            let value = MockStruct::new(5, 6);\n            store(other_contract_address, SLOT, value);\n        });\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_load_other_contract() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n            let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n            let _: Option<MockStruct> = load(other_contract_address, SLOT);\n        });\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_delete_other_contract() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n            let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n            delete(other_contract_address, SLOT);\n        });\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_copy_other_contract() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n            let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n            copy(other_contract_address, SLOT, SLOT, 0);\n        });\n    }\n}\n","path":"/home/filip/nargo/github.com/AztecProtocol/aztec-packages/v3.0.1-rc.1/noir-projects/aztec-nr/aztec/src/oracle/capsules.nr"},"171":{"source":"use crate::context::utility_context::UtilityContext;\n\n#[oracle(utilityGetUtilityContext)]\nunconstrained fn get_utility_context_oracle() -> UtilityContext {}\n\n/// Returns a utility context built from the global variables of anchor block and the contract address of the function\n/// being executed.\npub unconstrained fn get_utility_context() -> UtilityContext {\n    get_utility_context_oracle()\n}\n","path":"/home/filip/nargo/github.com/AztecProtocol/aztec-packages/v3.0.1-rc.1/noir-projects/aztec-nr/aztec/src/oracle/execution.nr"},"173":{"source":"use protocol_types::{\n    address::AztecAddress, contract_class_id::ContractClassId, contract_instance::ContractInstance,\n    traits::FromField,\n};\n\n// NOTE: this is for use in private only\n#[oracle(utilityGetContractInstance)]\nunconstrained fn get_contract_instance_oracle(_address: AztecAddress) -> ContractInstance {}\n\n// NOTE: this is for use in private only\nunconstrained fn get_contract_instance_internal(address: AztecAddress) -> ContractInstance {\n    get_contract_instance_oracle(address)\n}\n\n// NOTE: this is for use in private only\npub fn get_contract_instance(address: AztecAddress) -> ContractInstance {\n    // Safety: The to_address function combines all values in the instance object to produce an address,\n    // so by checking that we get the expected address we validate the entire struct.\n    let instance = unsafe { get_contract_instance_internal(address) };\n    assert_eq(instance.to_address(), address);\n\n    instance\n}\n\nstruct GetContractInstanceResult {\n    exists: bool,\n    member: Field,\n}\n\n// These oracles each return a ContractInstance member\n// plus a boolean indicating whether the instance was found.\n#[oracle(avmOpcodeGetContractInstanceDeployer)]\nunconstrained fn get_contract_instance_deployer_oracle_avm(\n    _address: AztecAddress,\n) -> [GetContractInstanceResult; 1] {}\n#[oracle(avmOpcodeGetContractInstanceClassId)]\nunconstrained fn get_contract_instance_class_id_oracle_avm(\n    _address: AztecAddress,\n) -> [GetContractInstanceResult; 1] {}\n#[oracle(avmOpcodeGetContractInstanceInitializationHash)]\nunconstrained fn get_contract_instance_initialization_hash_oracle_avm(\n    _address: AztecAddress,\n) -> [GetContractInstanceResult; 1] {}\n\nunconstrained fn get_contract_instance_deployer_internal_avm(\n    address: AztecAddress,\n) -> [GetContractInstanceResult; 1] {\n    get_contract_instance_deployer_oracle_avm(address)\n}\nunconstrained fn get_contract_instance_class_id_internal_avm(\n    address: AztecAddress,\n) -> [GetContractInstanceResult; 1] {\n    get_contract_instance_class_id_oracle_avm(address)\n}\nunconstrained fn get_contract_instance_initialization_hash_internal_avm(\n    address: AztecAddress,\n) -> [GetContractInstanceResult; 1] {\n    get_contract_instance_initialization_hash_oracle_avm(address)\n}\n\npub fn get_contract_instance_deployer_avm(address: AztecAddress) -> Option<AztecAddress> {\n    // Safety: AVM opcodes are constrained by the AVM itself\n    let GetContractInstanceResult { exists, member } =\n        unsafe { get_contract_instance_deployer_internal_avm(address)[0] };\n    if exists {\n        Option::some(AztecAddress::from_field(member))\n    } else {\n        Option::none()\n    }\n}\npub fn get_contract_instance_class_id_avm(address: AztecAddress) -> Option<ContractClassId> {\n    // Safety: AVM opcodes are constrained by the AVM itself\n    let GetContractInstanceResult { exists, member } =\n        unsafe { get_contract_instance_class_id_internal_avm(address)[0] };\n    if exists {\n        Option::some(ContractClassId::from_field(member))\n    } else {\n        Option::none()\n    }\n}\npub fn get_contract_instance_initialization_hash_avm(address: AztecAddress) -> Option<Field> {\n    // Safety: AVM opcodes are constrained by the AVM itself\n    let GetContractInstanceResult { exists, member } =\n        unsafe { get_contract_instance_initialization_hash_internal_avm(address)[0] };\n    if exists {\n        Option::some(member)\n    } else {\n        Option::none()\n    }\n}\n","path":"/home/filip/nargo/github.com/AztecProtocol/aztec-packages/v3.0.1-rc.1/noir-projects/aztec-nr/aztec/src/oracle/get_contract_instance.nr"},"181":{"source":"use protocol_types::address::AztecAddress;\n\n/// Finds new private logs that may have been sent to all registered accounts in PXE in the current contract and makes\n/// them available for later processing in Noir by storing them in a capsule array.\npub unconstrained fn fetch_tagged_logs(pending_tagged_log_array_base_slot: Field) {\n    fetch_tagged_logs_oracle(pending_tagged_log_array_base_slot);\n}\n\n#[oracle(utilityFetchTaggedLogs)]\nunconstrained fn fetch_tagged_logs_oracle(pending_tagged_log_array_base_slot: Field) {}\n\n// This must be a single oracle and not one for notes and one for events because the entire point is to validate\n// all notes and events in one go, minimizing node round-trips.\npub(crate) unconstrained fn validate_enqueued_notes_and_events(\n    contract_address: AztecAddress,\n    note_validation_requests_array_base_slot: Field,\n    event_validation_requests_array_base_slot: Field,\n) {\n    validate_enqueued_notes_and_events_oracle(\n        contract_address,\n        note_validation_requests_array_base_slot,\n        event_validation_requests_array_base_slot,\n    );\n}\n\n#[oracle(utilityValidateEnqueuedNotesAndEvents)]\nunconstrained fn validate_enqueued_notes_and_events_oracle(\n    contract_address: AztecAddress,\n    note_validation_requests_array_base_slot: Field,\n    event_validation_requests_array_base_slot: Field,\n) {}\n\npub(crate) unconstrained fn bulk_retrieve_logs(\n    contract_address: AztecAddress,\n    log_retrieval_requests_array_base_slot: Field,\n    log_retrieval_responses_array_base_slot: Field,\n) {\n    bulk_retrieve_logs_oracle(\n        contract_address,\n        log_retrieval_requests_array_base_slot,\n        log_retrieval_responses_array_base_slot,\n    );\n}\n\n#[oracle(utilityBulkRetrieveLogs)]\nunconstrained fn bulk_retrieve_logs_oracle(\n    contract_address: AztecAddress,\n    log_retrieval_requests_array_base_slot: Field,\n    log_retrieval_responses_array_base_slot: Field,\n) {}\n","path":"/home/filip/nargo/github.com/AztecProtocol/aztec-packages/v3.0.1-rc.1/noir-projects/aztec-nr/aztec/src/oracle/message_processing.nr"},"186":{"source":"use protocol_types::{address::aztec_address::AztecAddress, point::Point};\n\n// TODO(#12656): return an app-siloed secret + document this\n#[oracle(utilityGetSharedSecret)]\nunconstrained fn get_shared_secret_oracle(address: AztecAddress, ephPk: Point) -> Point {}\n\n/// Returns an app-siloed shared secret between `address` and someone who knows the secret key behind an\n/// ephemeral public key `ephPk`. The app-siloing means that contracts cannot retrieve secrets that belong to\n/// other contracts, and therefore cannot e.g. decrypt their messages. This is an important security consideration\n/// given that both the `address` and `ephPk` are public information.\n///\n/// The shared secret `S` is computed as:\n/// `let S =  (ivsk + h) * ephPk`\n/// where `ivsk + h` is the 'preaddress' i.e. the preimage of the address, also called the address secret.\n/// TODO(#12656): app-silo this secret\npub unconstrained fn get_shared_secret(address: AztecAddress, ephPk: Point) -> Point {\n    get_shared_secret_oracle(address, ephPk)\n}\n","path":"/home/filip/nargo/github.com/AztecProtocol/aztec-packages/v3.0.1-rc.1/noir-projects/aztec-nr/aztec/src/oracle/shared_secret.nr"},"187":{"source":"use dep::protocol_types::{address::AztecAddress, traits::{Packable, ToField}};\n\n#[oracle(utilityStorageRead)]\nunconstrained fn storage_read_oracle<let N: u32>(\n    address: Field,\n    storage_slot: Field,\n    block_number: u32,\n    length: u32,\n) -> [Field; N] {}\n\npub unconstrained fn raw_storage_read<let N: u32>(\n    address: AztecAddress,\n    storage_slot: Field,\n    block_number: u32,\n) -> [Field; N] {\n    storage_read_oracle(address.to_field(), storage_slot, block_number, N)\n}\n\npub unconstrained fn storage_read<T>(\n    address: AztecAddress,\n    storage_slot: Field,\n    block_number: u32,\n) -> T\nwhere\n    T: Packable,\n{\n    T::unpack(raw_storage_read(address, storage_slot, block_number))\n}\n\nmod tests {\n    use crate::oracle::storage::{raw_storage_read, storage_read};\n    use dep::protocol_types::{address::AztecAddress, traits::{FromField, Packable}};\n\n    use crate::test::mocks::mock_struct::MockStruct;\n    use std::test::OracleMock;\n\n    global address: AztecAddress = AztecAddress::from_field(29);\n    global slot: Field = 7;\n    global block_number: u32 = 17;\n\n    #[test]\n    unconstrained fn test_raw_storage_read() {\n        let written = MockStruct { a: 13, b: 42 };\n\n        let _ = OracleMock::mock(\"utilityStorageRead\").returns(written.pack());\n\n        let read: [Field; 2] = raw_storage_read(address, slot, block_number);\n        assert_eq(read[0], 13);\n        assert_eq(read[1], 42);\n    }\n\n    #[test]\n    unconstrained fn test_storage_read() {\n        let written = MockStruct { a: 13, b: 42 };\n\n        let _ = OracleMock::mock(\"utilityStorageRead\").returns(written.pack());\n\n        let read: MockStruct = storage_read(address, slot, block_number);\n        assert_eq(read.a, 13);\n        assert_eq(read.b, 42);\n    }\n}\n","path":"/home/filip/nargo/github.com/AztecProtocol/aztec-packages/v3.0.1-rc.1/noir-projects/aztec-nr/aztec/src/oracle/storage.nr"},"188":{"source":"/// The ORACLE_VERSION constant is used to check that the oracle interface is in sync between PXE and Aztec.nr. We need\n/// to version the oracle interface to ensure that developers get a reasonable error message if they use incompatible\n/// versions of Aztec.nr and PXE. The TypeScript counterpart is in `oracle_version.ts`.\n///\n/// @dev Whenever a contract function or Noir test is run, the `utilityAssertCompatibleOracleVersion` oracle is called and\n/// if the oracle version is incompatible an error is thrown.\npub global ORACLE_VERSION: Field = 5;\n\n/// Asserts that the version of the oracle is compatible with the version expected by the contract.\npub fn assert_compatible_oracle_version() {\n    // Safety: This oracle call returns nothing: we only call it to check Aztec.nr and Oracle interface versions are\n    // compatible. It is therefore always safe to call.\n    unsafe {\n        assert_compatible_oracle_version_wrapper();\n    }\n}\n\nunconstrained fn assert_compatible_oracle_version_wrapper() {\n    assert_compatible_oracle_version_oracle(ORACLE_VERSION);\n}\n\n#[oracle(utilityAssertCompatibleOracleVersion)]\nunconstrained fn assert_compatible_oracle_version_oracle(version: Field) {}\n\nmod test {\n    use super::{assert_compatible_oracle_version_oracle, ORACLE_VERSION};\n\n    #[test]\n    unconstrained fn compatible_oracle_version() {\n        assert_compatible_oracle_version_oracle(ORACLE_VERSION);\n    }\n\n    #[test(should_fail_with = \"Incompatible oracle version. TXE is using version\")]\n    unconstrained fn incompatible_oracle_version() {\n        let arbitrary_incorrect_version = 318183437;\n        assert_compatible_oracle_version_oracle(arbitrary_incorrect_version);\n    }\n}\n","path":"/home/filip/nargo/github.com/AztecProtocol/aztec-packages/v3.0.1-rc.1/noir-projects/aztec-nr/aztec/src/oracle/version.nr"},"192":{"source":"use crate::state_vars::state_variable::StateVariable;\nuse dep::protocol_types::{storage::map::derive_storage_slot_in_map, traits::ToField};\n\n/// Map\n///\n/// A key-value storage container that maps keys to state variables, similar\n/// to Solidity mappings.\n///\n/// `Map` enables you to associate keys (like addresses or other identifiers)\n/// with state variables in your Aztec smart contract. This is conceptually\n/// similar to Solidity's `mapping(K => V)` syntax, where you can store and\n/// retrieve values by their associated keys.\n///\n/// You can declare a state variable contained within a Map in your contract's\n/// #[storage] struct.\n///\n/// For example, you might use\n/// `Map<AztecAddress, PublicMutable<FieldNote, Context>, Context>` to track\n/// token balances for different users, similar to how you'd use\n/// `mapping(address => uint256)` in Solidity.\n///\n/// > Aside: the verbose `Context` in the declaration is a consequence of\n/// > leveraging Noir's regular syntax for generics to ensure that certain\n/// > state variable methods can only be called in some contexts (private,\n/// > public, utility).\n///\n/// The methods of Map are:\n/// - `at` (access state variable for a given key)\n/// (see the method's own doc comments for more info).\n///\n/// ## Generic Parameters\n/// - `K`: The key type (must implement `ToField` trait for hashing)\n/// - `V`: The value type:\n///   - any Aztec state variable (variable that implements the StateVariable trait):\n///     - `PublicMutable`\n///     - `PublicImmutable`\n///     - `DelayedPublicMutable`\n///     - `Map`\n/// - `Context`: The execution context (handles private/public function\n///   contexts)\n///\n/// ## Usage\n/// Maps are typically declared in your contract's #[storage] struct and\n/// accessed\n/// using the `at(key)` method to get the state variable for a specific key.\n/// The resulting state variable can then be read from or written to using its\n/// own methods.\n///\n/// Note that maps cannot be used with owned state variables (variables that\n/// implement the OwnedStateVariable trait) - those need to be wrapped in an\n/// `Owned` state variable instead.\n///\n/// ## Advanced\n/// Internally, `Map` uses a single base storage slot to represent the\n/// mapping\n/// itself, similar to Solidity's approach. Individual key-value pairs are\n/// stored at derived storage slots computed by hashing the base storage\n/// slot\n/// with the key using Poseidon2. This ensures:\n/// - No storage slot collisions between different keys\n/// - Uniform distribution of storage slots across the storage space\n/// - Compatibility with Aztec's storage tree structure\n/// - Gas-efficient storage access patterns similar to Solidity mappings\n///\n/// The storage slot derivation uses `derive_storage_slot_in_map(base_slot,\n/// key)` which computes `poseidon2_hash([base_slot, key.to_field()])`,\n/// ensuring cryptographically secure slot separation.\n///\n/// docs:start:map\npub struct Map<K, V, Context> {\n    pub context: Context,\n    storage_slot: Field,\n}\n\n// Map reserves a single storage slot regardless of what it stores because\n// nothing is stored at said slot: it is only used to derive the storage slots\n// of nested state variables, which is expected to never result in collisions\n// or slots being close to one another due to these being hashes. This mirrors\n// the strategy adopted by Solidity mappings.\nimpl<K, V, Context> StateVariable<1, Context> for Map<K, V, Context> {\n    fn new(context: Context, storage_slot: Field) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        Map { context, storage_slot }\n    }\n\n    fn get_storage_slot(self) -> Field {\n        self.storage_slot\n    }\n}\n\nimpl<K, V, Context> Map<K, V, Context> {\n    /// Returns the state variable associated with the given key.\n    ///\n    /// This is equivalent to accessing `mapping[key]` in Solidity. It returns\n    /// the state variable instance for the specified key, which can then be\n    /// used to read or write the value at that key.\n    ///\n    /// Unlike Solidity mappings which return the value directly, this returns\n    /// the state variable wrapper (like PublicMutable, nested Map etc.)\n    /// that you then call methods on to interact with the actual value.\n    ///\n    /// # Arguments\n    ///\n    /// * `key` - The key to look up in the map. Must implement the ToField\n    ///           trait (which most basic Noir & Aztec types do).\n    ///\n    /// # Returns\n    ///\n    /// * `V` - The state variable instance for this key. You can then call\n    ///         methods like `.read()`, `.write()`, `.get_note()`, etc. on this\n    ///         depending on the specific state variable type.\n    ///\n    /// # Example\n    ///\n    /// ```noir\n    /// // Get a user's balance (assuming PrivateMutable<FieldNote>)\n    /// let user_balance = self.storage.balances.at(user_address);\n    /// let current_note = user_balance.get_note();\n    ///\n    /// // Update the balance\n    /// user_balance.replace(new_note);\n    /// ```\n    ///\n    pub fn at<let N: u32>(self, key: K) -> V\n    where\n        K: ToField,\n        V: StateVariable<N, Context>,\n    {\n        V::new(\n            self.context,\n            derive_storage_slot_in_map(self.storage_slot, key),\n        )\n    }\n}\n","path":"/home/filip/nargo/github.com/AztecProtocol/aztec-packages/v3.0.1-rc.1/noir-projects/aztec-nr/aztec/src/state_vars/map.nr"},"204":{"source":"use crate::context::{PublicContext, UtilityContext};\nuse crate::state_vars::state_variable::StateVariable;\nuse dep::protocol_types::traits::Packable;\n\n/// # PublicMutable\n///\n/// PublicMutable is a public state variable type for values that can be read\n/// and written within #[external(\"public\")] functions of your smart contract.\n///\n/// You can declare a state variable of type PublicMutable within your contract's\n/// #[storage] struct:\n///\n/// E.g.:\n/// `your_variable: PublicMutable<T, Context>`\n/// or:\n/// `your_mapping: Map<Field, PublicMutable<T, Context>>`\n///\n/// The methods of PublicMutable are:\n/// - `read`\n/// - `write`\n/// (see the methods' own doc comments for more info).\n///\n/// ## Example.\n///\n/// A voting contract's proposal count can be represented as a PublicMutable<u64>.\n/// The count can be read by anyone to see how many proposals exist, and incremented\n/// when new proposals are submitted.\n///\n/// # Generic Parameters:\n///\n/// * `T` - The type of value stored (must implement Packable).\n/// * `Context` - The execution context (PublicContext or UtilityContext).\n///\n/// # Advanced\n///\n/// Unlike private state variables which use notes, PublicMutable stores values\n/// directly in Aztec's public data tree. This enables direct read and write\n/// access to the current state during public function execution.\n///\n/// docs:start:public_mutable_struct\npub struct PublicMutable<T, Context> {\n    context: Context,\n    storage_slot: Field,\n}\n\nimpl<T, Context, let M: u32> StateVariable<M, Context> for PublicMutable<T, Context>\nwhere\n    T: Packable<N = M>,\n{\n    fn new(context: Context, storage_slot: Field) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        PublicMutable { context, storage_slot }\n    }\n\n    fn get_storage_slot(self) -> Field {\n        self.storage_slot\n    }\n}\n\nimpl<T> PublicMutable<T, PublicContext> {\n    /// Reads the current value stored in this PublicMutable state variable.\n    ///\n    /// # Returns\n    ///\n    /// * `T` - The current value stored in this PublicMutable.\n    ///\n    /// docs:start:public_mutable_struct_read\n    pub fn read(self) -> T\n    where\n        T: Packable,\n    {\n        self.context.storage_read(self.storage_slot)\n    }\n\n    /// Writes a new value to this PublicMutable state variable.\n    ///\n    /// # Arguments\n    ///\n    /// * `value` - The new value to store in this PublicMutable.\n    ///\n    /// # Advanced\n    ///\n    /// This function updates the value stored in Aztec's public data tree.\n    /// The new value becomes immediately available to subsequent reads within\n    /// the same transaction.\n    ///\n    /// docs:start:public_mutable_struct_write\n    pub fn write(self, value: T)\n    where\n        T: Packable,\n    {\n        self.context.storage_write(self.storage_slot, value);\n    }\n}\n\nimpl<T> PublicMutable<T, UtilityContext> {\n    /// Reads the current value stored in this PublicMutable state variable.\n    ///\n    /// Notice that this function is executable only within a UtilityContext, which\n    /// is an unconstrained environment on the user's local device.\n    ///\n    /// # Returns\n    ///\n    /// * `T` - The current value stored in this PublicMutable.\n    ///\n    pub unconstrained fn read(self) -> T\n    where\n        T: Packable,\n    {\n        self.context.storage_read(self.storage_slot)\n    }\n}\n","path":"/home/filip/nargo/github.com/AztecProtocol/aztec-packages/v3.0.1-rc.1/noir-projects/aztec-nr/aztec/src/state_vars/public_mutable.nr"},"229":{"source":"/// Appends the elements of the second `BoundedVec` to the end of the first one. The resulting `BoundedVec` can have any arbitrary maximum length, but it must be\n/// large enough to fit all of the elements of both the first and second vectors.\npub fn append<T, let ALen: u32, let BLen: u32, let DstLen: u32>(\n    a: BoundedVec<T, ALen>,\n    b: BoundedVec<T, BLen>,\n) -> BoundedVec<T, DstLen> {\n    let mut dst = BoundedVec::new();\n\n    dst.extend_from_bounded_vec(a);\n    dst.extend_from_bounded_vec(b);\n\n    dst\n}\n\nmod test {\n    use super::append;\n\n    #[test]\n    unconstrained fn append_empty_vecs() {\n        let a: BoundedVec<_, 3> = BoundedVec::new();\n        let b: BoundedVec<_, 14> = BoundedVec::new();\n\n        let result: BoundedVec<Field, 5> = append(a, b);\n\n        assert_eq(result.len(), 0);\n        assert_eq(result.storage(), std::mem::zeroed());\n    }\n\n    #[test]\n    unconstrained fn append_non_empty_vecs() {\n        let a: BoundedVec<_, 3> = BoundedVec::from_array([1, 2, 3]);\n        let b: BoundedVec<_, 14> = BoundedVec::from_array([4, 5, 6]);\n\n        let result: BoundedVec<Field, 8> = append(a, b);\n\n        assert_eq(result.len(), 6);\n        assert_eq(result.storage(), [1, 2, 3, 4, 5, 6, std::mem::zeroed(), std::mem::zeroed()]);\n    }\n\n    #[test(should_fail_with = \"out of bounds\")]\n    unconstrained fn append_non_empty_vecs_insufficient_max_len() {\n        let a: BoundedVec<_, 3> = BoundedVec::from_array([1, 2, 3]);\n        let b: BoundedVec<_, 14> = BoundedVec::from_array([4, 5, 6]);\n\n        let _: BoundedVec<Field, 5> = append(a, b);\n    }\n}\n","path":"/home/filip/nargo/github.com/AztecProtocol/aztec-packages/v3.0.1-rc.1/noir-projects/aztec-nr/aztec/src/utils/array/append.nr"},"232":{"source":"/// Returns `DstLen` elements from a source array, starting at `offset`. `DstLen` must not be larger than the number\n/// of elements past `offset`.\n///\n/// Examples:\n/// ```\n/// let foo: [Field; 2] = subarray([1, 2, 3, 4, 5], 2);\n/// assert_eq(foo, [3, 4]);\n///\n/// let bar: [Field; 5] = subarray([1, 2, 3, 4, 5], 2); // fails - we can't return 5 elements since only 3 remain\n/// ```\npub fn subarray<T, let SrcLen: u32, let DstLen: u32>(src: [T; SrcLen], offset: u32) -> [T; DstLen] {\n    assert(offset + DstLen <= SrcLen, \"DstLen too large for offset\");\n\n    let mut dst: [T; DstLen] = std::mem::zeroed();\n    for i in 0..DstLen {\n        dst[i] = src[i + offset];\n    }\n\n    dst\n}\n\nmod test {\n    use super::subarray;\n\n    #[test]\n    unconstrained fn subarray_into_empty() {\n        // In all of these cases we're setting DstLen to be 0, so we always get back an empty array.\n        assert_eq(subarray::<Field, _, _>([], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 2), []);\n    }\n\n    #[test]\n    unconstrained fn subarray_complete() {\n        assert_eq(subarray::<Field, _, _>([], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 0), [1, 2, 3, 4, 5]);\n    }\n\n    #[test]\n    unconstrained fn subarray_different_end_sizes() {\n        // We implicitly select how many values to read in the size of the return array\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3, 4, 5]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3, 4]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2]);\n    }\n\n    #[test(should_fail_with = \"DstLen too large for offset\")]\n    unconstrained fn subarray_offset_too_large() {\n        // With an offset of 1 we can only request up to 4 elements\n        let _: [_; 5] = subarray([1, 2, 3, 4, 5], 1);\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subarray_bad_return_value() {\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [3, 3, 4, 5]);\n    }\n}\n","path":"/home/filip/nargo/github.com/AztecProtocol/aztec-packages/v3.0.1-rc.1/noir-projects/aztec-nr/aztec/src/utils/array/subarray.nr"},"233":{"source":"use crate::utils::array;\n\n/// Returns `DstMaxLen` elements from a source BoundedVec, starting at `offset`. `offset` must not be larger than the\n/// original length, and `DstLen` must not be larger than the total number of elements past `offset` (including the\n/// zeroed elements past `len()`).\n///\n/// Only elements at the beginning of the vector can be removed: it is not possible to also remove elements at the end\n/// of the vector by passing a value for `DstLen` that is smaller than `len() - offset`.\n///\n/// Examples:\n/// ```\n/// let foo = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n/// assert_eq(subbvec(foo, 2), BoundedVec::<_, 8>::from_array([3, 4, 5]));\n///\n/// let bar: BoundedVec<_, 1> = subbvec(foo, 2); // fails - we can't return just 1 element since 3 remain\n/// let baz: BoundedVec<_, 10> = subbvec(foo, 3); // fails - we can't return 10 elements since only 7 remain\n/// ```\npub fn subbvec<T, let SrcMaxLen: u32, let DstMaxLen: u32>(\n    bvec: BoundedVec<T, SrcMaxLen>,\n    offset: u32,\n) -> BoundedVec<T, DstMaxLen> {\n    // from_parts_unchecked does not verify that the elements past len are zeroed, but that is not an issue in our case\n    // because we're constructing the new storage array as a subarray of the original one (which should have zeroed\n    // storage past len), guaranteeing correctness. This is because `subarray` does not allow extending arrays past\n    // their original length.\n    BoundedVec::from_parts_unchecked(array::subarray(bvec.storage(), offset), bvec.len() - offset)\n}\n\nmod test {\n    use super::subbvec;\n\n    #[test]\n    unconstrained fn subbvec_empty() {\n        let bvec = BoundedVec::<Field, 0>::from_array([]);\n        assert_eq(subbvec(bvec, 0), bvec);\n    }\n\n    #[test]\n    unconstrained fn subbvec_complete() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n        assert_eq(subbvec(bvec, 0), bvec);\n\n        let smaller_capacity = BoundedVec::<_, 5>::from_array([1, 2, 3, 4, 5]);\n        assert_eq(subbvec(bvec, 0), smaller_capacity);\n    }\n\n    #[test]\n    unconstrained fn subbvec_partial() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        assert_eq(subbvec(bvec, 2), BoundedVec::<_, 8>::from_array([3, 4, 5]));\n        assert_eq(subbvec(bvec, 2), BoundedVec::<_, 3>::from_array([3, 4, 5]));\n    }\n\n    #[test]\n    unconstrained fn subbvec_into_empty() {\n        let bvec: BoundedVec<_, 10> = BoundedVec::from_array([1, 2, 3, 4, 5]);\n        assert_eq(subbvec(bvec, 5), BoundedVec::<_, 5>::from_array([]));\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subbvec_offset_past_len() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n        let _: BoundedVec<_, 1> = subbvec(bvec, 6);\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subbvec_insufficient_dst_len() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        // We're not providing enough space to hold all of the items inside the original BoundedVec. subbvec can cause\n        // for the capacity to reduce, but not the length (other than by len - offset).\n        let _: BoundedVec<_, 1> = subbvec(bvec, 2);\n    }\n\n    #[test(should_fail_with = \"DstLen too large for offset\")]\n    unconstrained fn subbvec_dst_len_causes_enlarge() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        // subbvec does not supprt capacity increases\n        let _: BoundedVec<_, 11> = subbvec(bvec, 0);\n    }\n\n    #[test(should_fail_with = \"DstLen too large for offset\")]\n    unconstrained fn subbvec_dst_len_too_large_for_offset() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        // This effectively requests a capacity increase, since there'd be just one element plus the 5 empty slots,\n        // which is less than 7.\n        let _: BoundedVec<_, 7> = subbvec(bvec, 4);\n    }\n}\n","path":"/home/filip/nargo/github.com/AztecProtocol/aztec-packages/v3.0.1-rc.1/noir-projects/aztec-nr/aztec/src/utils/array/subbvec.nr"},"235":{"source":"use std::static_assert;\n\n// These functions are used to facilitate the conversion of log ciphertext between byte and field representations.\n//\n// `bytes_to_fields` uses fixed-size arrays since encryption contexts have compile-time size information.\n// `bytes_from_fields` uses BoundedVec for flexibility in unconstrained contexts where sizes are dynamic.\n//\n// Together they provide bidirectional conversion between bytes and fields when processing encrypted logs.\n\n/// Converts the input bytes into an array of fields. A Field is ~254 bits meaning that each field can store 31 whole\n/// bytes. Use `bytes_from_fields` to obtain the original bytes array.\n///\n/// The input bytes are chunked into chunks of 31 bytes. Each 31-byte chunk is viewed as big-endian, and is converted\n/// into a Field.\n/// For example, [1, 10, 3, ..., 0] (31 bytes) is encoded as [1 * 256^30 + 10 * 256^29 + 3 * 256^28 + ... + 0]\n/// Note: N must be a multiple of 31 bytes\npub fn bytes_to_fields<let N: u32>(bytes: [u8; N]) -> [Field; N / 31] {\n    // Assert that N is a multiple of 31\n    static_assert(N % 31 == 0, \"N must be a multiple of 31\");\n\n    let mut fields = [0; N / 31];\n\n    // Since N is a multiple of 31, we can simply process all chunks fully\n    for i in 0..N / 31 {\n        let mut field = 0;\n        for j in 0..31 {\n            // Shift the existing value left by 8 bits and add the new byte\n            field = field * 256 + bytes[i * 31 + j] as Field;\n        }\n        fields[i] = field;\n    }\n\n    fields\n}\n\n/// Converts an input BoundedVec of fields into a BoundedVec of bytes in big-endian order. Arbitrary Field arrays\n/// are not allowed: this is assumed to be an array obtained via `bytes_to_fields`, i.e. one that actually represents\n/// bytes. To convert a Field array into bytes, use `fields_to_bytes`.\n///\n/// Each input field must contain at most 31 bytes (this is constrained to be so).\n/// Each field is converted into 31 big-endian bytes, and the resulting 31-byte chunks are concatenated\n/// back together in the order of the original fields.\npub fn bytes_from_fields<let N: u32>(fields: BoundedVec<Field, N>) -> BoundedVec<u8, N * 31> {\n    let mut bytes = BoundedVec::new();\n\n    for i in 0..fields.len() {\n        let field = fields.get(i);\n\n        // We expect that the field contains at most 31 bytes of information.\n        field.assert_max_bit_size::<248>();\n\n        // Now we can safely convert the field to 31 bytes.\n        let field_as_bytes: [u8; 31] = field.to_be_bytes();\n\n        for j in 0..31 {\n            bytes.push(field_as_bytes[j]);\n        }\n    }\n\n    bytes\n}\n\nmod tests {\n    use crate::utils::array::subarray;\n    use super::{bytes_from_fields, bytes_to_fields};\n\n    #[test]\n    unconstrained fn random_bytes_to_fields_and_back(input: [u8; 93]) {\n        let fields = bytes_to_fields(input);\n\n        // At this point in production, the log flies through the system and we get a BoundedVec on the other end.\n        // So we need to convert the field array to a BoundedVec to be able to feed it to the `bytes_from_fields`\n        // function.\n        let fields_as_bounded_vec = BoundedVec::<_, 6>::from_array(fields);\n\n        let bytes_back = bytes_from_fields(fields_as_bounded_vec);\n\n        // Compare the original input with the round-tripped result\n        assert_eq(bytes_back.len(), input.len());\n        assert_eq(subarray(bytes_back.storage(), 0), input);\n    }\n\n    #[test(should_fail_with = \"N must be a multiple of 31\")]\n    unconstrained fn bytes_to_fields_input_length_not_multiple_of_31() {\n        // Try to convert 32 bytes (not a multiple of 31) to fields\n        let _fields = bytes_to_fields([0; 32]);\n    }\n\n}\n","path":"/home/filip/nargo/github.com/AztecProtocol/aztec-packages/v3.0.1-rc.1/noir-projects/aztec-nr/aztec/src/utils/conversion/bytes_to_fields.nr"},"236":{"source":"// These functions are used to facilitate the conversion of log plaintext represented as fields into bytes and back.\n//\n// `fields_to_bytes` uses fixed-size arrays since encryption contexts have compile-time size information.\n// `fields_from_bytes` uses BoundedVec for flexibility in unconstrained contexts where sizes are dynamic.\n//\n// Together they provide bidirectional conversion between fields and bytes.\n\n/// Converts an input array of fields into a single array of bytes. Use `fields_from_bytes` to obtain the original\n/// field array.\n/// Each field is converted to a 32-byte big-endian array.\n///\n/// For example, if you have a field array [123, 456], it will be converted to a 64-byte array:\n/// [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,123,  // First field (32 bytes)\n///  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,200]  // Second field (32 bytes)\n///\n/// Since a field is ~254 bits, you'll end up with a subtle 2-bit \"gap\" at the big end, every 32 bytes. Be careful\n/// that such a gap doesn't leak information! This could happen if you for example expected the output to be\n/// indistinguishable from random bytes.\npub fn fields_to_bytes<let N: u32>(fields: [Field; N]) -> [u8; 32 * N] {\n    let mut bytes = [0; 32 * N];\n\n    for i in 0..N {\n        let field_as_bytes: [u8; 32] = fields[i].to_be_bytes();\n\n        for j in 0..32 {\n            bytes[i * 32 + j] = field_as_bytes[j];\n        }\n    }\n\n    bytes\n}\n\n/// Converts an input BoundedVec of bytes into a BoundedVec of fields. Arbitrary byte arrays are not allowed: this\n/// is assumed to be an array obtained via `fields_to_bytes`, i.e. one that actually represents fields. To convert\n/// a byte array into Fields, use `bytes_to_fields`.\n///\n/// The input bytes are chunked into chunks of 32 bytes. Each 32-byte chunk is viewed as big-endian, and is converted\n/// into a Field.\n/// For example, [1, 10, 3, ..., 0] (32 bytes) is encoded as [1 * 256^31 + 10 * 256^30 + 3 * 256^29 + ... + 0]\n/// Note 1: N must be a multiple of 32 bytes\n/// Note 2: The max value check code was taken from std::field::to_be_bytes function.\npub fn fields_from_bytes<let N: u32>(bytes: BoundedVec<u8, N>) -> BoundedVec<Field, N / 32> {\n    // Assert that input length is a multiple of 32\n    assert(bytes.len() % 32 == 0, \"Input length must be a multiple of 32\");\n\n    let mut fields = BoundedVec::new();\n\n    let p = std::field::modulus_be_bytes();\n\n    // Since input length is a multiple of 32, we can simply process all chunks fully\n    for i in 0..bytes.len() / 32 {\n        let mut field = 0;\n\n        // Process each byte in the 32-byte chunk\n        let mut ok = false;\n\n        for j in 0..32 {\n            let next_byte = bytes.get(i * 32 + j);\n            field = field * 256 + next_byte as Field;\n\n            if !ok {\n                if next_byte != p[j] {\n                    assert(next_byte < p[j], \"Value does not fit in field\");\n                    ok = true;\n                }\n            }\n        }\n        assert(ok, \"Value does not fit in field\");\n\n        fields.push(field);\n    }\n\n    fields\n}\n\nmod tests {\n    use crate::utils::array::subarray;\n    use super::{fields_from_bytes, fields_to_bytes};\n\n    #[test]\n    unconstrained fn random_fields_to_bytes_and_back(input: [Field; 3]) {\n        // Convert to bytes\n        let bytes = fields_to_bytes(input);\n\n        // At this point in production, the log flies through the system and we get a BoundedVec on the other end.\n        // So we need to convert the field array to a BoundedVec to be able to feed it to the `fields_from_bytes`\n        // function.\n        // 113 is an arbitrary max length that is larger than the input length of 96.\n        let bytes_as_bounded_vec = BoundedVec::<_, 113>::from_array(bytes);\n\n        // Convert back to fields\n        let fields_back = fields_from_bytes(bytes_as_bounded_vec);\n\n        // Compare the original input with the round-tripped result\n        assert_eq(fields_back.len(), input.len());\n        assert_eq(subarray(fields_back.storage(), 0), input);\n    }\n\n    #[test(should_fail_with = \"Input length must be a multiple of 32\")]\n    unconstrained fn to_fields_assert() {\n        // 143 is an arbitrary max length that is larger than 33\n        let input = BoundedVec::<_, 143>::from_array([\n            1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,\n            25, 26, 27, 28, 29, 30, 31, 32, 33,\n        ]);\n\n        // This should fail since 33 is not a multiple of 32\n        let _fields = fields_from_bytes(input);\n    }\n\n    #[test]\n    unconstrained fn fields_from_bytes_max_value() {\n        let max_field_as_bytes: [u8; 32] = (-1).to_be_bytes();\n        let input = BoundedVec::<_, 32>::from_array(max_field_as_bytes);\n\n        let fields = fields_from_bytes(input);\n\n        // The result should be a largest value storable in a field (-1 since we are modulo-ing)\n        assert_eq(fields.get(0), -1);\n    }\n\n    // In this test we verify that overflow check works by taking the max allowed value, bumping a random byte\n    // and then feeding it to `fields_from_bytes` as input.\n    #[test(should_fail_with = \"Value does not fit in field\")]\n    unconstrained fn fields_from_bytes_overflow(random_value: u8) {\n        let index_of_byte_to_bump = random_value % 32;\n\n        // Obtain the byte representation of the maximum field value\n        let max_field_value_as_bytes: [u8; 32] = (-1).to_be_bytes();\n\n        let byte_to_bump = max_field_value_as_bytes[index_of_byte_to_bump as u32];\n\n        // Skip test execution if the selected byte is already at maximum value (255).\n        // This is acceptable since we are using fuzz testing to generate many test cases.\n        if byte_to_bump != 255 {\n            let mut input = BoundedVec::<_, 32>::from_array(max_field_value_as_bytes);\n\n            // Increment the selected byte to exceed the field's maximum value\n            input.set(index_of_byte_to_bump as u32, byte_to_bump + 1);\n\n            // Attempt the conversion, which should fail due to the value exceeding the field's capacity\n            let _fields = fields_from_bytes(input);\n        }\n    }\n\n}\n","path":"/home/filip/nargo/github.com/AztecProtocol/aztec-packages/v3.0.1-rc.1/noir-projects/aztec-nr/aztec/src/utils/conversion/fields_to_bytes.nr"},"239":{"source":"use protocol_types::{point::Point, utils::field::sqrt};\n\n// I am storing the modulus minus 1 divided by 2 here because full modulus would throw \"String literal too large\" error\n// Full modulus is 21888242871839275222246405745257275088548364400416034343698204186575808495617\nglobal BN254_FR_MODULUS_DIV_2: Field =\n    10944121435919637611123202872628637544274182200208017171849102093287904247808;\n\n/// Converts a point to a byte array.\n///\n/// We don't serialize the point at infinity flag because this function is used in situations where we do not want\n/// to waste the extra byte (encrypted log).\npub fn point_to_bytes(p: Point) -> [u8; 32] {\n    // Note that there is 1 more free bit in the 32 bytes (254 bits currently occupied by the x coordinate, 1 bit for\n    // the \"sign\") so it's possible to use that last bit as an \"is_infinite\" flag if desired in the future.\n    assert(!p.is_infinite, \"Cannot serialize point at infinity as bytes.\");\n\n    let mut result: [u8; 32] = p.x.to_be_bytes();\n\n    if get_sign_of_point(p) {\n        // y is <= (modulus - 1) / 2 so we set the sign bit to 1\n        // Here we leverage that field fits into 254 bits (log2(Fr.MODULUS) < 254) and given that we serialize Fr to 32\n        // bytes and we use big-endian the 2 most significant bits are never populated. Hence we can use one of\n        // the bits as a sign bit.\n        result[0] += 128;\n    }\n\n    result\n}\n\n/**\n * Returns: true if p.y <= MOD_DIV_2, else false.\n */\npub fn get_sign_of_point(p: Point) -> bool {\n    // We store only a \"sign\" of the y coordinate because the rest can be derived from the x coordinate. To get\n    // the sign we check if the y coordinate is less or equal than the curve's order minus 1 divided by 2.\n    // Ideally we'd do `y <= MOD_DIV_2`, but there's no `lte` function, so instead we do `!(y > MOD_DIV_2)`, which is\n    // equivalent, and then rewrite that as `!(MOD_DIV_2 < y)`, since we also have no `gt` function.\n    !BN254_FR_MODULUS_DIV_2.lt(p.y)\n}\n\n/// Returns a `Point` in the Grumpkin curve given its x coordinate.\n///\n/// Because not all values in the field are valid x coordinates of points in the curve (i.e. there\n/// is no corresponding y value in the field that satisfies the curve equation), it may not be\n/// possible to reconstruct a `Point`. `Option::none()` is returned in such cases.\npub fn point_from_x_coord(x: Field) -> Option<Point> {\n    // y ^ 2 = x ^ 3 - 17\n    let rhs = x * x * x - 17;\n    sqrt(rhs).map(|y| Point { x, y, is_infinite: false })\n}\n\n/// Returns a `Point` in the Grumpkin curve given its x coordinate and sign for the y coordinate.\n///\n/// Because not all values in the field are valid x coordinates of points in the curve (i.e. there\n/// is no corresponding y value in the field that satisfies the curve equation), it may not be\n/// possible to reconstruct a `Point`. `Option::none()` is returned in such cases.\n///\n/// @param x - The x coordinate of the point\n/// @param sign - The \"sign\" of the y coordinate - determines whether y <= (Fr.MODULUS - 1) / 2\npub fn point_from_x_coord_and_sign(x: Field, sign: bool) -> Option<Point> {\n    // y ^ 2 = x ^ 3 - 17\n    let rhs = x * x * x - 17;\n\n    sqrt(rhs).map(|y| {\n        // If there is a square root, we need to ensure it has the correct \"sign\"\n        let y_is_positive = !BN254_FR_MODULUS_DIV_2.lt(y);\n        let final_y = if y_is_positive == sign { y } else { -y };\n        Point { x, y: final_y, is_infinite: false }\n    })\n}\n\nmod test {\n    use crate::utils::point::{point_from_x_coord, point_from_x_coord_and_sign, point_to_bytes};\n    use dep::protocol_types::point::Point;\n    use dep::protocol_types::utils::field::pow;\n\n    #[test]\n    unconstrained fn test_point_to_bytes_positive_sign() {\n        let p = Point {\n            x: 0x1af41f5de96446dc3776a1eb2d98bb956b7acd9979a67854bec6fa7c2973bd73,\n            y: 0x07fc22c7f2c7057571f137fe46ea9c95114282bc95d37d71ec4bfb88de457d4a,\n            is_infinite: false,\n        };\n\n        let compressed_point = point_to_bytes(p);\n\n        let expected_compressed_point_positive_sign = [\n            154, 244, 31, 93, 233, 100, 70, 220, 55, 118, 161, 235, 45, 152, 187, 149, 107, 122,\n            205, 153, 121, 166, 120, 84, 190, 198, 250, 124, 41, 115, 189, 115,\n        ];\n        assert_eq(expected_compressed_point_positive_sign, compressed_point);\n    }\n\n    #[test]\n    unconstrained fn test_point_to_bytes_negative_sign() {\n        let p = Point {\n            x: 0x247371652e55dd74c9af8dbe9fb44931ba29a9229994384bd7077796c14ee2b5,\n            y: 0x26441aec112e1ae4cee374f42556932001507ad46e255ffb27369c7e3766e5c0,\n            is_infinite: false,\n        };\n\n        let compressed_point = point_to_bytes(p);\n\n        let expected_compressed_point_negative_sign = [\n            36, 115, 113, 101, 46, 85, 221, 116, 201, 175, 141, 190, 159, 180, 73, 49, 186, 41, 169,\n            34, 153, 148, 56, 75, 215, 7, 119, 150, 193, 78, 226, 181,\n        ];\n\n        assert_eq(expected_compressed_point_negative_sign, compressed_point);\n    }\n\n    #[test]\n    unconstrained fn test_point_from_x_coord_and_sign() {\n        // Test positive y coordinate\n        let x = 0x1af41f5de96446dc3776a1eb2d98bb956b7acd9979a67854bec6fa7c2973bd73;\n        let sign = true;\n        let p = point_from_x_coord_and_sign(x, sign).unwrap();\n\n        assert_eq(p.x, x);\n        assert_eq(p.y, 0x07fc22c7f2c7057571f137fe46ea9c95114282bc95d37d71ec4bfb88de457d4a);\n        assert_eq(p.is_infinite, false);\n\n        // Test negative y coordinate\n        let x2 = 0x247371652e55dd74c9af8dbe9fb44931ba29a9229994384bd7077796c14ee2b5;\n        let sign2 = false;\n        let p2 = point_from_x_coord_and_sign(x2, sign2).unwrap();\n\n        assert_eq(p2.x, x2);\n        assert_eq(p2.y, 0x26441aec112e1ae4cee374f42556932001507ad46e255ffb27369c7e3766e5c0);\n        assert_eq(p2.is_infinite, false);\n    }\n\n    #[test]\n    unconstrained fn test_point_from_x_coord_valid() {\n        // x = 8 is a known quadratic residue - should give a valid point\n        let result = point_from_x_coord(Field::from(8));\n        assert(result.is_some());\n\n        let point = result.unwrap();\n        assert_eq(point.x, Field::from(8));\n        // Check curve equation y^2 = x^3 - 17\n        assert_eq(pow(point.y, 2), pow(point.x, 3) - 17);\n    }\n\n    #[test]\n    unconstrained fn test_point_from_x_coord_invalid() {\n        // x = 3 is a non-residue for this curve - should give None\n        let x = Field::from(3);\n        let maybe_point = point_from_x_coord(x);\n        assert(maybe_point.is_none());\n    }\n\n}\n","path":"/home/filip/nargo/github.com/AztecProtocol/aztec-packages/v3.0.1-rc.1/noir-projects/aztec-nr/aztec/src/utils/point.nr"},"250":{"source":"use std::default::Default;\nuse std::hash::Hasher;\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2 {\n    cache: [Field; 3],\n    state: [Field; 4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2 {\n        let mut result =\n            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv: Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\npub struct Poseidon2Hasher {\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n","path":"/home/filip/nargo/github.com/noir-lang/poseidon/v0.1.1/src/poseidon2.nr"},"270":{"source":"use crate::traits::{Deserialize, Empty, FromField, Serialize, ToField};\nuse std::meta::derive;\n\n#[derive(Deserialize, Eq, Serialize)]\npub struct FunctionSelector {\n    // 1st 4-bytes (big-endian leftmost) of abi-encoding of an event.\n    pub inner: u32,\n}\n\nimpl FromField for FunctionSelector {\n    fn from_field(field: Field) -> Self {\n        Self { inner: field as u32 }\n    }\n}\n\nimpl ToField for FunctionSelector {\n    fn to_field(self) -> Field {\n        self.inner as Field\n    }\n}\n\nimpl Empty for FunctionSelector {\n    fn empty() -> Self {\n        Self { inner: 0 as u32 }\n    }\n}\n\nimpl FunctionSelector {\n    pub fn from_u32(value: u32) -> Self {\n        Self { inner: value }\n    }\n\n    pub fn from_signature<let N: u32>(signature: str<N>) -> Self {\n        let bytes = signature.as_bytes();\n        let hash = crate::hash::poseidon2_hash_bytes(bytes);\n\n        // `hash` is automatically truncated to fit within 32 bits.\n        FunctionSelector::from_field(hash)\n    }\n\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n}\n\n#[test]\nfn test_is_valid_selector() {\n    let selector = FunctionSelector::from_signature(\"IS_VALID()\");\n    assert_eq(selector.to_field(), 0x73cdda47);\n}\n\n#[test]\nfn test_long_selector() {\n    let selector =\n        FunctionSelector::from_signature(\"foo_and_bar_and_baz_and_foo_bar_baz_and_bar_foo\");\n    assert_eq(selector.to_field(), 0x7590a997);\n}\n","path":"/home/filip/nargo/github.com/AztecProtocol/aztec-packages/v3.0.1-rc.1/noir-projects/noir-protocol-circuits/crates/types/src/abis/function_selector.nr"},"308":{"source":"use crate::{\n    address::{\n        partial_address::PartialAddress, salted_initialization_hash::SaltedInitializationHash,\n    },\n    constants::{\n        AZTEC_ADDRESS_LENGTH, GENERATOR_INDEX__CONTRACT_ADDRESS_V1, MAX_FIELD_VALUE,\n        MAX_PROTOCOL_CONTRACTS,\n    },\n    contract_class_id::ContractClassId,\n    hash::poseidon2_hash_with_separator,\n    public_keys::{IvpkM, NpkM, OvpkM, PublicKeys, ToPoint, TpkM},\n    traits::{Deserialize, Empty, FromField, Packable, Serialize, ToField},\n    utils::field::{pow, sqrt},\n};\n\n// We do below because `use crate::point::Point;` does not work\nuse dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\n\nuse crate::public_keys::AddressPoint;\nuse std::{\n    embedded_curve_ops::{EmbeddedCurveScalar, fixed_base_scalar_mul as derive_public_key},\n    ops::Add,\n};\nuse std::meta::derive;\n\n// Aztec address\n#[derive(Deserialize, Eq, Packable, Serialize)]\npub struct AztecAddress {\n    pub inner: Field,\n}\n\nimpl Empty for AztecAddress {\n    fn empty() -> Self {\n        Self { inner: 0 }\n    }\n}\n\nimpl ToField for AztecAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl FromField for AztecAddress {\n    fn from_field(value: Field) -> AztecAddress {\n        AztecAddress { inner: value }\n    }\n}\n\nimpl AztecAddress {\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n\n    /// Returns an address's `AddressPoint`, which can be used to create shared secrets with the owner\n    /// of the address. If the address is invalid (i.e. it is not a properly derived Aztec address), then this\n    /// returns `Option::none()`, and no shared secrets can be created.\n    pub fn to_address_point(self) -> Option<AddressPoint> {\n        // We compute the address point by taking our address, setting it to x, and then solving for y in the\n        // equation which defines our bn curve:\n        // y^2 = x^3 - 17; x = address\n        let x = self.inner;\n        let y_squared = pow(x, 3) - 17;\n\n        // An invalid AztecAddress is one for which no y coordinate satisfies the curve equation, which we'll\n        // identify by proving that the square root of y_squared does not exist.\n        let mut y_opt = sqrt(y_squared);\n        if y_opt.is_none() {\n            Option::none()\n        } else {\n            let mut y = y_opt.unwrap();\n\n            // If we get a negative y coordinate (any y where y > MAX_FIELD_VALUE / 2), we pin it to the\n            // positive one (any value where y <= MAX_FIELD_VALUE / 2) by subtracting it from the Field modulus\n            // note: The field modulus is MAX_FIELD_VALUE + 1\n            if (!(y.lt(MAX_FIELD_VALUE / 2) | y.eq(MAX_FIELD_VALUE / 2))) {\n                y = (MAX_FIELD_VALUE + 1) - y;\n            }\n\n            Option::some(\n                AddressPoint { inner: Point { x: self.inner, y, is_infinite: false } },\n            )\n        }\n    }\n\n    pub fn compute(public_keys: PublicKeys, partial_address: PartialAddress) -> AztecAddress {\n        let public_keys_hash = public_keys.hash();\n\n        let pre_address = poseidon2_hash_with_separator(\n            [public_keys_hash.to_field(), partial_address.to_field()],\n            GENERATOR_INDEX__CONTRACT_ADDRESS_V1,\n        );\n\n        let address_point = derive_public_key(EmbeddedCurveScalar::from_field(pre_address)).add(\n            public_keys.ivpk_m.to_point(),\n        );\n\n        // Note that our address is only the x-coordinate of the full address_point. This is okay because when people want to encrypt something and send it to us\n        // they can recover our full point using the x-coordinate (our address itself). To do this, they recompute the y-coordinate according to the equation y^2 = x^3 - 17.\n        // When they do this, they may get a positive y-coordinate (a value that is less than or equal to MAX_FIELD_VALUE / 2) or\n        // a negative y-coordinate (a value that is more than MAX_FIELD_VALUE), and we cannot dictate which one they get and hence the recovered point may sometimes be different than the one\n        // our secret can decrypt. Regardless though, they should and will always encrypt using point with the positive y-coordinate by convention.\n        // This ensures that everyone encrypts to the same point given an arbitrary x-coordinate (address). This is allowed because even though our original point may not have a positive y-coordinate,\n        // with our original secret, we will be able to derive the secret to the point with the flipped (and now positive) y-coordinate that everyone encrypts to.\n        AztecAddress::from_field(address_point.x)\n    }\n\n    pub fn compute_from_class_id(\n        contract_class_id: ContractClassId,\n        salted_initialization_hash: SaltedInitializationHash,\n        public_keys: PublicKeys,\n    ) -> Self {\n        let partial_address = PartialAddress::compute_from_salted_initialization_hash(\n            contract_class_id,\n            salted_initialization_hash,\n        );\n\n        AztecAddress::compute(public_keys, partial_address)\n    }\n\n    pub fn is_protocol_contract(self) -> bool {\n        self.inner.lt(MAX_PROTOCOL_CONTRACTS as Field)\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.inner == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n}\n\n#[test]\nfn compute_address_from_partial_and_pub_keys() {\n    let public_keys = PublicKeys {\n        npk_m: NpkM {\n            inner: Point {\n                x: 0x22f7fcddfa3ce3e8f0cc8e82d7b94cdd740afa3e77f8e4a63ea78a239432dcab,\n                y: 0x0471657de2b6216ade6c506d28fbc22ba8b8ed95c871ad9f3e3984e90d9723a7,\n                is_infinite: false,\n            },\n        },\n        ivpk_m: IvpkM {\n            inner: Point {\n                x: 0x111223493147f6785514b1c195bb37a2589f22a6596d30bb2bb145fdc9ca8f1e,\n                y: 0x273bbffd678edce8fe30e0deafc4f66d58357c06fd4a820285294b9746c3be95,\n                is_infinite: false,\n            },\n        },\n        ovpk_m: OvpkM {\n            inner: Point {\n                x: 0x09115c96e962322ffed6522f57194627136b8d03ac7469109707f5e44190c484,\n                y: 0x0c49773308a13d740a7f0d4f0e6163b02c5a408b6f965856b6a491002d073d5b,\n                is_infinite: false,\n            },\n        },\n        tpk_m: TpkM {\n            inner: Point {\n                x: 0x00d3d81beb009873eb7116327cf47c612d5758ef083d4fda78e9b63980b2a762,\n                y: 0x2f567d22d2b02fe1f4ad42db9d58a36afd1983e7e2909d1cab61cafedad6193a,\n                is_infinite: false,\n            },\n        },\n    };\n\n    let partial_address = PartialAddress::from_field(\n        0x0a7c585381b10f4666044266a02405bf6e01fa564c8517d4ad5823493abd31de,\n    );\n\n    let address = AztecAddress::compute(public_keys, partial_address);\n\n    // The following value was generated by `derivation.test.ts`.\n    // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\n    let expected_computed_address_from_partial_and_pubkeys =\n        0x24e4646f58b9fbe7d38e317db8d5636c423fbbdfbe119fc190fe9c64747e0c62;\n    assert(address.to_field() == expected_computed_address_from_partial_and_pubkeys);\n}\n\n#[test]\nfn compute_preaddress_from_partial_and_pub_keys() {\n    let pre_address = poseidon2_hash_with_separator([1, 2], GENERATOR_INDEX__CONTRACT_ADDRESS_V1);\n    let expected_computed_preaddress_from_partial_and_pubkey =\n        0x23ce9be3fa3c846b0f9245cc796902e731d04f086e8a42473bb29e405fc98075;\n    assert(pre_address == expected_computed_preaddress_from_partial_and_pubkey);\n}\n\n#[test]\nfn from_field_to_field() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(FromField::from_field(address.to_field()), address);\n}\n\n#[test]\nfn serde() {\n    let address = AztecAddress { inner: 37 };\n    // We use the AZTEC_ADDRESS_LENGTH constant to ensure that there is a match between the derived trait\n    // implementation and the constant.\n    let serialized: [Field; AZTEC_ADDRESS_LENGTH] = address.serialize();\n    let deserialized = AztecAddress::deserialize(serialized);\n    assert_eq(address, deserialized);\n}\n\n#[test]\nfn to_address_point_valid() {\n    // x = 8 where x^3 - 17 = 512 - 17 = 495, which is a residue in this field\n    let address = AztecAddress { inner: 8 };\n    let maybe_point = address.to_address_point();\n    assert(maybe_point.is_some());\n\n    let point = maybe_point.unwrap().inner;\n    // check that x is preserved\n    assert_eq(point.x, Field::from(8));\n\n    // check that the curve equation holds: y^2 == x^3 - 17\n    assert_eq(pow(point.y, 2), pow(point.x, 3) - 17);\n}\n\n#[test]\nunconstrained fn to_address_point_invalid() {\n    // x = 3 where x^3 - 17 = 27 - 17 = 10, which is a non-residue in this field\n    let address = AztecAddress { inner: 3 }; //\n    let maybe_point = address.to_address_point();\n    assert(maybe_point.is_none());\n}\n","path":"/home/filip/nargo/github.com/AztecProtocol/aztec-packages/v3.0.1-rc.1/noir-projects/noir-protocol-circuits/crates/types/src/address/aztec_address.nr"},"329":{"source":"// TODO: Expose other wrapped functions than debug (info, warn)\n// ['silent', 'fatal', 'error', 'warn', 'info', 'verbose', 'debug', 'trace']\n\npub global SILENT_LOG_LEVEL: u8 = 0;\npub global FATAL_LOG_LEVEL: u8 = 1;\npub global ERROR_LOG_LEVEL: u8 = 2;\npub global WARN_LOG_LEVEL: u8 = 3;\npub global INFO_LOG_LEVEL: u8 = 4;\npub global VERBOSE_LOG_LEVEL: u8 = 5;\npub global DEBUG_LOG_LEVEL: u8 = 6;\npub global TRACE_LOG_LEVEL: u8 = 7;\n\n/// Utility function to console.log data in the acir simulator.\n/// Example:\n///   debug_log(\"blah blah this is a debug string\");\npub fn debug_log<let N: u32>(msg: str<N>) {\n    debug_log_format(msg, []);\n}\n\n/// Same as debug_log, but allows to customize the log level.\n/// Consider changing just to 'log'\npub fn debug_log_with_level<let N: u32>(log_level: u8, msg: str<N>) {\n    debug_log_format_with_level(log_level, msg, []);\n}\n\n/// Utility function to console.log data in the acir simulator. This variant receives a format string in which the\n/// `${k}` tokens will be replaced with the k-eth value in the `args` array.\n/// Examples:\n///   debug_log_format(\"get_2(slot:{0}) =>\\n\\t0:{1}\\n\\t1:{2}\", [storage_slot, note0_hash, note1_hash]);\n///   debug_log_format(\"whole array: {}\", [e1, e2, e3, e4]);\npub fn debug_log_format<let M: u32, let N: u32>(msg: str<M>, args: [Field; N]) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe { debug_log_array_oracle_wrapper(DEBUG_LOG_LEVEL, msg, args) };\n}\n\n/// Same as debug_log_format, but allows to customize the log level.\n/// Consider changing just to 'log_format'\npub fn debug_log_format_with_level<let M: u32, let N: u32>(\n    log_level: u8,\n    msg: str<M>,\n    args: [Field; N],\n) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe { debug_log_array_oracle_wrapper(log_level, msg, args) };\n}\n\n/// Utility function to console.log data in the acir simulator. This variant receives a format string in which the\n/// `${k}` tokens will be replaced with the k-eth value in the `args` slice.\n/// Examples:\n///   debug_log_format(\"get_2(slot:{0}) =>\\n\\t0:{1}\\n\\t1:{2}\", [storage_slot, note0_hash, note1_hash]);\n///   debug_log_format(\"whole slice: {}\", [e1, e2, e3, e4]);\npub fn debug_log_format_slice<let M: u32>(log_level: u8, msg: str<M>, args: [Field]) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe { debug_log_slice_oracle_wrapper(log_level, msg, args) };\n}\n\n// We provide two versions of the debug log oracle: one that takes args as a slice and another one that takes args as an array.\n// We do this since conversion from array to slice generates overhead in public functions, since opcodes need to be emitted for the conversion.\n// By exposing the two flavors, we avoid conversions since the AVM is able to handle both arrays an slices in this oracle.\n\nunconstrained fn debug_log_slice_oracle_wrapper<let M: u32>(\n    log_level: u8,\n    msg: str<M>,\n    args: [Field],\n) {\n    debug_log_slice_oracle(log_level, msg, args);\n}\n\n// WARNING: sometimes when using debug logs the ACVM errors with: `thrown: \"solver opcode resolution error: cannot solve opcode: expression has too many unknowns x155\"`\n#[oracle(utilityDebugLog)]\nunconstrained fn debug_log_slice_oracle<let M: u32>(log_level: u8, msg: str<M>, args: [Field]) {}\n\nunconstrained fn debug_log_array_oracle_wrapper<let M: u32, let N: u32>(\n    log_level: u8,\n    msg: str<M>,\n    args: [Field; N],\n) {\n    debug_log_array_oracle(log_level, msg, N, args);\n}\n\n#[oracle(utilityDebugLog)]\nunconstrained fn debug_log_array_oracle<let M: u32, let N: u32>(\n    log_level: u8,\n    msg: str<M>,\n    length: u32,\n    args: [Field; N],\n) {}\n","path":"/home/filip/nargo/github.com/AztecProtocol/aztec-packages/v3.0.1-rc.1/noir-projects/noir-protocol-circuits/crates/types/src/debug_log.nr"},"339":{"source":"mod poseidon2_chunks;\n\nuse crate::{\n    abis::{\n        contract_class_function_leaf_preimage::ContractClassFunctionLeafPreimage,\n        function_selector::FunctionSelector,\n        note_hash::NoteHash,\n        nullifier::Nullifier,\n        private_log::{PrivateLog, PrivateLogData},\n        transaction::tx_request::TxRequest,\n    },\n    address::{AztecAddress, EthAddress},\n    constants::{\n        CONTRACT_CLASS_LOG_SIZE_IN_FIELDS, FUNCTION_TREE_HEIGHT, GENERATOR_INDEX__NOTE_HASH_NONCE,\n        GENERATOR_INDEX__OUTER_NULLIFIER, GENERATOR_INDEX__SILOED_NOTE_HASH,\n        GENERATOR_INDEX__UNIQUE_NOTE_HASH, NULL_MSG_SENDER_CONTRACT_ADDRESS, TWO_POW_64,\n    },\n    merkle_tree::root_from_sibling_path,\n    messaging::l2_to_l1_message::L2ToL1Message,\n    poseidon2::Poseidon2Sponge,\n    side_effect::{Counted, Scoped},\n    traits::{FromField, Hash, ToField},\n    utils::field::{field_from_bytes, field_from_bytes_32_trunc},\n};\n\npub use poseidon2_chunks::poseidon2_absorb_in_chunks_existing_sponge;\nuse poseidon2_chunks::poseidon2_absorb_in_chunks;\nuse std::embedded_curve_ops::EmbeddedCurveScalar;\n\npub fn sha256_to_field<let N: u32>(bytes_to_hash: [u8; N]) -> Field {\n    let sha256_hashed = sha256::digest(bytes_to_hash);\n    let hash_in_a_field = field_from_bytes_32_trunc(sha256_hashed);\n\n    hash_in_a_field\n}\n\npub fn private_functions_root_from_siblings(\n    selector: FunctionSelector,\n    vk_hash: Field,\n    function_leaf_index: Field,\n    function_leaf_sibling_path: [Field; FUNCTION_TREE_HEIGHT],\n) -> Field {\n    let function_leaf_preimage = ContractClassFunctionLeafPreimage { selector, vk_hash };\n    let function_leaf = function_leaf_preimage.hash();\n    root_from_sibling_path(\n        function_leaf,\n        function_leaf_index,\n        function_leaf_sibling_path,\n    )\n}\n\npub fn compute_note_hash_nonce(first_nullifier_in_tx: Field, note_index_in_tx: u32) -> Field {\n    // Hashing the first nullifier with note index in tx is guaranteed to be unique (because all nullifiers are also\n    // unique).\n    poseidon2_hash_with_separator(\n        [first_nullifier_in_tx, note_index_in_tx as Field],\n        GENERATOR_INDEX__NOTE_HASH_NONCE,\n    )\n}\n\npub fn compute_unique_note_hash(note_nonce: Field, siloed_note_hash: Field) -> Field {\n    let inputs = [note_nonce, siloed_note_hash];\n    poseidon2_hash_with_separator(inputs, GENERATOR_INDEX__UNIQUE_NOTE_HASH)\n}\n\npub fn compute_nonce_and_unique_note_hash(\n    siloed_note_hash: Field,\n    first_nullifier: Field,\n    note_index_in_tx: u32,\n) -> Field {\n    let note_nonce = compute_note_hash_nonce(first_nullifier, note_index_in_tx);\n    compute_unique_note_hash(note_nonce, siloed_note_hash)\n}\n\npub fn compute_siloed_note_hash(app: AztecAddress, note_hash: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [app.to_field(), note_hash],\n        GENERATOR_INDEX__SILOED_NOTE_HASH,\n    )\n}\n\n/// Computes unique note hashes from siloed note hashes\npub fn compute_unique_siloed_note_hash(\n    siloed_note_hash: Field,\n    first_nullifier: Field,\n    note_index_in_tx: u32,\n) -> Field {\n    if siloed_note_hash == 0 {\n        0\n    } else {\n        compute_nonce_and_unique_note_hash(siloed_note_hash, first_nullifier, note_index_in_tx)\n    }\n}\n\n/// Siloing in the context of Aztec refers to the process of hashing a note hash with a contract address (this way\n/// the note hash is scoped to a specific contract). This is used to prevent intermingling of notes between contracts.\npub fn silo_note_hash(note_hash: Scoped<Counted<NoteHash>>) -> Field {\n    if note_hash.contract_address.is_zero() {\n        0\n    } else {\n        compute_siloed_note_hash(note_hash.contract_address, note_hash.innermost())\n    }\n}\n\npub fn compute_siloed_nullifier(app: AztecAddress, nullifier: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [app.to_field(), nullifier],\n        GENERATOR_INDEX__OUTER_NULLIFIER,\n    )\n}\n\npub fn silo_nullifier(nullifier: Scoped<Counted<Nullifier>>) -> Field {\n    let value = nullifier.innermost().value;\n    // Q: shouldn't we be checking whether the _whole_ nullifier is empty?\n    // A: We don't have to. The init and inner circuits add contract address to non-empty nullifiers.\n    // So we know we should silo it if the contract address is not empty.\n    if nullifier.contract_address.is_zero() {\n        value // Return `value` instead of 0 because an already-siloed nullifier's contract address is zero.\n    } else {\n        compute_siloed_nullifier(nullifier.contract_address, value)\n    }\n}\n\npub fn create_protocol_nullifier(tx_request: TxRequest) -> Scoped<Counted<Nullifier>> {\n    Nullifier { value: tx_request.hash(), note_hash: 0 }.count(1).scope(\n        NULL_MSG_SENDER_CONTRACT_ADDRESS,\n    )\n}\n\npub fn compute_siloed_private_log_field(contract_address: AztecAddress, field: Field) -> Field {\n    poseidon2_hash([contract_address.to_field(), field])\n}\n\npub fn silo_private_log(private_log: Scoped<Counted<PrivateLogData>>) -> PrivateLog {\n    let log = private_log.innermost().log;\n    if private_log.contract_address.is_zero() {\n        log\n    } else {\n        let mut fields = log.fields;\n        fields[0] = compute_siloed_private_log_field(private_log.contract_address, fields[0]);\n        PrivateLog::new(fields, log.length)\n    }\n}\n\npub fn compute_contract_class_log_hash(log: [Field; CONTRACT_CLASS_LOG_SIZE_IN_FIELDS]) -> Field {\n    poseidon2_hash(log)\n}\n\npub fn compute_app_secret_key(\n    master_secret_key: EmbeddedCurveScalar,\n    app_address: AztecAddress,\n    app_secret_generator: Field,\n) -> Field {\n    poseidon2_hash_with_separator(\n        [master_secret_key.hi, master_secret_key.lo, app_address.to_field()],\n        app_secret_generator,\n    )\n}\n\npub fn merkle_hash(left: Field, right: Field) -> Field {\n    poseidon2_hash([left, right])\n}\n\npub fn compute_l2_to_l1_hash(\n    contract_address: AztecAddress,\n    recipient: EthAddress,\n    content: Field,\n    rollup_version_id: Field,\n    chain_id: Field,\n) -> Field {\n    let contract_address_bytes: [u8; 32] = contract_address.to_field().to_be_bytes();\n    let recipient_bytes: [u8; 20] = recipient.to_be_bytes();\n    let content_bytes: [u8; 32] = content.to_be_bytes();\n    let rollup_version_id_bytes: [u8; 32] = rollup_version_id.to_be_bytes();\n    let chain_id_bytes: [u8; 32] = chain_id.to_be_bytes();\n\n    let mut bytes: [u8; 148] = std::mem::zeroed();\n    for i in 0..32 {\n        bytes[i] = contract_address_bytes[i];\n        bytes[i + 32] = rollup_version_id_bytes[i];\n        // 64 - 84 are for recipient.\n        bytes[i + 84] = chain_id_bytes[i];\n        bytes[i + 116] = content_bytes[i];\n    }\n\n    for i in 0..20 {\n        bytes[64 + i] = recipient_bytes[i];\n    }\n\n    sha256_to_field(bytes)\n}\n\npub fn silo_l2_to_l1_message(\n    msg: Scoped<L2ToL1Message>,\n    rollup_version_id: Field,\n    chain_id: Field,\n) -> Field {\n    if msg.contract_address.is_zero() {\n        0\n    } else {\n        compute_l2_to_l1_hash(\n            msg.contract_address,\n            msg.inner.recipient,\n            msg.inner.content,\n            rollup_version_id,\n            chain_id,\n        )\n    }\n}\n\n/// Computes sha256 hash of 2 input fields.\n///\n/// @returns A truncated field (i.e., the first byte is always 0).\npub fn accumulate_sha256(v0: Field, v1: Field) -> Field {\n    // Concatenate two fields into 32 x 2 = 64 bytes\n    let v0_as_bytes: [u8; 32] = v0.to_be_bytes();\n    let v1_as_bytes: [u8; 32] = v1.to_be_bytes();\n    let hash_input_flattened = v0_as_bytes.concat(v1_as_bytes);\n\n    sha256_to_field(hash_input_flattened)\n}\n\n#[inline_always]\npub fn pedersen_hash<let N: u32>(inputs: [Field; N], hash_index: u32) -> Field {\n    std::hash::pedersen_hash_with_separator(inputs, hash_index)\n}\n\npub fn poseidon2_hash<let N: u32>(inputs: [Field; N]) -> Field {\n    poseidon::poseidon2::Poseidon2::hash(inputs, N)\n}\n\n#[no_predicates]\npub fn poseidon2_hash_with_separator<let N: u32, T>(inputs: [Field; N], separator: T) -> Field\nwhere\n    T: ToField,\n{\n    let inputs_with_separator = [separator.to_field()].concat(inputs);\n    poseidon2_hash(inputs_with_separator)\n}\n\n/// Computes a Poseidon2 hash over a dynamic-length subarray of the given input.\n/// Only the first `in_len` fields of `input` are absorbed; any remaining fields are ignored.\n/// The caller is responsible for ensuring that the input is padded with zeros if required.\n#[no_predicates]\npub fn poseidon2_hash_subarray<let N: u32>(input: [Field; N], in_len: u32) -> Field {\n    let mut sponge = poseidon2_absorb_in_chunks(input, in_len);\n    sponge.squeeze()\n}\n\n// NB the below is the same as poseidon::poseidon2::Poseidon2::hash(), but replacing a range check with a bit check,\n// and absorbing in chunks of 3 below.\n#[no_predicates]\npub fn poseidon2_cheaper_variable_hash<let N: u32>(input: [Field; N], in_len: u32) -> Field {\n    let mut sponge = poseidon2_absorb_in_chunks(input, in_len);\n    // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n    // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n    // fixed-length and variable-length hashes do not collide)\n    if in_len != N {\n        sponge.absorb(1);\n    }\n    sponge.squeeze()\n}\n\n// This function is  unconstrained because it is intended to be used in unconstrained context only as\n// in constrained contexts it would be too inefficient.\npub unconstrained fn poseidon2_hash_with_separator_bounded_vec<let N: u32, T>(\n    inputs: BoundedVec<Field, N>,\n    separator: T,\n) -> Field\nwhere\n    T: ToField,\n{\n    let in_len = inputs.len() + 1;\n    let iv: Field = (in_len as Field) * TWO_POW_64;\n    let mut sponge = Poseidon2Sponge::new(iv);\n    sponge.absorb(separator.to_field());\n\n    for i in 0..inputs.len() {\n        sponge.absorb(inputs.get(i));\n    }\n\n    sponge.squeeze()\n}\n\n#[no_predicates]\npub fn poseidon2_hash_bytes<let N: u32>(inputs: [u8; N]) -> Field {\n    let mut fields = [0; (N + 30) / 31];\n    let mut field_index = 0;\n    let mut current_field = [0; 31];\n    for i in 0..inputs.len() {\n        let index = i % 31;\n        current_field[index] = inputs[i];\n        if index == 30 {\n            fields[field_index] = field_from_bytes(current_field, false);\n            current_field = [0; 31];\n            field_index += 1;\n        }\n    }\n    if field_index != fields.len() {\n        fields[field_index] = field_from_bytes(current_field, false);\n    }\n    poseidon2_hash(fields)\n}\n\n#[test]\nfn poseidon_chunks_matches_fixed() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    let mut fixed_input = [3; 501];\n    assert(in_len == fixed_input.len()); // sanity check\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    let sub_chunk_hash = poseidon2_hash_subarray(input, in_len);\n    let fixed_len_hash = poseidon::poseidon2::Poseidon2::hash(fixed_input, fixed_input.len());\n    assert(sub_chunk_hash == fixed_len_hash);\n}\n\n#[test]\nfn poseidon_chunks_matches_variable() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    let variable_chunk_hash = poseidon2_cheaper_variable_hash(input, in_len);\n    let variable_len_hash = poseidon::poseidon2::Poseidon2::hash(input, in_len);\n    assert(variable_chunk_hash == variable_len_hash);\n}\n\n#[test]\nfn smoke_sha256_to_field() {\n    let full_buffer = [\n        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,\n        25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,\n        48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70,\n        71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93,\n        94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112,\n        113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130,\n        131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148,\n        149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159,\n    ];\n    let result = sha256_to_field(full_buffer);\n\n    assert(result == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184c7);\n\n    // to show correctness of the current ver (truncate one byte) vs old ver (mod full bytes):\n    let result_bytes = sha256::digest(full_buffer);\n    let truncated_field = crate::utils::field::field_from_bytes_32_trunc(result_bytes);\n    assert(truncated_field == result);\n    let mod_res = result + (result_bytes[31] as Field);\n    assert(mod_res == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184e0);\n}\n\n#[test]\nfn compute_l2_l1_hash() {\n    // All zeroes\n    let hash_result =\n        compute_l2_to_l1_hash(AztecAddress::from_field(0), EthAddress::zero(), 0, 0, 0);\n    assert(hash_result == 0x3b18c58c739716e76429634a61375c45b3b5cd470c22ab6d3e14cee23dd992);\n\n    // Non-zero case\n    let hash_result = compute_l2_to_l1_hash(\n        AztecAddress::from_field(1),\n        EthAddress::from_field(3),\n        5,\n        2,\n        4,\n    );\n    assert(hash_result == 0xaab2a5828156782b12a1dc6f336e2bc627eb1b9514b02d511f66296990c050);\n}\n\n#[test]\nfn silo_l2_to_l1_message_matches_typescript() {\n    let version = 4;\n    let chainId = 5;\n\n    let hash = silo_l2_to_l1_message(\n        L2ToL1Message { recipient: EthAddress::from_field(1), content: 2 }.scope(\n            AztecAddress::from_field(3),\n        ),\n        version,\n        chainId,\n    );\n\n    // The following value was generated by `yarn-project/stdlib/src/hash/hash.test.ts`\n    let hash_from_typescript = 0x0081edf209e087ad31b3fd24263698723d57190bd1d6e9fe056fc0c0a68ee661;\n\n    assert_eq(hash, hash_from_typescript);\n}\n\n#[test]\nunconstrained fn poseidon2_hash_with_separator_bounded_vec_matches_non_bounded_vec_version() {\n    let inputs = BoundedVec::<Field, 4>::from_array([1, 2, 3]);\n    let separator = 42;\n\n    // Hash using bounded vec version\n    let bounded_result = poseidon2_hash_with_separator_bounded_vec(inputs, separator);\n\n    // Hash using regular version\n    let regular_result = poseidon2_hash_with_separator([1, 2, 3], separator);\n\n    // Results should match\n    assert_eq(bounded_result, regular_result);\n}\n","path":"/home/filip/nargo/github.com/AztecProtocol/aztec-packages/v3.0.1-rc.1/noir-projects/noir-protocol-circuits/crates/types/src/hash.nr"},"352":{"source":"use utils::derive_serialization_quotes;\n\npub mod utils;\n\n/// Generates the generic parameter declarations for a struct's trait implementation.\n///\n/// This function takes a struct type definition and generates the generic parameter declarations\n/// that go after the `impl` keyword. For example, given a struct with generics `N: u32` and `T`,\n/// it generates `<let N: u32, T>`.\n///\n/// # Parameters\n/// - `s`: The struct type definition to generate generic declarations for\n///\n/// # Returns\n/// A quoted code block containing the generic parameter declarations, or an empty quote if the struct\n/// has no generic parameters\n///\n/// # Example\n/// For a struct defined as:\n/// ```\n/// struct Container<T, let N: u32> {\n///     items: [T; N],\n///     count: u32\n/// }\n/// ```\n///\n/// This function generates:\n/// ```\n/// <let N: u32, T>\n/// ```\ncomptime fn get_generics_declarations(s: TypeDefinition) -> Quoted {\n    let generics = s.generics();\n\n    if generics.len() > 0 {\n        let generics_declarations_items = generics\n            .map(|(name, maybe_integer_typ)| {\n                // The second item in the generics tuple is an Option of an integer type that is Some only if\n                // the generic is numeric.\n                if maybe_integer_typ.is_some() {\n                    // The generic is numeric, so we return a quote defined as e.g. \"let N: u32\"\n                    let integer_type = maybe_integer_typ.unwrap();\n                    quote {let $name: $integer_type}\n                } else {\n                    // The generic is not numeric, so we return a quote containing the name of the generic (e.g. \"T\")\n                    quote {$name}\n                }\n            })\n            .join(quote {,});\n        quote {<$generics_declarations_items>}\n    } else {\n        // The struct doesn't have any generics defined, so we just return an empty quote.\n        quote {}\n    }\n}\n\n/// Generates the `where` clause for a trait implementation that constrains non-numeric generic type parameters.\n///\n/// This function takes a struct type definition and a trait name, and generates a `where` clause that\n/// requires all non-numeric generic type parameters to implement the specified trait.\n///\n/// # Parameters\n/// - `s`: The struct type definition to generate the where clause for\n/// - `trait_name`: The name of the trait that non-numeric generic parameters must implement\n///\n/// # Returns\n/// A quoted code block containing the where clause, or an empty quote if the struct has no non-numeric\n/// generic parameters\n///\n/// # Example\n/// For a struct defined as:\n/// ```\n/// struct Container<T, let N: u32> {\n///     items: [T; N],\n///     count: u32\n/// }\n/// ```\n///\n/// And trait name \"Serialize\", this function generates:\n/// ```\n/// where T: Serialize\n/// ```\ncomptime fn get_where_trait_clause(s: TypeDefinition, trait_name: Quoted) -> Quoted {\n    let generics = s.generics();\n\n    // The second item in the generics tuple is an Option of an integer type that is Some only if the generic is\n    // numeric.\n    let non_numeric_generics =\n        generics.filter(|(_, maybe_integer_typ)| maybe_integer_typ.is_none());\n\n    if non_numeric_generics.len() > 0 {\n        let non_numeric_generics_declarations =\n            non_numeric_generics.map(|(name, _)| quote {$name: $trait_name}).join(quote {,});\n        quote {where $non_numeric_generics_declarations}\n    } else {\n        // There are no non-numeric generics, so we return an empty quote.\n        quote {}\n    }\n}\n\n/// Generates a `Serialize` trait implementation for a struct type.\n///\n/// # Parameters\n/// - `s`: The struct type definition to generate the implementation for\n///\n/// # Returns\n/// A quoted code block containing the trait implementation\n///\n/// # Example\n/// For a struct defined as:\n/// ```\n/// struct Log<N> {\n///     fields: [Field; N],\n///     length: u32\n/// }\n/// ```\n///\n/// This function generates code equivalent to:\n/// ```\n/// impl<let N: u32> Serialize for Log<N> {\n///     let N: u32 = <[Field; N] as Serialize>::N + <u32 as Serialize>::N;\n///\n///     #[inline_always]\n///     fn serialize(self) -> [Field; Self::N] {\n///         let mut serialized_params = [0; _];\n///         let mut offset = 0;\n///\n///         let serialized_member = Serialize::serialize(self.fields);\n///         let serialized_member_len = <[Field; N] as Serialize>::N;\n///         for i in 0..serialized_member_len {\n///             serialized_params[i + offset] = serialized_member[i];\n///         }\n///         offset += serialized_member_len;\n///\n///         let serialized_member = Serialize::serialize(self.length);\n///         let serialized_member_len = <u32 as Serialize>::N;\n///         for i in 0..serialized_member_len {\n///             serialized_params[i + offset] = serialized_member[i];\n///         }\n///         offset += serialized_member_len;\n///\n///         serialized_params\n///     }\n/// }\n/// ```\npub comptime fn derive_serialize(s: TypeDefinition) -> Quoted {\n    let typ = s.as_type();\n    let nested_struct = typ.as_data_type().unwrap();\n\n    // We care only about the name and type so we drop the last item of the tuple\n    let params = nested_struct.0.fields(nested_struct.1).map(|(name, typ, _)| (name, typ));\n\n    // Generates the generic parameter declarations (to be placed after the `impl` keyword) and the `where` clause\n    // for the `Serialize` trait.\n    let generics_declarations = get_generics_declarations(s);\n    let where_serialize_clause = get_where_trait_clause(s, quote {Serialize});\n\n    let (function_body, params_len_quote, serialized_params_name) =\n        derive_serialization_quotes(params, true);\n\n    quote {\n        impl$generics_declarations $crate::traits::Serialize for $typ\n            $where_serialize_clause\n        {\n            let N: u32 = $params_len_quote;\n\n            #[inline_always]\n            fn serialize(self) -> [Field; Self::N] {\n                $function_body\n\n                $serialized_params_name\n            }\n        }\n    }\n}\n\n/// Generates a `Deserialize` trait implementation for a given struct `s`.\n///\n/// # Arguments\n/// * `s` - The struct type definition to generate the implementation for\n///\n/// # Returns\n/// A `Quoted` block containing the generated trait implementation\n///\n/// # Requirements\n/// Each struct member type must implement the `Deserialize` trait (it gets used in the generated code).\n///\n/// # Example\n/// For a struct like:\n/// ```\n/// struct MyStruct {\n///     x: AztecAddress,\n///     y: Field,\n/// }\n/// ```\n///\n/// This generates:\n/// ```\n/// impl Deserialize for MyStruct {\n///     let N: u32 = <AztecAddress as Deserialize>::N + <Field as Deserialize>::N;\n///\n///     fn deserialize(serialized: [Field; Self::N]) -> Self {\n///         let mut offset = 0;\n///         let mut member_fields = [0; <AztecAddress as Deserialize>::N];\n///         for i in 0..<AztecAddress as Deserialize>::N {\n///             member_fields[i] = serialized[i + offset];\n///         }\n///         let x = <AztecAddress as Deserialize>::deserialize(member_fields);\n///         offset += <AztecAddress as Deserialize>::N;\n///\n///         let mut member_fields = [0; <Field as Deserialize>::N];\n///         for i in 0..<Field as Deserialize>::N {\n///             member_fields[i] = serialized[i + offset];\n///         }\n///         let y = <Field as Deserialize>::deserialize(member_fields);\n///         offset += <Field as Deserialize>::N;\n///\n///         Self { x, y }\n///     }\n/// }\n/// ```\npub(crate) comptime fn derive_deserialize(s: TypeDefinition) -> Quoted {\n    let typ = s.as_type();\n    let nested_struct = typ.as_data_type().unwrap();\n    let params = nested_struct.0.fields(nested_struct.1);\n\n    // Generates the generic parameter declarations (to be placed after the `impl` keyword) and the `where` clause\n    // for the `Deserialize` trait.\n    let generics_declarations = get_generics_declarations(s);\n    let where_deserialize_clause = get_where_trait_clause(s, quote {Deserialize});\n\n    // The following will give us:\n    // <type_of_struct_member_1 as Deserialize>::N + <type_of_struct_member_2 as Deserialize>::N + ...\n    // (or 0 if the struct has no members)\n    let right_hand_side_of_definition_of_n = if params.len() > 0 {\n        params\n            .map(|(_, param_type, _): (Quoted, Type, Quoted)| {\n                quote {\n            <$param_type as $crate::traits::Deserialize>::N\n        }\n            })\n            .join(quote {+})\n    } else {\n        quote {0}\n    };\n\n    // For structs containing a single member, we can enhance performance by directly deserializing the input array,\n    // bypassing the need for loop-based array construction. While this optimization yields significant benefits in\n    // Brillig where the loops are expected to not be optimized, it is not relevant in ACIR where the loops are\n    // expected to be optimized away.\n    let function_body = if params.len() > 1 {\n        // This generates deserialization code for each struct member and concatenates them together.\n        let deserialization_of_struct_members = params\n            .map(|(param_name, param_type, _): (Quoted, Type, Quoted)| {\n                quote {\n                    let mut member_fields = [0; <$param_type as Deserialize>::N];\n                    for i in 0..<$param_type as Deserialize>::N {\n                        member_fields[i] = serialized[i + offset];\n                    }\n                    let $param_name = <$param_type as Deserialize>::deserialize(member_fields);\n                    offset += <$param_type as Deserialize>::N;\n                }\n            })\n            .join(quote {});\n\n        // We join the struct member names with a comma to be used in the `Self { ... }` syntax\n        // This will give us e.g. `a, b, c` for a struct with three fields named `a`, `b`, and `c`.\n        let struct_members = params\n            .map(|(param_name, _, _): (Quoted, Type, Quoted)| quote { $param_name })\n            .join(quote {,});\n\n        quote {\n            let mut offset = 0;\n\n            $deserialization_of_struct_members\n\n            Self { $struct_members }\n        }\n    } else if params.len() == 1 {\n        let param_name = params[0].0;\n        quote {\n            Self { $param_name: $crate::traits::Deserialize::deserialize(serialized) }\n        }\n    } else {\n        quote {\n            Self {}\n        }\n    };\n\n    quote {\n        impl$generics_declarations $crate::traits::Deserialize for $typ\n            $where_deserialize_clause\n        {\n            let N: u32 = $right_hand_side_of_definition_of_n;\n\n            #[inline_always]\n            fn deserialize(serialized: [Field; Self::N]) -> Self {\n                $function_body\n            }\n        }\n    }\n}\n\n/// Generates a `Packable` trait implementation for a given struct `s`.\n///\n/// # Arguments\n/// * `s` - The struct type definition to generate the implementation for\n///\n/// # Returns\n/// A `Quoted` block containing the generated trait implementation\n///\n/// # Requirements\n/// Each struct member type must implement the `Packable` trait (it gets used in the generated code).\n///\n/// # Example\n/// For a struct like:\n/// ```\n/// struct MyStruct {\n///     x: AztecAddress,\n///     y: Field,\n/// }\n/// ```\n///\n/// This generates:\n/// ```\n/// impl Packable for MyStruct {\n///     let N: u32 = 2;\n///\n///     fn pack(self) -> [Field; 2] {\n///         let mut result: [Field; 2] = [0_Field; 2];\n///         let mut offset: u32 = 0_u32;\n///         let packed_member: [Field; 1] = self.x.pack();\n///         let packed_member_len: u32 = <Field as Packable>::N;\n///         for i in 0_u32..packed_member_len {\n///             {\n///                 result[i + offset] = packed_member[i];\n///             }\n///         }\n///         offset = offset + packed_member_len;\n///         let packed_member: [Field; 1] = self.y.pack();\n///         let packed_member_len: u32 = <Field as Packable>::N;\n///         for i in 0_u32..packed_member_len {\n///             {\n///                 result[i + offset] = packed_member[i];\n///             }\n///         }\n///         offset = offset + packed_member_len;\n///         result\n///     }\n///\n///     fn unpack(packed: [Field; 2]) -> Self {\n///         let mut offset: u32 = 0_u32;\n///         let mut member_fields: [Field; 1] = [0_Field; 1];\n///         for i in 0_u32..<AztecAddress as Packable>::N {\n///             member_fields[i] = packed[i + offset];\n///         }\n///         let x: AztecAddress = <AztecAddress as Packable>::unpack(member_fields);\n///         offset = offset + <AztecAddress as Packable>::N;\n///         let mut member_fields: [Field; 1] = [0_Field; 1];\n///         for i in 0_u32..<Field as Packable>::N {\n///             member_fields[i] = packed[i + offset];\n///         }\n///         let y: Field = <Field as Packable>::unpack(member_fields);\n///         offset = offset + <Field as Packable>::N;\n///         Self { x: x, y: y }\n///     }\n/// }\n/// ```\npub comptime fn derive_packable(s: TypeDefinition) -> Quoted {\n    let typ = s.as_type();\n    let nested_struct = typ.as_data_type().unwrap();\n    let params = nested_struct.0.fields(nested_struct.1);\n\n    // Generates the generic parameter declarations (to be placed after the `impl` keyword) and the `where` clause\n    // for the `Packable` trait.\n    let generics_declarations = get_generics_declarations(s);\n    let where_packable_clause = get_where_trait_clause(s, quote {Packable});\n\n    // The following will give us:\n    // <type_of_struct_member_1 as Packable>::N + <type_of_struct_member_2 as Packable>::N + ...\n    // (or 0 if the struct has no members)\n    let right_hand_side_of_definition_of_n = if params.len() > 0 {\n        params\n            .map(|(_, param_type, _): (Quoted, Type, Quoted)| {\n                quote {\n            <$param_type as $crate::traits::Packable>::N\n        }\n            })\n            .join(quote {+})\n    } else {\n        quote {0}\n    };\n\n    // For structs containing a single member, we can enhance performance by directly returning the packed member,\n    // bypassing the need for loop-based array construction. While this optimization yields significant benefits in\n    // Brillig where the loops are expected to not be optimized, it is not relevant in ACIR where the loops are\n    // expected to be optimized away.\n    let pack_function_body = if params.len() > 1 {\n        // For multiple struct members, generate packing code that:\n        // 1. Packs each member\n        // 2. Copies the packed fields into the result array at the correct offset\n        // 3. Updates the offset for the next member\n        let packing_of_struct_members = params\n            .map(|(param_name, param_type, _): (Quoted, Type, Quoted)| {\n                quote {\n                    let packed_member = $crate::traits::Packable::pack(self.$param_name);\n                    let packed_member_len = <$param_type as $crate::traits::Packable>::N;\n                    for i in 0..packed_member_len {\n                        result[i + offset] = packed_member[i];\n                    }\n                    offset += packed_member_len;\n                }\n            })\n            .join(quote {});\n\n        quote {\n            let mut result = [0; Self::N];\n            let mut offset = 0;\n\n            $packing_of_struct_members\n\n            result\n        }\n    } else if params.len() == 1 {\n        let param_name = params[0].0;\n        quote {\n            $crate::traits::Packable::pack(self.$param_name)\n        }\n    } else {\n        quote {\n            [0; Self::N]\n        }\n    };\n\n    // For structs containing a single member, we can enhance performance by directly unpacking the input array,\n    // bypassing the need for loop-based array construction. While this optimization yields significant benefits in\n    // Brillig where the loops are expected to not be optimized, it is not relevant in ACIR where the loops are\n    // expected to be optimized away.\n    let unpack_function_body = if params.len() > 1 {\n        // For multiple struct members, generate unpacking code that:\n        // 1. Unpacks each member\n        // 2. Copies packed fields into member array at correct offset\n        // 3. Updates offset for next member\n        let unpacking_of_struct_members = params\n            .map(|(param_name, param_type, _): (Quoted, Type, Quoted)| {\n                quote {\n                    let mut member_fields = [0; <$param_type as $crate::traits::Packable>::N];\n                    for i in 0..<$param_type as $crate::traits::Packable>::N {\n                        member_fields[i] = packed[i + offset];\n                    }\n                    let $param_name = <$param_type as $crate::traits::Packable>::unpack(member_fields);\n                    offset += <$param_type as $crate::traits::Packable>::N;\n                }\n            })\n            .join(quote {});\n\n        // We join the struct member names with a comma to be used in the `Self { ... }` syntax\n        let struct_members = params\n            .map(|(param_name, _, _): (Quoted, Type, Quoted)| quote { $param_name })\n            .join(quote {,});\n\n        quote {\n            let mut offset = 0;\n            $unpacking_of_struct_members\n            Self { $struct_members }\n        }\n    } else if params.len() == 1 {\n        let param_name = params[0].0;\n        quote {\n            Self { $param_name: $crate::traits::Packable::unpack(packed) }\n        }\n    } else {\n        quote {\n            Self {}\n        }\n    };\n\n    quote {\n        impl$generics_declarations $crate::traits::Packable for $typ\n            $where_packable_clause\n        {\n            let N: u32 = $right_hand_side_of_definition_of_n;\n\n            #[inline_always]\n            fn pack(self) -> [Field; Self::N] {\n                $pack_function_body\n            }\n\n            #[inline_always]\n            fn unpack(packed: [Field; Self::N]) -> Self {\n                $unpack_function_body\n            }\n        }\n    }\n}\n\nmod test {\n    use crate::traits::{Deserialize, Packable, Serialize};\n\n    #[derive(Deserialize, Eq, Packable, Serialize)]\n    pub struct Empty {}\n\n    #[derive(Deserialize, Eq, Packable, Serialize)]\n    pub struct Smol {\n        a: Field,\n        b: Field,\n    }\n\n    #[derive(Deserialize, Eq, Serialize)]\n    pub struct HasArray {\n        a: [Field; 2],\n        b: bool,\n    }\n\n    #[derive(Deserialize, Eq, Serialize)]\n    pub struct Fancier {\n        a: Smol,\n        b: [Field; 2],\n        c: [u8; 3],\n        d: str<16>,\n    }\n\n    #[derive(Deserialize, Eq, Packable, Serialize)]\n    pub struct HasArrayWithGenerics<T, let N: u32> {\n        pub fields: [T; N],\n        pub length: u32,\n    }\n\n    #[test]\n    fn serde_on_empty() {\n        let original = Empty {};\n        let serialized = original.serialize();\n        assert_eq(serialized, [], \"Serialized does not match empty array\");\n        let deserialized = Empty::deserialize(serialized);\n        assert_eq(deserialized, original, \"Deserialized does not match original\");\n    }\n\n    #[test]\n    fn packable_on_empty() {\n        let original = Empty {};\n        let packed = original.pack();\n        assert_eq(packed, [], \"Packed does not match empty array\");\n        let unpacked = Empty::unpack(packed);\n        assert_eq(unpacked, original, \"Unpacked does not match original\");\n    }\n\n    #[test]\n    fn serde_on_smol() {\n        let smol = Smol { a: 1, b: 2 };\n        let serialized = smol.serialize();\n        assert(serialized == [1, 2], serialized);\n        let deserialized = Smol::deserialize(serialized);\n        assert(deserialized == smol);\n\n        // None of the struct members implements the `Packable` trait so the packed and serialized data should be the same\n        let packed = smol.pack();\n        assert_eq(packed, serialized, \"Packed does not match serialized\");\n    }\n\n    #[test]\n    fn serde_on_has_array() {\n        let has_array = HasArray { a: [1, 2], b: true };\n        let serialized = has_array.serialize();\n        assert(serialized == [1, 2, 1], serialized);\n        let deserialized = HasArray::deserialize(serialized);\n        assert(deserialized == has_array);\n    }\n\n    #[test]\n    fn serde_on_fancier() {\n        let fancier =\n            Fancier { a: Smol { a: 1, b: 2 }, b: [0, 1], c: [1, 2, 3], d: \"metaprogramming!\" };\n        let serialized = fancier.serialize();\n        assert(\n            serialized\n                == [\n                    1, 2, 0, 1, 1, 2, 3, 0x6d, 0x65, 0x74, 0x61, 0x70, 0x72, 0x6f, 0x67, 0x72, 0x61,\n                    0x6d, 0x6d, 0x69, 0x6e, 0x67, 0x21,\n                ],\n            serialized,\n        );\n        let deserialized = Fancier::deserialize(serialized);\n        assert(deserialized == fancier);\n    }\n\n    #[test]\n    fn serde_on_contains_array_with_generics() {\n        let struct_with_array_of_generics = HasArrayWithGenerics { fields: [1, 2, 3], length: 3 };\n        let serialized = struct_with_array_of_generics.serialize();\n        assert(serialized == [1, 2, 3, 3], serialized);\n        let deserialized = HasArrayWithGenerics::deserialize(serialized);\n        assert(deserialized == struct_with_array_of_generics);\n    }\n\n    #[test]\n    fn packable_on_contains_array_with_generics() {\n        let struct_with_array_of_generics = HasArrayWithGenerics { fields: [1, 2, 3], length: 3 };\n        let packed = struct_with_array_of_generics.pack();\n        assert(packed == [1, 2, 3, 3], packed);\n\n        let unpacked = HasArrayWithGenerics::unpack(packed);\n        assert(unpacked == struct_with_array_of_generics);\n    }\n\n}\n","path":"/home/filip/nargo/github.com/AztecProtocol/aztec-packages/v3.0.1-rc.1/noir-projects/noir-protocol-circuits/crates/types/src/meta/mod.nr"},"353":{"source":"/// Generates serialization code for a list of parameters and the total length of the serialized array\n///\n/// # Parameters\n/// - `params`: A list of (name, type) tuples to serialize\n/// - `use_self_prefix`: If true, parameters are accessed as `self.$param_name` (for struct members).\n///                      If false, parameters are accessed directly as `$param_name` (for function parameters).\n///\n/// # Returns\n/// A tuple containing:\n/// - Quoted code that serializes the parameters into an array named `serialized_params`\n/// - Quoted code that evaluates to the total length of the serialized array\n/// - Quoted code containing the name of the serialized array\npub comptime fn derive_serialization_quotes(\n    params: [(Quoted, Type)],\n    use_self_prefix: bool,\n) -> (Quoted, Quoted, Quoted) {\n    let prefix_quote = if use_self_prefix {\n        quote { self. }\n    } else {\n        quote {}\n    };\n\n    let params_len_quote = get_params_len_quote(params);\n    let serialized_params_name = quote { serialized_params };\n\n    let body = if params.len() == 0 {\n        quote {\n            let $serialized_params_name: [Field; 0] = [];\n        }\n    } else if params.len() == 1 {\n        // When we have only a single parameter on the input, we can enhance performance by directly returning\n        // the serialized member, bypassing the need for loop-based array construction. While this optimization yields\n        // significant benefits in Brillig where the loops are expected to not be optimized, it is not relevant in ACIR\n        // where the loops are expected to be optimized away.\n\n        let param_name = params[0].0;\n        quote {\n            let $serialized_params_name = $crate::traits::Serialize::serialize($prefix_quote$param_name);\n        }\n    } else {\n        // For multiple struct members, generate serialization code that:\n        // 1. Serializes each member\n        // 2. Copies the serialized fields into the serialize array at the correct offset\n        // 3. Updates the offset for the next member\n        let serialization_of_struct_members = params\n            .map(|(param_name, param_type): (Quoted, Type)| {\n                quote {\n                let serialized_member = $crate::traits::Serialize::serialize($prefix_quote$param_name);\n                let serialized_member_len = <$param_type as $crate::traits::Serialize>::N;\n                for i in 0..serialized_member_len {\n                    $serialized_params_name[i + offset] = serialized_member[i];\n                }\n                offset += serialized_member_len;\n            }\n            })\n            .join(quote {});\n\n        quote {\n            let mut $serialized_params_name = [0; $params_len_quote];\n            let mut offset = 0;\n\n            $serialization_of_struct_members\n        }\n    };\n\n    (body, params_len_quote, serialized_params_name)\n}\n\n/// Generates a quoted expression that computes the total serialized length of function parameters.\n///\n/// # Parameters\n/// * `params` - An array of tuples where each tuple contains a quoted parameter name and its Type. The type needs\n///              to implement the Serialize trait.\n///\n/// # Returns\n/// A quoted expression that evaluates to:\n/// * `0` if there are no parameters\n/// * `(<type1 as Serialize>::N + <type2 as Serialize>::N + ...)` for one or more parameters\npub comptime fn get_params_len_quote(params: [(Quoted, Type)]) -> Quoted {\n    if params.len() == 0 {\n        quote { 0 }\n    } else {\n        let params_quote_without_parentheses = params\n            .map(|(_, param_type): (Quoted, Type)| {\n                quote {\n                    <$param_type as $crate::traits::Serialize>::N\n                }\n            })\n            .join(quote {+});\n        quote { ($params_quote_without_parentheses) }\n    }\n}\n","path":"/home/filip/nargo/github.com/AztecProtocol/aztec-packages/v3.0.1-rc.1/noir-projects/noir-protocol-circuits/crates/types/src/meta/utils.nr"},"355":{"source":"use crate::constants::TWO_POW_64;\nuse crate::traits::{Deserialize, Serialize};\nuse std::meta::derive;\n// NB: This is a clone of noir/noir-repo/noir_stdlib/src/hash/poseidon2.nr\n// It exists as we sometimes need to perform custom absorption, but the stdlib version\n// has a private absorb() method (it's also designed to just be a hasher)\n// Can be removed when standalone noir poseidon lib exists: See noir#6679\n\ncomptime global RATE: u32 = 3;\n\n#[derive(Deserialize, Eq, Serialize)]\npub struct Poseidon2Sponge {\n    pub cache: [Field; 3],\n    pub state: [Field; 4],\n    pub cache_size: u32,\n    pub squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2Sponge {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2Sponge::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2Sponge {\n        let mut result =\n            Poseidon2Sponge { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = std::hash::poseidon2_permutation(self.state, 4);\n    }\n\n    pub fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    pub fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let iv: Field = (in_len as Field) * TWO_POW_64;\n        let mut sponge = Poseidon2Sponge::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n","path":"/home/filip/nargo/github.com/AztecProtocol/aztec-packages/v3.0.1-rc.1/noir-projects/noir-protocol-circuits/crates/types/src/poseidon2.nr"},"367":{"source":"use crate::{hash::poseidon2_hash, traits::ToField};\n\npub fn derive_storage_slot_in_map<K>(storage_slot: Field, key: K) -> Field\nwhere\n    K: ToField,\n{\n    poseidon2_hash([storage_slot, key.to_field()])\n}\n\nmod test {\n    use crate::{address::AztecAddress, storage::map::derive_storage_slot_in_map, traits::FromField};\n\n    #[test]\n    fn test_derive_storage_slot_in_map_matches_typescript() {\n        let map_slot = 0x132258fb6962c4387ba659d9556521102d227549a386d39f0b22d1890d59c2b5;\n        let key = AztecAddress::from_field(\n            0x302dbc2f9b50a73283d5fb2f35bc01eae8935615817a0b4219a057b2ba8a5a3f,\n        );\n\n        let slot = derive_storage_slot_in_map(map_slot, key);\n\n        // The following value was generated by `map_slot.test.ts`\n        let slot_from_typescript =\n            0x15b9fe39449affd8b377461263e9d2b610b9ad40580553500b4e41d9cbd887ac;\n\n        assert_eq(slot, slot_from_typescript);\n    }\n}\n","path":"/home/filip/nargo/github.com/AztecProtocol/aztec-packages/v3.0.1-rc.1/noir-projects/noir-protocol-circuits/crates/types/src/storage/map.nr"},"383":{"source":"use crate::meta::{derive_deserialize, derive_packable, derive_serialize};\nuse crate::utils::field::field_from_bytes;\n\n// Trait: is_empty\n//\n// The general is_empty trait checks if a data type is is empty,\n// and it defines empty for the basic data types as 0.\n//\n// If a Field is equal to zero, then it is regarded as zero.\n// We will go with this definition for now, however it can be problematic\n// if a value can actually be zero. In a future refactor, we can\n// use the optional type for safety. Doing it now would lead to a worse devex\n// and would make it harder to sync up with the cpp code.\n// Preferred over Default trait to convey intent, as default doesn't necessarily mean empty.\npub trait Empty: Eq {\n    fn empty() -> Self;\n\n    fn is_empty(self) -> bool {\n        self.eq(Self::empty())\n    }\n\n    // Requires this Noir fix: https://github.com/noir-lang/noir/issues/9002\n    // fn assert_not_empty<let U: u32>(self, msg: str<U>) { // This msg version was failing with weird compiler errors.\n    //     // We provide a default impl but it's likely inefficient.\n    //     // The reason we include this function is because there's a lot of\n    //     // opportunity for optimisation on a per-struct basis.\n    //     // You only need to show one element is not empty to know that the whole thing\n    //     // is not empty.\n    //     // If you know an element of your struct which should always be nonempty,\n    //     // you can write an impl that solely checks that that element is nonempty.\n    //     assert(!self.is_empty(), msg);\n    // }\n\n    // This default impl is overwritten by types like arrays, because there's a much\n    // more efficient approach.\n    fn assert_empty<let S: u32>(self, msg: str<S>) {\n        assert(self.is_empty(), msg);\n    }\n}\n\nimpl Empty for Field {\n    #[inline_always]\n    fn empty() -> Self {\n        0\n    }\n}\n\nimpl Empty for bool {\n    #[inline_always]\n    fn empty() -> Self {\n        false\n    }\n}\n\nimpl Empty for u1 {\n    #[inline_always]\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u8 {\n    #[inline_always]\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u16 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u32 {\n    #[inline_always]\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u64 {\n    #[inline_always]\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u128 {\n    #[inline_always]\n    fn empty() -> Self {\n        0\n    }\n}\n\nimpl<T, let N: u32> Empty for [T; N]\nwhere\n    T: Empty,\n{\n    #[inline_always]\n    fn empty() -> Self {\n        [T::empty(); N]\n    }\n\n    fn is_empty(self) -> bool {\n        self.all(|elem| elem.is_empty())\n    }\n\n    fn assert_empty<let S: u32>(self, msg: str<S>) -> () {\n        self.for_each(|elem| elem.assert_empty(msg))\n    }\n}\n\nimpl<T> Empty for [T]\nwhere\n    T: Empty,\n{\n    #[inline_always]\n    fn empty() -> Self {\n        [T::empty()]\n    }\n\n    fn is_empty(self) -> bool {\n        self.all(|elem| elem.is_empty())\n    }\n\n    fn assert_empty<let S: u32>(self, msg: str<S>) -> () {\n        self.for_each(|elem| elem.assert_empty(msg))\n    }\n}\nimpl<A, B> Empty for (A, B)\nwhere\n    A: Empty,\n    B: Empty,\n{\n    #[inline_always]\n    fn empty() -> Self {\n        (A::empty(), B::empty())\n    }\n}\n\nimpl<T> Empty for Option<T>\nwhere\n    T: Eq,\n{\n    #[inline_always]\n    fn empty() -> Self {\n        Option::none()\n    }\n}\n\n// pub fn is_empty<T>(item: T) -> bool\n// where\n//     T: Empty,\n// {\n//     item.eq(T::empty())\n// }\n\n// pub fn is_empty_array<T, let N: u32>(array: [T; N]) -> bool\n// where\n//     T: Empty,\n// {\n//     array.all(|elem| is_empty(elem))\n// }\n\n// pub fn assert_empty<T>(item: T) -> ()\n// where\n//     T: Empty,\n// {\n//     assert(item.eq(T::empty()))\n// }\n\n// pub fn assert_empty_array<T, let N: u32>(array: [T; N]) -> ()\n// where\n//     T: Empty,\n// {\n//     // A cheaper option than `is_empty_array` for if you don't need to gracefully\n//     // handle a bool result.\n//     // Avoids the `&` operator of `is_empty_array`'s `.all()` call.\n//     for i in 0..N {\n//         assert(is_empty(array[i]));\n//     }\n// }\n\npub trait Hash {\n    fn hash(self) -> Field;\n}\n\npub trait ToField {\n    fn to_field(self) -> Field;\n}\n\nimpl ToField for Field {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self\n    }\n}\n\nimpl ToField for bool {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u1 {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u8 {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u16 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u32 {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u64 {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u128 {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl<let N: u32> ToField for str<N> {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        assert(N < 32, \"String doesn't fit in a field, consider using Serialize instead\");\n        field_from_bytes(self.as_bytes(), true)\n    }\n}\n\npub trait FromField {\n    fn from_field(value: Field) -> Self;\n}\n\nimpl FromField for Field {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value\n    }\n}\n\nimpl FromField for bool {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value != 0\n    }\n}\nimpl FromField for u1 {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value as u1\n    }\n}\nimpl FromField for u8 {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value as u8\n    }\n}\nimpl FromField for u16 {\n    fn from_field(value: Field) -> Self {\n        value as u16\n    }\n}\nimpl FromField for u32 {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value as u32\n    }\n}\nimpl FromField for u64 {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value as u64\n    }\n}\nimpl FromField for u128 {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value as u128\n    }\n}\n\n// docs:start:serialize\n/// Trait for serializing Noir types into arrays of Fields.\n///\n/// An implementation of the Serialize trait has to follow Noir's intrinsic serialization (each member of a struct\n/// converted directly into one or more Fields without any packing or compression). This trait (and Deserialize) are\n/// typically used to communicate between Noir and TypeScript (via oracles and function arguments).\n///\n/// # On Following Noir's Intrinsic Serialization\n/// When calling a Noir function from TypeScript (TS), first the function arguments are serialized into an array\n/// of fields. This array is then included in the initial witness. Noir's intrinsic serialization is then used\n/// to deserialize the arguments from the witness. When the same Noir function is called from Noir this Serialize trait\n/// is used instead of the serialization in TS. For this reason we need to have a match between TS serialization,\n/// Noir's intrinsic serialization and the implementation of this trait. If there is a mismatch, the function calls\n/// fail with an arguments hash mismatch error message.\n///\n/// # Associated Constants\n/// * `N` - The length of the output Field array, known at compile time\n///\n/// # Example\n/// ```\n/// impl<let N: u32> Serialize for str<N> {\n///     let N: u32 = N;\n///\n///     fn serialize(self) -> [Field; Self::N] {\n///         let bytes = self.as_bytes();\n///         let mut fields = [0; Self::N];\n///         for i in 0..bytes.len() {\n///             fields[i] = bytes[i] as Field;  // Each byte gets its own Field\n///         }\n///         fields\n///     }\n/// }\n/// ```\n#[derive_via(derive_serialize)]\npub trait Serialize {\n    let N: u32;\n\n    fn serialize(self) -> [Field; N];\n}\n// docs:end:serialize\n\nimpl<let M: u32> Serialize for str<M> {\n    let N: u32 = M;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        let bytes = self.as_bytes();\n        let mut fields = [0; Self::N];\n        for i in 0..bytes.len() {\n            fields[i] = bytes[i] as Field;\n        }\n        fields\n    }\n}\n\n/// Implementation of Deserialize for BoundedVec.\n///\n/// This implementation deserializes a BoundedVec from an array of Fields. The array contains:\n/// 1. The serialized items, each taking up T::N Fields\n/// 2. The length of the BoundedVec as the last Field\n///\n/// # Type Parameters\n/// * `T` - The type of items stored in the BoundedVec, must implement Deserialize\n/// * `M` - The maximum length of the BoundedVec\n///\n/// # Fields Array Layout\n/// [item1_field1, item1_field2, ..., item2_field1, item2_field2, ..., length]\n/// Where:\n/// - itemN_fieldM: The M-th Field of the N-th item (T::N Fields per item)\n/// - length: The number of items in the BoundedVec (1 Field)\n///\n/// Total length N = T::N * M + 1, where:\n/// - T::N is the number of Fields needed to deserialize one item\n/// - M is the maximum length of the BoundedVec\n/// - +1 is for storing the length\n///\n/// # Note\n/// Not deriving this because it's not supported to call derive_deserialize on a \"remote\" struct (and it will never\n/// be supported).\nimpl<T, let M: u32> Deserialize for BoundedVec<T, M>\nwhere\n    T: Deserialize,\n{\n    let N: u32 = <T as Deserialize>::N * M + 1;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        let mut new_bounded_vec: BoundedVec<T, M> = BoundedVec::new();\n\n        // Length is stored in the last field as we need to match intrinsic Noir serialization and the `len` struct\n        // field is after `storage` struct field (see `bounded_vec.nr` in noir-stdlib)\n        let len = fields[<T as Deserialize>::N * M] as u32;\n\n        for i in 0..len {\n            let mut nested_fields = [0; <T as Deserialize>::N];\n            for j in 0..<T as Deserialize>::N {\n                nested_fields[j] = fields[i * <T as Deserialize>::N + j];\n            }\n\n            let item = T::deserialize(nested_fields);\n            new_bounded_vec.push(item);\n        }\n\n        new_bounded_vec\n    }\n}\n\n// This may cause issues if used as program input, because noir disallows empty arrays for program input.\n// I think this is okay because I don't foresee a unit type being used as input. But leaving this comment as a hint\n// if someone does run into this in the future.\nimpl Deserialize for () {\n    let N: u32 = 0;\n\n    fn deserialize(_fields: [Field; Self::N]) -> Self {\n        ()\n    }\n}\n\n// Note: Not deriving this because it's not supported to call derive_serialize on a \"remote\" struct (and it will never\n// be supported).\nimpl<T, let M: u32> Serialize for BoundedVec<T, M>\nwhere\n    T: Serialize,\n{\n    let N: u32 = <T as Serialize>::N * M + 1; // +1 for the length of the BoundedVec\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        let mut fields = [0; Self::N];\n\n        let storage = self.storage();\n\n        for i in 0..M {\n            let serialized_item = storage[i].serialize();\n\n            for j in 0..<T as Serialize>::N {\n                fields[i * <T as Serialize>::N + j] = serialized_item[j];\n            }\n        }\n\n        // Length is stored in the last field as we need to match intrinsic Noir serialization and the `len` struct\n        // field is after `storage` struct field (see `bounded_vec.nr` in noir-stdlib)\n        fields[<T as Serialize>::N * M] = self.len() as Field;\n\n        fields\n    }\n}\n\n// docs:start:deserialize\n/// Trait for deserializing Noir types from arrays of Fields.\n///\n/// An implementation of the Deserialize trait has to follow Noir's intrinsic serialization (each member of a struct\n/// converted directly into one or more Fields without any packing or compression). This trait is typically used when\n/// deserializing return values from function calls in Noir. Since the same function could be called from TypeScript\n/// (TS), in which case the TS deserialization would get used, we need to have a match between the 2.\n///\n/// # Associated Constants\n/// * `N` - The length of the input Field array, known at compile time\n///\n/// # Example\n/// ```\n/// impl<let M: u32> Deserialize for str<M> {\n///     let N: u32 = M;\n///\n///     #[inline_always]\n///     fn deserialize(fields: [Field; Self::N]) -> Self {\n///         str::<Self::N>::from(fields.map(|value| value as u8))\n///     }\n/// }\n/// ```\n#[derive_via(derive_deserialize)]\npub trait Deserialize {\n    let N: u32;\n\n    fn deserialize(fields: [Field; N]) -> Self;\n}\n// docs:end:deserialize\n\nimpl<let M: u32> Deserialize for str<M> {\n    let N: u32 = M;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        str::<Self::N>::from(fields.map(|value| value as u8))\n    }\n}\n\n/// Trait for efficiently packing and unpacking Noir types into and from arrays of Fields.\n///\n/// The `Packable` trait allows types to be serialized and deserialized with a focus on minimizing the size of\n/// the resulting Field array. This trait is used when storage efficiency is critical (e.g. when storing data\n/// in the contract's public storage).\n///\n/// # Associated Constants\n/// * `N` - The length of the Field array, known at compile time\n#[derive_via(derive_packable)]\npub trait Packable {\n    let N: u32;\n\n    /// Packs the current value into a compact array of `Field` elements.\n    fn pack(self) -> [Field; N];\n\n    /// Unpacks a compact array of `Field` elements into the original value.\n    fn unpack(fields: [Field; N]) -> Self;\n}\n\n#[test]\nunconstrained fn bounded_vec_serialization() {\n    // Test empty BoundedVec\n    let empty_vec: BoundedVec<Field, 3> = BoundedVec::from_array([]);\n    let serialized = empty_vec.serialize();\n    let deserialized = BoundedVec::<Field, 3>::deserialize(serialized);\n    assert_eq(empty_vec, deserialized);\n    assert_eq(deserialized.len(), 0);\n\n    // Test partially filled BoundedVec\n    let partial_vec: BoundedVec<[u32; 2], 3> = BoundedVec::from_array([[1, 2]]);\n    let serialized = partial_vec.serialize();\n    let deserialized = BoundedVec::<[u32; 2], 3>::deserialize(serialized);\n    assert_eq(partial_vec, deserialized);\n    assert_eq(deserialized.len(), 1);\n    assert_eq(deserialized.get(0), [1, 2]);\n\n    // Test full BoundedVec\n    let full_vec: BoundedVec<[u32; 2], 3> = BoundedVec::from_array([[1, 2], [3, 4], [5, 6]]);\n    let serialized = full_vec.serialize();\n    let deserialized = BoundedVec::<[u32; 2], 3>::deserialize(serialized);\n    assert_eq(full_vec, deserialized);\n    assert_eq(deserialized.len(), 3);\n    assert_eq(deserialized.get(0), [1, 2]);\n    assert_eq(deserialized.get(1), [3, 4]);\n    assert_eq(deserialized.get(2), [5, 6]);\n}\n","path":"/home/filip/nargo/github.com/AztecProtocol/aztec-packages/v3.0.1-rc.1/noir-projects/noir-protocol-circuits/crates/types/src/traits.nr"},"385":{"source":"use crate::traits::Packable;\n\nglobal BOOL_PACKED_LEN: u32 = 1;\nglobal U8_PACKED_LEN: u32 = 1;\nglobal U16_PACKED_LEN: u32 = 1;\nglobal U32_PACKED_LEN: u32 = 1;\nglobal U64_PACKED_LEN: u32 = 1;\nglobal U128_PACKED_LEN: u32 = 1;\nglobal FIELD_PACKED_LEN: u32 = 1;\nglobal I8_PACKED_LEN: u32 = 1;\nglobal I16_PACKED_LEN: u32 = 1;\nglobal I32_PACKED_LEN: u32 = 1;\nglobal I64_PACKED_LEN: u32 = 1;\n\nimpl Packable for bool {\n    let N: u32 = BOOL_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> bool {\n        (fields[0] as u1) != 0\n    }\n}\n\nimpl Packable for u8 {\n    let N: u32 = U8_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0] as u8\n    }\n}\n\nimpl Packable for u16 {\n    let N: u32 = U16_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0] as u16\n    }\n}\n\nimpl Packable for u32 {\n    let N: u32 = U32_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0] as u32\n    }\n}\n\nimpl Packable for u64 {\n    let N: u32 = U64_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0] as u64\n    }\n}\n\nimpl Packable for u128 {\n    let N: u32 = U128_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0] as u128\n    }\n}\n\nimpl Packable for Field {\n    let N: u32 = FIELD_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0]\n    }\n}\n\nimpl Packable for i8 {\n    let N: u32 = I8_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as u8 as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0] as u8 as i8\n    }\n}\n\nimpl Packable for i16 {\n    let N: u32 = I16_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as u16 as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0] as u16 as i16\n    }\n}\n\nimpl Packable for i32 {\n    let N: u32 = I32_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as u32 as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0] as u32 as i32\n    }\n}\n\nimpl Packable for i64 {\n    let N: u32 = I64_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as u64 as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0] as u64 as i64\n    }\n}\n\nimpl<T, let M: u32> Packable for [T; M]\nwhere\n    T: Packable,\n{\n    let N: u32 = M * <T as Packable>::N;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        let mut result: [Field; Self::N] = std::mem::zeroed();\n        for i in 0..M {\n            let serialized = self[i].pack();\n            for j in 0..<T as Packable>::N {\n                result[i * <T as Packable>::N + j] = serialized[j];\n            }\n        }\n        result\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        let mut reader = crate::utils::reader::Reader::new(fields);\n        let mut result: [T; M] = std::mem::zeroed();\n        reader.read_struct_array::<T, <T as Packable>::N, M>(Packable::unpack, result)\n    }\n}\n\n#[test]\nfn test_u16_packing() {\n    let a: u16 = 10;\n    assert_eq(a, u16::unpack(a.pack()));\n}\n\n#[test]\nfn test_i8_packing() {\n    let a: i8 = -10;\n    assert_eq(a, i8::unpack(a.pack()));\n}\n\n#[test]\nfn test_i16_packing() {\n    let a: i16 = -10;\n    assert_eq(a, i16::unpack(a.pack()));\n}\n\n#[test]\nfn test_i32_packing() {\n    let a: i32 = -10;\n    assert_eq(a, i32::unpack(a.pack()));\n}\n\n#[test]\nfn test_i64_packing() {\n    let a: i64 = -10;\n    assert_eq(a, i64::unpack(a.pack()));\n}\n","path":"/home/filip/nargo/github.com/AztecProtocol/aztec-packages/v3.0.1-rc.1/noir-projects/noir-protocol-circuits/crates/types/src/type_packing.nr"},"386":{"source":"use crate::traits::{Deserialize, Serialize};\n\nglobal U1_SERIALIZED_LEN: u32 = 1;\nglobal BOOL_SERIALIZED_LEN: u32 = 1;\nglobal U8_SERIALIZED_LEN: u32 = 1;\nglobal U16_SERIALIZED_LEN: u32 = 1;\nglobal U32_SERIALIZED_LEN: u32 = 1;\nglobal U64_SERIALIZED_LEN: u32 = 1;\nglobal U128_SERIALIZED_LEN: u32 = 1;\nglobal FIELD_SERIALIZED_LEN: u32 = 1;\nglobal I8_SERIALIZED_LEN: u32 = 1;\nglobal I16_SERIALIZED_LEN: u32 = 1;\nglobal I32_SERIALIZED_LEN: u32 = 1;\nglobal I64_SERIALIZED_LEN: u32 = 1;\n\nimpl Serialize for bool {\n    let N: u32 = BOOL_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize for bool {\n    let N: u32 = BOOL_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> bool {\n        fields[0] != 0\n    }\n}\n\nimpl Serialize for u1 {\n    let N: u32 = U1_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize for u1 {\n    let N: u32 = U1_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u1\n    }\n}\n\nimpl Serialize for u8 {\n    let N: u32 = U8_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize for u8 {\n    let N: u32 = U8_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u8\n    }\n}\n\nimpl Serialize for u16 {\n    let N: u32 = U16_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize for u16 {\n    let N: u32 = U16_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u16\n    }\n}\n\nimpl Serialize for u32 {\n    let N: u32 = U32_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize for u32 {\n    let N: u32 = U32_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u32\n    }\n}\n\nimpl Serialize for u64 {\n    let N: u32 = U64_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize for u64 {\n    let N: u32 = U64_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u64\n    }\n}\n\nimpl Serialize for u128 {\n    let N: u32 = U128_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize for u128 {\n    let N: u32 = U128_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u128\n    }\n}\n\nimpl Serialize for Field {\n    let N: u32 = FIELD_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self]\n    }\n}\n\nimpl Deserialize for Field {\n    let N: u32 = FIELD_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0]\n    }\n}\n\nimpl Serialize for i8 {\n    let N: u32 = I8_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as u8 as Field]\n    }\n}\n\nimpl Deserialize for i8 {\n    let N: u32 = I8_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u8 as i8\n    }\n}\n\nimpl Serialize for i16 {\n    let N: u32 = I16_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as u16 as Field]\n    }\n}\n\nimpl Deserialize for i16 {\n    let N: u32 = I16_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u16 as i16\n    }\n}\n\nimpl Serialize for i32 {\n    let N: u32 = I32_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as u32 as Field]\n    }\n}\n\nimpl Deserialize for i32 {\n    let N: u32 = I32_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u32 as i32\n    }\n}\n\nimpl Serialize for i64 {\n    let N: u32 = I64_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as u64 as Field]\n    }\n}\n\nimpl Deserialize for i64 {\n    let N: u32 = I64_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u64 as i64\n    }\n}\n\nimpl<T, let M: u32> Serialize for [T; M]\nwhere\n    T: Serialize,\n{\n    let N: u32 = <T as Serialize>::N * M;\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        let mut result: [Field; _] = std::mem::zeroed();\n        for i in 0..M {\n            let serialized_t = self[i].serialize();\n            for j in 0..<T as Serialize>::N {\n                result[i * <T as Serialize>::N + j] = serialized_t[j];\n            }\n        }\n        result\n    }\n}\n\nimpl<T, let M: u32> Deserialize for [T; M]\nwhere\n    T: Deserialize,\n{\n    let N: u32 = <T as Deserialize>::N * M;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        let mut reader = crate::utils::reader::Reader::new(fields);\n        let mut result: [T; M] = std::mem::zeroed();\n        reader.read_struct_array::<T, <T as Deserialize>::N, M>(Deserialize::deserialize, result)\n    }\n}\n\nimpl<T> Serialize for Option<T>\nwhere\n    T: Serialize,\n{\n    let N: u32 = <T as Serialize>::N + 1;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        let mut result: [Field; Self::N] = std::mem::zeroed();\n\n        result[0] = if self.is_some() { 1 } else { 0 };\n\n        let value_serialized = self.unwrap_unchecked().serialize();\n        for i in 0..<T as Serialize>::N {\n            result[1 + i] = value_serialized[i];\n        }\n\n        result\n    }\n}\n\nimpl<T> Deserialize for Option<T>\nwhere\n    T: Deserialize,\n{\n    let N: u32 = <T as Deserialize>::N + 1;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        if fields[0] == 1 {\n            let mut value_fields = [0; <T as Deserialize>::N];\n            for i in 0..<T as Deserialize>::N {\n                value_fields[i] = fields[1 + i];\n            }\n\n            Option::some(T::deserialize(value_fields))\n        } else {\n            Option::none()\n        }\n    }\n}\n\nmod test {\n    use crate::traits::{Deserialize, Serialize};\n\n    #[test]\n    fn u16_serialization() {\n        let a: u16 = 10;\n        assert_eq(a, u16::deserialize(a.serialize()));\n    }\n\n    #[test]\n    fn i8_serialization() {\n        let a: i8 = -10;\n        assert_eq(a, i8::deserialize(a.serialize()));\n    }\n\n    #[test]\n    fn i16_serialization() {\n        let a: i16 = -10;\n        assert_eq(a, i16::deserialize(a.serialize()));\n    }\n\n    #[test]\n    fn i32_serialization() {\n        let a: i32 = -10;\n        assert_eq(a, i32::deserialize(a.serialize()));\n    }\n\n    #[test]\n    fn i64_serialization() {\n        let a: i64 = -10;\n        assert_eq(a, i64::deserialize(a.serialize()));\n    }\n\n    #[test]\n    fn option_field_serialization() {\n        let opt_some = Option::some(5);\n        assert_eq(Option::<_>::deserialize(opt_some.serialize()), opt_some);\n\n        let opt_none = Option::none();\n        assert_eq(Option::<Field>::deserialize(opt_none.serialize()), opt_none);\n    }\n\n    #[test]\n    fn array_serialization() {\n        let array = [1, 2, 3, 4];\n\n        let serialized: [Field; 4] = array.serialize();\n        let deserialized: [Field; 4] = Deserialize::deserialize(serialized);\n        assert_eq(deserialized, array);\n    }\n\n    #[test]\n    fn nested_array_serialization() {\n        let nested_array = [[1, 2, 3, 4], [5, 6, 7, 8]];\n\n        let serialized: [Field; 8] = nested_array.serialize();\n        let deserialized: [[Field; 4]; 2] = Deserialize::deserialize(serialized);\n\n        assert_eq(deserialized, nested_array);\n    }\n\n    #[test]\n    fn option_array_serialization() {\n        let opt_some = Option::some([2, 5]);\n        assert_eq(Option::<_>::deserialize(opt_some.serialize()), opt_some);\n\n        let opt_none = Option::none();\n        assert_eq(Option::<Field>::deserialize(opt_none.serialize()), opt_none);\n    }\n}\n","path":"/home/filip/nargo/github.com/AztecProtocol/aztec-packages/v3.0.1-rc.1/noir-projects/noir-protocol-circuits/crates/types/src/type_serialization.nr"},"391":{"source":"global KNOWN_NON_RESIDUE: Field = 5; // This is a non-residue in Noir's native Field.\n\npub fn field_from_bytes<let N: u32>(bytes: [u8; N], big_endian: bool) -> Field {\n    assert(bytes.len() < 32, \"field_from_bytes: N must be less than 32\");\n    let mut as_field = 0;\n    let mut offset = 1;\n    for i in 0..N {\n        let mut index = i;\n        if big_endian {\n            index = N - i - 1;\n        }\n        as_field += (bytes[index] as Field) * offset;\n        offset *= 256;\n    }\n\n    as_field\n}\n\n// Convert a 32 byte array to a field element by truncating the final byte\npub fn field_from_bytes_32_trunc(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..15 {\n        // covers bytes 16..30 (31 is truncated and ignored)\n        low = low + (bytes32[15 + 15 - i] as Field) * v;\n        v = v * 256;\n        // covers bytes 0..14\n        high = high + (bytes32[14 - i] as Field) * v;\n    }\n    // covers byte 15\n    low = low + (bytes32[15] as Field) * v;\n\n    low + high * v\n}\n\n// TODO to radix returns u8, so we cannot use bigger radixes. It'd be ideal to use a radix of the maximum range-constrained integer noir supports\npub fn full_field_less_than(lhs: Field, rhs: Field) -> bool {\n    lhs.lt(rhs)\n}\n\npub fn full_field_greater_than(lhs: Field, rhs: Field) -> bool {\n    rhs.lt(lhs)\n}\n\npub fn min(f1: Field, f2: Field) -> Field {\n    if f1.lt(f2) {\n        f1\n    } else {\n        f2\n    }\n}\n\nglobal C1: u32 = 28;\nglobal C3: Field = 40770029410420498293352137776570907027550720424234931066070132305055;\nglobal C5: Field = 19103219067921713944291392827692070036145651957329286315305642004821462161904;\n\npub fn pow(x: Field, y: Field) -> Field {\n    let mut r = 1 as Field;\n    let b: [u1; 254] = y.to_le_bits();\n\n    for i in 0..254 {\n        r *= r;\n        r *= (b[254 - 1 - i] as Field) * x + (1 - b[254 - 1 - i] as Field);\n    }\n\n    r\n}\n\n/// Returns Option::some(sqrt) if there is a square root, and Option::none() if there isn't.\npub fn sqrt(x: Field) -> Option<Field> {\n    // Safety: if the hint returns the square root of x, then we simply square it\n    // check the result equals x. If x is not square, we return a value that\n    // enables us to prove that fact (see the `else` clause below).\n    let (is_sq, maybe_sqrt) = unsafe { __sqrt(x) };\n\n    if is_sq {\n        let sqrt = maybe_sqrt;\n        validate_sqrt_hint(x, sqrt);\n        Option::some(sqrt)\n    } else {\n        let not_sqrt_hint = maybe_sqrt;\n        validate_not_sqrt_hint(x, not_sqrt_hint);\n        Option::none()\n    }\n}\n\n// Boolean indicating whether Field element is a square, i.e. whether there exists a y in Field s.t. x = y*y.\nunconstrained fn is_square(x: Field) -> bool {\n    let v = pow(x, -1 / 2);\n    v * (v - 1) == 0\n}\n\n// Tonelli-Shanks algorithm for computing the square root of a Field element.\n// Requires C1 = max{c: 2^c divides (p-1)}, where p is the order of Field\n// as well as C3 = (C2 - 1)/2, where C2 = (p-1)/(2^c1),\n// and C5 = ZETA^C2, where ZETA is a non-square element of Field.\n// These are pre-computed above as globals.\nunconstrained fn tonelli_shanks_sqrt(x: Field) -> Field {\n    let mut z = pow(x, C3);\n    let mut t = z * z * x;\n    z *= x;\n    let mut b = t;\n    let mut c = C5;\n\n    for i in 0..(C1 - 1) {\n        for _j in 1..(C1 - i - 1) {\n            b *= b;\n        }\n\n        z *= if b == 1 { 1 } else { c };\n\n        c *= c;\n\n        t *= if b == 1 { 1 } else { c };\n\n        b = t;\n    }\n\n    z\n}\n\n// NB: this doesn't return an option, because in the case of there _not_ being a square root, we still want to return a field element that allows us to then assert in the _constrained_ sqrt function that there is no sqrt.\nunconstrained fn __sqrt(x: Field) -> (bool, Field) {\n    let is_sq = is_square(x);\n    if is_sq {\n        let sqrt = tonelli_shanks_sqrt(x);\n        (true, sqrt)\n    } else {\n        // Demonstrate that x is not a square (a.k.a. a \"quadratic non-residue\").\n        // Facts:\n        // The Legendre symbol (\"LS\") of x, is x^((p-1)/2) (mod p).\n        // - If x is a square, LS(x) = 1\n        // - If x is not a square, LS(x) = -1\n        // - If x = 0, LS(x) = 0.\n        //\n        // Hence:\n        // sq * sq = sq // 1 * 1 = 1\n        // non-sq * non-sq = sq // -1 * -1 = 1\n        // sq * non-sq = non-sq // -1 * 1 = -1\n        //\n        // See: https://en.wikipedia.org/wiki/Legendre_symbol\n        let demo_x_not_square = x * KNOWN_NON_RESIDUE;\n        let not_sqrt = tonelli_shanks_sqrt(demo_x_not_square);\n        (false, not_sqrt)\n    }\n}\n\nfn validate_sqrt_hint(x: Field, hint: Field) {\n    assert(hint * hint == x, f\"The claimed_sqrt {hint} is not the sqrt of x {x}\");\n}\n\nfn validate_not_sqrt_hint(x: Field, hint: Field) {\n    // We need this assertion, because x = 0 would pass the other assertions in this\n    // function, and we don't want people to be able to prove that 0 is not square!\n    assert(x != 0, \"0 has a square root; you cannot claim it is not square\");\n    // Demonstrate that x is not a square (a.k.a. a \"quadratic non-residue\").\n    //\n    // Facts:\n    // The Legendre symbol (\"LS\") of x, is x^((p-1)/2) (mod p).\n    // - If x is a square, LS(x) = 1\n    // - If x is not a square, LS(x) = -1\n    // - If x = 0, LS(x) = 0.\n    //\n    // Hence:\n    // 1. sq * sq = sq // 1 * 1 = 1\n    // 2. non-sq * non-sq = sq // -1 * -1 = 1\n    // 3. sq * non-sq = non-sq // -1 * 1 = -1\n    //\n    // See: https://en.wikipedia.org/wiki/Legendre_symbol\n    //\n    // We want to demonstrate that this below multiplication falls under bullet-point (2):\n    let demo_x_not_square = x * KNOWN_NON_RESIDUE;\n    // I.e. we want to demonstrate that `demo_x_not_square` has Legendre symbol 1\n    // (i.e. that it is a square), so we prove that it is square below.\n    // Why do we want to prove that it has LS 1?\n    // Well, since it was computed with a known-non-residue, its squareness implies we're\n    // in case 2 (something multiplied by a known-non-residue yielding a result which\n    // has a LS of 1), which implies that x must be a non-square. The unconstrained\n    // function gave us the sqrt of demo_x_not_square, so all we need to do is\n    // assert its squareness:\n    assert(\n        hint * hint == demo_x_not_square,\n        f\"The hint {hint} does not demonstrate that {x} is not a square\",\n    );\n}\n\n#[test]\nunconstrained fn bytes_field_test() {\n    // Tests correctness of field_from_bytes_32_trunc against existing methods\n    // Bytes representing 0x543e0a6642ffeb8039296861765a53407bba62bd1c97ca43374de950bbe0a7\n    let inputs = [\n        84, 62, 10, 102, 66, 255, 235, 128, 57, 41, 104, 97, 118, 90, 83, 64, 123, 186, 98, 189, 28,\n        151, 202, 67, 55, 77, 233, 80, 187, 224, 167,\n    ];\n    let field = field_from_bytes(inputs, true);\n    let return_bytes: [u8; 31] = field.to_be_bytes();\n    assert_eq(inputs, return_bytes);\n    // 32 bytes - we remove the final byte, and check it matches the field\n    let inputs2 = [\n        84, 62, 10, 102, 66, 255, 235, 128, 57, 41, 104, 97, 118, 90, 83, 64, 123, 186, 98, 189, 28,\n        151, 202, 67, 55, 77, 233, 80, 187, 224, 167, 158,\n    ];\n    let field2 = field_from_bytes_32_trunc(inputs2);\n    let return_bytes2: [u8; 31] = field.to_be_bytes();\n\n    assert_eq(return_bytes2, return_bytes);\n    assert_eq(field2, field);\n}\n\n#[test]\nunconstrained fn max_field_test() {\n    // Tests the hardcoded value in constants.nr vs underlying modulus\n    // NB: We can't use 0-1 in constants.nr as it will be transpiled incorrectly to ts and sol constants files\n    let max_value = crate::constants::MAX_FIELD_VALUE;\n    assert_eq(max_value, 0 - 1);\n    // modulus == 0 is tested elsewhere, so below is more of a sanity check\n    let max_bytes: [u8; 32] = max_value.to_be_bytes();\n    let mod_bytes = std::field::modulus_be_bytes();\n    for i in 0..31 {\n        assert_eq(max_bytes[i], mod_bytes[i]);\n    }\n    assert_eq(max_bytes[31], mod_bytes[31] - 1);\n}\n\n#[test]\nunconstrained fn sqrt_valid_test() {\n    let x = 16; // examples: 16, 9, 25, 81\n    let result = sqrt(x);\n    assert(result.is_some());\n    assert_eq(result.unwrap() * result.unwrap(), x);\n}\n\n#[test]\nunconstrained fn sqrt_invalid_test() {\n    let x = KNOWN_NON_RESIDUE; // has no square root in the field\n    let result = sqrt(x);\n    assert(result.is_none());\n}\n","path":"/home/filip/nargo/github.com/AztecProtocol/aztec-packages/v3.0.1-rc.1/noir-projects/noir-protocol-circuits/crates/types/src/utils/field.nr"},"395":{"source":"pub struct Reader<let N: u32> {\n    data: [Field; N],\n    offset: u32,\n}\n\nimpl<let N: u32> Reader<N> {\n    pub fn new(data: [Field; N]) -> Self {\n        Self { data, offset: 0 }\n    }\n\n    pub fn read(&mut self) -> Field {\n        let result = self.data[self.offset];\n        self.offset += 1;\n        result\n    }\n\n    pub fn read_u32(&mut self) -> u32 {\n        self.read() as u32\n    }\n\n    pub fn read_u64(&mut self) -> u64 {\n        self.read() as u64\n    }\n\n    pub fn read_bool(&mut self) -> bool {\n        self.read() != 0\n    }\n\n    pub fn read_array<let K: u32>(&mut self) -> [Field; K] {\n        let mut result = [0; K];\n        for i in 0..K {\n            result[i] = self.data[self.offset + i];\n        }\n        self.offset += K;\n        result\n    }\n\n    pub fn read_struct<T, let K: u32>(&mut self, deserialise: fn([Field; K]) -> T) -> T {\n        let result = deserialise(self.read_array());\n        result\n    }\n\n    pub fn read_struct_array<T, let K: u32, let C: u32>(\n        &mut self,\n        deserialise: fn([Field; K]) -> T,\n        mut result: [T; C],\n    ) -> [T; C] {\n        for i in 0..C {\n            result[i] = self.read_struct(deserialise);\n        }\n        result\n    }\n\n    pub fn finish(self) {\n        assert_eq(self.offset, self.data.len(), \"Reader did not read all data\");\n    }\n}\n","path":"/home/filip/nargo/github.com/AztecProtocol/aztec-packages/v3.0.1-rc.1/noir-projects/noir-protocol-circuits/crates/types/src/utils/reader.nr"}}}